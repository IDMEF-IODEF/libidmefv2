# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Idmefv2;
use base qw(Exporter);
use base qw(DynaLoader);
package Idmefv2c;
bootstrap Idmefv2;
package Idmefv2;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Idmefv2;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Idmefv2;


############# Class : Idmefv2::LibIdmefv2Error ##############

package Idmefv2::LibIdmefv2Error;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_LibIdmefv2Error($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_LibIdmefv2Error(@_);
    bless $self, $pkg if defined($self);
}

*getCode = *Idmefv2c::LibIdmefv2Error_getCode;
*what = *Idmefv2c::LibIdmefv2Error_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Criterion ##############

package Idmefv2::IDMEFV2Criterion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
*OPERATOR_NOT = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT;
*OPERATOR_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOCASE;
*OPERATOR_EQUAL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_EQUAL;
*OPERATOR_EQUAL_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_EQUAL_NOCASE;
*OPERATOR_NOT_EQUAL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_EQUAL;
*OPERATOR_NOT_EQUAL_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_EQUAL_NOCASE;
*OPERATOR_LESSER = *Idmefv2c::IDMEFV2Criterion_OPERATOR_LESSER;
*OPERATOR_LESSER_OR_EQUAL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_LESSER_OR_EQUAL;
*OPERATOR_GREATER = *Idmefv2c::IDMEFV2Criterion_OPERATOR_GREATER;
*OPERATOR_GREATER_OR_EQUAL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_GREATER_OR_EQUAL;
*OPERATOR_SUBSTR = *Idmefv2c::IDMEFV2Criterion_OPERATOR_SUBSTR;
*OPERATOR_SUBSTR_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_SUBSTR_NOCASE;
*OPERATOR_NOT_SUBSTR = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_SUBSTR;
*OPERATOR_NOT_SUBSTR_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_SUBSTR_NOCASE;
*OPERATOR_REGEX = *Idmefv2c::IDMEFV2Criterion_OPERATOR_REGEX;
*OPERATOR_REGEX_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_REGEX_NOCASE;
*OPERATOR_NOT_REGEX = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_REGEX;
*OPERATOR_NOT_REGEX_NOCASE = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_REGEX_NOCASE;
*OPERATOR_NULL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NULL;
*OPERATOR_NOT_NULL = *Idmefv2c::IDMEFV2Criterion_OPERATOR_NOT_NULL;
sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Criterion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Criterion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Criteria ##############

package Idmefv2::IDMEFV2Criteria;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Criteria($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Criteria(@_);
    bless $self, $pkg if defined($self);
}

*match = *Idmefv2c::IDMEFV2Criteria_match;
*clone = *Idmefv2c::IDMEFV2Criteria_clone;
*andCriteria = *Idmefv2c::IDMEFV2Criteria_andCriteria;
*orCriteria = *Idmefv2c::IDMEFV2Criteria_orCriteria;
*toString = *Idmefv2c::IDMEFV2Criteria_toString;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Value ##############

package Idmefv2::IDMEFV2Value;
use overload
    "<=" => sub { $_[0]->__le__($_[1])},
    ">=" => sub { $_[0]->__ge__($_[1])},
    "<" => sub { $_[0]->__lt__($_[1])},
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
*TYPE_UNKNOWN = *Idmefv2c::IDMEFV2Value_TYPE_UNKNOWN;
*TYPE_INT8 = *Idmefv2c::IDMEFV2Value_TYPE_INT8;
*TYPE_UINT8 = *Idmefv2c::IDMEFV2Value_TYPE_UINT8;
*TYPE_INT16 = *Idmefv2c::IDMEFV2Value_TYPE_INT16;
*TYPE_UINT16 = *Idmefv2c::IDMEFV2Value_TYPE_UINT16;
*TYPE_INT32 = *Idmefv2c::IDMEFV2Value_TYPE_INT32;
*TYPE_UINT32 = *Idmefv2c::IDMEFV2Value_TYPE_UINT32;
*TYPE_INT64 = *Idmefv2c::IDMEFV2Value_TYPE_INT64;
*TYPE_UINT64 = *Idmefv2c::IDMEFV2Value_TYPE_UINT64;
*TYPE_FLOAT = *Idmefv2c::IDMEFV2Value_TYPE_FLOAT;
*TYPE_DOUBLE = *Idmefv2c::IDMEFV2Value_TYPE_DOUBLE;
*TYPE_STRING = *Idmefv2c::IDMEFV2Value_TYPE_STRING;
*TYPE_TIME = *Idmefv2c::IDMEFV2Value_TYPE_TIME;
*TYPE_DATA = *Idmefv2c::IDMEFV2Value_TYPE_DATA;
*TYPE_ENUM = *Idmefv2c::IDMEFV2Value_TYPE_ENUM;
*TYPE_LIST = *Idmefv2c::IDMEFV2Value_TYPE_LIST;
*TYPE_CLASS = *Idmefv2c::IDMEFV2Value_TYPE_CLASS;
*getType = *Idmefv2c::IDMEFV2Value_getType;
*isNull = *Idmefv2c::IDMEFV2Value_isNull;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Value($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Value(@_);
    bless $self, $pkg if defined($self);
}

*match = *Idmefv2c::IDMEFV2Value_match;
*clone = *Idmefv2c::IDMEFV2Value_clone;
*toString = *Idmefv2c::IDMEFV2Value_toString;
*__le__ = *Idmefv2c::IDMEFV2Value___le__;
*__ge__ = *Idmefv2c::IDMEFV2Value___ge__;
*__lt__ = *Idmefv2c::IDMEFV2Value___lt__;
*__gt__ = *Idmefv2c::IDMEFV2Value___gt__;
*__eq__ = *Idmefv2c::IDMEFV2Value___eq__;
*__ne__ = *Idmefv2c::IDMEFV2Value___ne__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Path ##############

package Idmefv2::IDMEFV2Path;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Path(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Path($self);
        delete $OWNER{$self};
    }
}

*set = *Idmefv2c::IDMEFV2Path_set;
*getClass = *Idmefv2c::IDMEFV2Path_getClass;
*getValueType = *Idmefv2c::IDMEFV2Path_getValueType;
*setIndex = *Idmefv2c::IDMEFV2Path_setIndex;
*undefineIndex = *Idmefv2c::IDMEFV2Path_undefineIndex;
*getIndex = *Idmefv2c::IDMEFV2Path_getIndex;
*makeChild = *Idmefv2c::IDMEFV2Path_makeChild;
*makeParent = *Idmefv2c::IDMEFV2Path_makeParent;
*compare = *Idmefv2c::IDMEFV2Path_compare;
*clone = *Idmefv2c::IDMEFV2Path_clone;
*checkOperator = *Idmefv2c::IDMEFV2Path_checkOperator;
*getApplicableOperators = *Idmefv2c::IDMEFV2Path_getApplicableOperators;
*getName = *Idmefv2c::IDMEFV2Path_getName;
*isAmbiguous = *Idmefv2c::IDMEFV2Path_isAmbiguous;
*hasLists = *Idmefv2c::IDMEFV2Path_hasLists;
*isList = *Idmefv2c::IDMEFV2Path_isList;
*getDepth = *Idmefv2c::IDMEFV2Path_getDepth;
*get = *Idmefv2c::IDMEFV2Path_get;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Time ##############

package Idmefv2::IDMEFV2Time;
use overload
    "<=" => sub { $_[0]->__le__($_[1])},
    "!=" => sub { $_[0]->__ne__($_[1])},
    ">=" => sub { $_[0]->__ge__($_[1])},
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Time(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Time($self);
        delete $OWNER{$self};
    }
}

*set = *Idmefv2c::IDMEFV2Time_set;
*setSec = *Idmefv2c::IDMEFV2Time_setSec;
*setUSec = *Idmefv2c::IDMEFV2Time_setUSec;
*setGmtOffset = *Idmefv2c::IDMEFV2Time_setGmtOffset;
*getSec = *Idmefv2c::IDMEFV2Time_getSec;
*getUSec = *Idmefv2c::IDMEFV2Time_getUSec;
*getGmtOffset = *Idmefv2c::IDMEFV2Time_getGmtOffset;
*getTime = *Idmefv2c::IDMEFV2Time_getTime;
*clone = *Idmefv2c::IDMEFV2Time_clone;
*toString = *Idmefv2c::IDMEFV2Time_toString;
*__ne__ = *Idmefv2c::IDMEFV2Time___ne__;
*__ge__ = *Idmefv2c::IDMEFV2Time___ge__;
*__le__ = *Idmefv2c::IDMEFV2Time___le__;
*__eq__ = *Idmefv2c::IDMEFV2Time___eq__;
*__gt__ = *Idmefv2c::IDMEFV2Time___gt__;
*__lt__ = *Idmefv2c::IDMEFV2Time___lt__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2Class ##############

package Idmefv2::IDMEFV2Class;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2Class(@_);
    bless $self, $pkg if defined($self);
}

*getDepth = *Idmefv2c::IDMEFV2Class_getDepth;
*get = *Idmefv2c::IDMEFV2Class_get;
*getChildCount = *Idmefv2c::IDMEFV2Class_getChildCount;
*isList = *Idmefv2c::IDMEFV2Class_isList;
*isKeyedList = *Idmefv2c::IDMEFV2Class_isKeyedList;
*getName = *Idmefv2c::IDMEFV2Class_getName;
*toString = *Idmefv2c::IDMEFV2Class_toString;
*getValueType = *Idmefv2c::IDMEFV2Class_getValueType;
*getPath = *Idmefv2c::IDMEFV2Class_getPath;
*getEnumValues = *Idmefv2c::IDMEFV2Class_getEnumValues;
*getApplicableOperator = *Idmefv2c::IDMEFV2Class_getApplicableOperator;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2Class($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Idmefv2::IDMEFV2 ##############

package Idmefv2::IDMEFV2;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Idmefv2 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Idmefv2c::delete_IDMEFV2($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Idmefv2c::new_IDMEFV2(@_);
    bless $self, $pkg if defined($self);
}

*set = *Idmefv2c::IDMEFV2_set;
*clone = *Idmefv2c::IDMEFV2_clone;
*getId = *Idmefv2c::IDMEFV2_getId;
*toString = *Idmefv2c::IDMEFV2_toString;
*toJSON = *Idmefv2c::IDMEFV2_toJSON;
*toBinary = *Idmefv2c::IDMEFV2_toBinary;
*__eq__ = *Idmefv2c::IDMEFV2___eq__;
*get = *Idmefv2c::IDMEFV2_get;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Idmefv2;

1;
