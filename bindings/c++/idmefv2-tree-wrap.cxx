
















/*****
*
* Author: Sebastien Tricaud <stricaud@inl.fr>
*
* This file is part of the Libidmefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IDMEFV2 version : Not released yet
 * Template file: generate-tree-wrap.cxx.mako
 *
 */

#include "config.h"

#include "idmefv2-tree-wrap.hxx"
#include "common.h"


static std::string *to_string(libidmefv2_string_t *str)
{
        return new std::string(libidmefv2_string_get_string(str));
}


static libidmefv2_string_t *from_string(std::string *str)
{
        int ret;
        libidmefv2_string_t *pstr;

        ret = libidmefv2_string_new_dup_fast(&pstr, str->c_str(), str->length());
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        return pstr;
}

    

/**
 * idmefv2_address_new:
 * @ret: Pointer where to store the created #idmefv2_address_t object.
 *
 * Create a new #idmefv2_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2address::IDMEFV2address()
{
        idmefv2_address_new(&_priv);
}


/**
 * idmefv2_address_destroy:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2address::~IDMEFV2address()
{
        idmefv2_address_destroy(_priv);
}





std::string  IDMEFV2address::get_ident()
{
        return to_string(idmefv2_address_get_ident(_priv));
}

void IDMEFV2address::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_address_set_ident(this, ident);
}




idmefv2_address_translation_t  IDMEFV2address::get_translation()
{
        return (idmefv2_address_get_translation(_priv));
}

void IDMEFV2address::set_translation(idmefv2_address_translation_t translation)
{
        idmefv2_address_set_translation(this, translation);
}




idmefv2_address_category_t  IDMEFV2address::get_category()
{
        return (idmefv2_address_get_category(_priv));
}

void IDMEFV2address::set_category(idmefv2_address_category_t category)
{
        idmefv2_address_set_category(this, category);
}




std::string  IDMEFV2address::get_vlan_name()
{
        return to_string(idmefv2_address_get_vlan_name(_priv));
}

void IDMEFV2address::set_vlan_name(libidmefv2_string_t *vlan_name)
{
        idmefv2_address_set_vlan_name(this, vlan_name);
}




uint32_t * IDMEFV2address::get_vlan_num()
{
        return (idmefv2_address_get_vlan_num(_priv));
}

void IDMEFV2address::set_vlan_num(uint32_t vlan_num)
{
        libidmefv2_return_if_fail(ptr);
        ptr->vlan_num = vlan_num;
        ptr->vlan_num_is_set = 1;
}


void IDMEFV2address::unset_vlan_num()
{
        idmefv2_address_unset_vlan_num(_priv);
}




std::string  IDMEFV2address::get_address()
{
        return to_string(idmefv2_address_get_address(_priv));
}

void IDMEFV2address::set_address(libidmefv2_string_t *address)
{
        idmefv2_address_set_address(this, address);
}




std::string  IDMEFV2address::get_netmask()
{
        return to_string(idmefv2_address_get_netmask(_priv));
}

void IDMEFV2address::set_netmask(libidmefv2_string_t *netmask)
{
        idmefv2_address_set_netmask(this, netmask);
}



/**
 * idmefv2_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2address::copy(IDMEFV2address *dst)
{
        return idmefv2_address_copy(_priv, dst->_priv);
}



/**
 * idmefv2_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2address *IDMEFV2address::clone()
{
        int ret;
        idmefv2_address_t *dst;
        IDMEFV2address *ptr;

        ret = idmefv2_address_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2address();
        idmefv2_address_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2address::compare(IDMEFV2address *obj)
{
        return idmefv2_address_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_user_id_new:
 * @ret: Pointer where to store the created #idmefv2_user_id_t object.
 *
 * Create a new #idmefv2_user_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user_id::IDMEFV2user_id()
{
        idmefv2_user_id_new(&_priv);
}


/**
 * idmefv2_user_id_destroy:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2user_id::~IDMEFV2user_id()
{
        idmefv2_user_id_destroy(_priv);
}





std::string  IDMEFV2user_id::get_ident()
{
        return to_string(idmefv2_user_id_get_ident(_priv));
}

void IDMEFV2user_id::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_user_id_set_ident(this, ident);
}




idmefv2_user_id_category_t  IDMEFV2user_id::get_category()
{
        return (idmefv2_user_id_get_category(_priv));
}

void IDMEFV2user_id::set_category(idmefv2_user_id_category_t category)
{
        idmefv2_user_id_set_category(this, category);
}




std::string  IDMEFV2user_id::get_tty()
{
        return to_string(idmefv2_user_id_get_tty(_priv));
}

void IDMEFV2user_id::set_tty(libidmefv2_string_t *tty)
{
        idmefv2_user_id_set_tty(this, tty);
}




std::string  IDMEFV2user_id::get_name()
{
        return to_string(idmefv2_user_id_get_name(_priv));
}

void IDMEFV2user_id::set_name(libidmefv2_string_t *name)
{
        idmefv2_user_id_set_name(this, name);
}




uint32_t * IDMEFV2user_id::get_number()
{
        return (idmefv2_user_id_get_number(_priv));
}

void IDMEFV2user_id::set_number(uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}


void IDMEFV2user_id::unset_number()
{
        idmefv2_user_id_unset_number(_priv);
}



/**
 * idmefv2_user_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2user_id::copy(IDMEFV2user_id *dst)
{
        return idmefv2_user_id_copy(_priv, dst->_priv);
}



/**
 * idmefv2_user_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user_id *IDMEFV2user_id::clone()
{
        int ret;
        idmefv2_user_id_t *dst;
        IDMEFV2user_id *ptr;

        ret = idmefv2_user_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2user_id();
        idmefv2_user_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_user_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2user_id::compare(IDMEFV2user_id *obj)
{
        return idmefv2_user_id_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_node_name_new:
 * @ret: Pointer where to store the created #idmefv2_node_name_t object.
 *
 * Create a new #idmefv2_node_name_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node_name::IDMEFV2node_name()
{
        idmefv2_node_name_new(&_priv);
}


/**
 * idmefv2_node_name_destroy:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2node_name::~IDMEFV2node_name()
{
        idmefv2_node_name_destroy(_priv);
}





idmefv2_node_name_category_t  IDMEFV2node_name::get_category()
{
        return (idmefv2_node_name_get_category(_priv));
}

void IDMEFV2node_name::set_category(idmefv2_node_name_category_t category)
{
        idmefv2_node_name_set_category(this, category);
}




std::string  IDMEFV2node_name::get_name()
{
        return to_string(idmefv2_node_name_get_name(_priv));
}

void IDMEFV2node_name::set_name(libidmefv2_string_t *name)
{
        idmefv2_node_name_set_name(this, name);
}



/**
 * idmefv2_node_name_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_node_name_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2node_name::copy(IDMEFV2node_name *dst)
{
        return idmefv2_node_name_copy(_priv, dst->_priv);
}



/**
 * idmefv2_node_name_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node_name *IDMEFV2node_name::clone()
{
        int ret;
        idmefv2_node_name_t *dst;
        IDMEFV2node_name *ptr;

        ret = idmefv2_node_name_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2node_name();
        idmefv2_node_name_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_node_name_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2node_name::compare(IDMEFV2node_name *obj)
{
        return idmefv2_node_name_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_location_new:
 * @ret: Pointer where to store the created #idmefv2_location_t object.
 *
 * Create a new #idmefv2_location_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2location::IDMEFV2location()
{
        idmefv2_location_new(&_priv);
}


/**
 * idmefv2_location_destroy:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2location::~IDMEFV2location()
{
        idmefv2_location_destroy(_priv);
}





std::string  IDMEFV2location::get_name()
{
        return to_string(idmefv2_location_get_name(_priv));
}

void IDMEFV2location::set_name(libidmefv2_string_t *name)
{
        idmefv2_location_set_name(this, name);
}




float * IDMEFV2location::get_latitude()
{
        return (idmefv2_location_get_latitude(_priv));
}

void IDMEFV2location::set_latitude(float latitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->latitude = latitude;
        ptr->latitude_is_set = 1;
}


void IDMEFV2location::unset_latitude()
{
        idmefv2_location_unset_latitude(_priv);
}




float * IDMEFV2location::get_longitude()
{
        return (idmefv2_location_get_longitude(_priv));
}

void IDMEFV2location::set_longitude(float longitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->longitude = longitude;
        ptr->longitude_is_set = 1;
}


void IDMEFV2location::unset_longitude()
{
        idmefv2_location_unset_longitude(_priv);
}




float * IDMEFV2location::get_altitude()
{
        return (idmefv2_location_get_altitude(_priv));
}

void IDMEFV2location::set_altitude(float altitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->altitude = altitude;
        ptr->altitude_is_set = 1;
}


void IDMEFV2location::unset_altitude()
{
        idmefv2_location_unset_altitude(_priv);
}




std::string  IDMEFV2location::get_country()
{
        return to_string(idmefv2_location_get_country(_priv));
}

void IDMEFV2location::set_country(libidmefv2_string_t *country)
{
        idmefv2_location_set_country(this, country);
}




std::string  IDMEFV2location::get_city()
{
        return to_string(idmefv2_location_get_city(_priv));
}

void IDMEFV2location::set_city(libidmefv2_string_t *city)
{
        idmefv2_location_set_city(this, city);
}




std::string  IDMEFV2location::get_postcode()
{
        return to_string(idmefv2_location_get_postcode(_priv));
}

void IDMEFV2location::set_postcode(libidmefv2_string_t *postcode)
{
        idmefv2_location_set_postcode(this, postcode);
}



/**
 * idmefv2_location_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_location_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2location::copy(IDMEFV2location *dst)
{
        return idmefv2_location_copy(_priv, dst->_priv);
}



/**
 * idmefv2_location_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2location *IDMEFV2location::clone()
{
        int ret;
        idmefv2_location_t *dst;
        IDMEFV2location *ptr;

        ret = idmefv2_location_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2location();
        idmefv2_location_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_location_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2location::compare(IDMEFV2location *obj)
{
        return idmefv2_location_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_interface_new:
 * @ret: Pointer where to store the created #idmefv2_interface_t object.
 *
 * Create a new #idmefv2_interface_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2interface::IDMEFV2interface()
{
        idmefv2_interface_new(&_priv);
}


/**
 * idmefv2_interface_destroy:
 * @ptr: pointer to a #idmefv2_interface_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2interface::~IDMEFV2interface()
{
        idmefv2_interface_destroy(_priv);
}





std::string  IDMEFV2interface::get_name()
{
        return to_string(idmefv2_interface_get_name(_priv));
}

void IDMEFV2interface::set_name(libidmefv2_string_t *name)
{
        idmefv2_interface_set_name(this, name);
}




idmefv2_interface_category_t  IDMEFV2interface::get_category()
{
        return (idmefv2_interface_get_category(_priv));
}

void IDMEFV2interface::set_category(idmefv2_interface_category_t category)
{
        idmefv2_interface_set_category(this, category);
}




std::string  IDMEFV2interface::get_meaning()
{
        return to_string(idmefv2_interface_get_meaning(_priv));
}

void IDMEFV2interface::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_interface_set_meaning(this, meaning);
}



/**
 * idmefv2_interface_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_interface_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2interface::copy(IDMEFV2interface *dst)
{
        return idmefv2_interface_copy(_priv, dst->_priv);
}



/**
 * idmefv2_interface_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2interface *IDMEFV2interface::clone()
{
        int ret;
        idmefv2_interface_t *dst;
        IDMEFV2interface *ptr;

        ret = idmefv2_interface_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2interface();
        idmefv2_interface_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_interface_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2interface::compare(IDMEFV2interface *obj)
{
        return idmefv2_interface_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_file_access_new:
 * @ret: Pointer where to store the created #idmefv2_file_access_t object.
 *
 * Create a new #idmefv2_file_access_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file_access::IDMEFV2file_access()
{
        idmefv2_file_access_new(&_priv);
}


/**
 * idmefv2_file_access_destroy:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2file_access::~IDMEFV2file_access()
{
        idmefv2_file_access_destroy(_priv);
}





idmefv2_user_id_t  IDMEFV2file_access::get_user_id()
{
        return (idmefv2_file_access_get_user_id(_priv));
}

void IDMEFV2file_access::set_user_id(idmefv2_user_id_t *user_id)
{
        idmefv2_file_access_set_user_id(this, user_id);
}




idmefv2_file_access_permission_t  IDMEFV2file_access::get_permission()
{
        return (idmefv2_file_access_get_permission(_priv));
}

void IDMEFV2file_access::set_permission(idmefv2_file_access_permission_t permission)
{
        idmefv2_file_access_set_permission(this, permission);
}



/**
 * idmefv2_file_access_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_access_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2file_access::copy(IDMEFV2file_access *dst)
{
        return idmefv2_file_access_copy(_priv, dst->_priv);
}



/**
 * idmefv2_file_access_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file_access *IDMEFV2file_access::clone()
{
        int ret;
        idmefv2_file_access_t *dst;
        IDMEFV2file_access *ptr;

        ret = idmefv2_file_access_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2file_access();
        idmefv2_file_access_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_file_access_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2file_access::compare(IDMEFV2file_access *obj)
{
        return idmefv2_file_access_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_inode_new:
 * @ret: Pointer where to store the created #idmefv2_inode_t object.
 *
 * Create a new #idmefv2_inode_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2inode::IDMEFV2inode()
{
        idmefv2_inode_new(&_priv);
}


/**
 * idmefv2_inode_destroy:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2inode::~IDMEFV2inode()
{
        idmefv2_inode_destroy(_priv);
}





uint32_t * IDMEFV2inode::get_number()
{
        return (idmefv2_inode_get_number(_priv));
}

void IDMEFV2inode::set_number(uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}


void IDMEFV2inode::unset_number()
{
        idmefv2_inode_unset_number(_priv);
}




uint32_t * IDMEFV2inode::get_major_device()
{
        return (idmefv2_inode_get_major_device(_priv));
}

void IDMEFV2inode::set_major_device(uint32_t major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->major_device = major_device;
        ptr->major_device_is_set = 1;
}


void IDMEFV2inode::unset_major_device()
{
        idmefv2_inode_unset_major_device(_priv);
}




uint32_t * IDMEFV2inode::get_minor_device()
{
        return (idmefv2_inode_get_minor_device(_priv));
}

void IDMEFV2inode::set_minor_device(uint32_t minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->minor_device = minor_device;
        ptr->minor_device_is_set = 1;
}


void IDMEFV2inode::unset_minor_device()
{
        idmefv2_inode_unset_minor_device(_priv);
}




uint32_t * IDMEFV2inode::get_c_major_device()
{
        return (idmefv2_inode_get_c_major_device(_priv));
}

void IDMEFV2inode::set_c_major_device(uint32_t c_major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_major_device = c_major_device;
        ptr->c_major_device_is_set = 1;
}


void IDMEFV2inode::unset_c_major_device()
{
        idmefv2_inode_unset_c_major_device(_priv);
}




uint32_t * IDMEFV2inode::get_c_minor_device()
{
        return (idmefv2_inode_get_c_minor_device(_priv));
}

void IDMEFV2inode::set_c_minor_device(uint32_t c_minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_minor_device = c_minor_device;
        ptr->c_minor_device_is_set = 1;
}


void IDMEFV2inode::unset_c_minor_device()
{
        idmefv2_inode_unset_c_minor_device(_priv);
}




idmefv2_time_t  IDMEFV2inode::get_change_time()
{
        return (idmefv2_inode_get_change_time(_priv));
}

void IDMEFV2inode::set_change_time(idmefv2_time_t *change_time)
{
        idmefv2_inode_set_change_time(this, change_time);
}



/**
 * idmefv2_inode_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_inode_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2inode::copy(IDMEFV2inode *dst)
{
        return idmefv2_inode_copy(_priv, dst->_priv);
}



/**
 * idmefv2_inode_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2inode *IDMEFV2inode::clone()
{
        int ret;
        idmefv2_inode_t *dst;
        IDMEFV2inode *ptr;

        ret = idmefv2_inode_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2inode();
        idmefv2_inode_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_inode_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2inode::compare(IDMEFV2inode *obj)
{
        return idmefv2_inode_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_checksum_new:
 * @ret: Pointer where to store the created #idmefv2_checksum_t object.
 *
 * Create a new #idmefv2_checksum_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2checksum::IDMEFV2checksum()
{
        idmefv2_checksum_new(&_priv);
}


/**
 * idmefv2_checksum_destroy:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2checksum::~IDMEFV2checksum()
{
        idmefv2_checksum_destroy(_priv);
}





std::string  IDMEFV2checksum::get_value()
{
        return to_string(idmefv2_checksum_get_value(_priv));
}

void IDMEFV2checksum::set_value(libidmefv2_string_t *value)
{
        idmefv2_checksum_set_value(this, value);
}




std::string  IDMEFV2checksum::get_key()
{
        return to_string(idmefv2_checksum_get_key(_priv));
}

void IDMEFV2checksum::set_key(libidmefv2_string_t *key)
{
        idmefv2_checksum_set_key(this, key);
}




idmefv2_checksum_algorithm_t  IDMEFV2checksum::get_algorithm()
{
        return (idmefv2_checksum_get_algorithm(_priv));
}

void IDMEFV2checksum::set_algorithm(idmefv2_checksum_algorithm_t algorithm)
{
        idmefv2_checksum_set_algorithm(this, algorithm);
}



/**
 * idmefv2_checksum_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_checksum_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2checksum::copy(IDMEFV2checksum *dst)
{
        return idmefv2_checksum_copy(_priv, dst->_priv);
}



/**
 * idmefv2_checksum_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2checksum *IDMEFV2checksum::clone()
{
        int ret;
        idmefv2_checksum_t *dst;
        IDMEFV2checksum *ptr;

        ret = idmefv2_checksum_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2checksum();
        idmefv2_checksum_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_checksum_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2checksum::compare(IDMEFV2checksum *obj)
{
        return idmefv2_checksum_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_stream_new:
 * @ret: Pointer where to store the created #idmefv2_stream_t object.
 *
 * Create a new #idmefv2_stream_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2stream::IDMEFV2stream()
{
        idmefv2_stream_new(&_priv);
}


/**
 * idmefv2_stream_destroy:
 * @ptr: pointer to a #idmefv2_stream_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2stream::~IDMEFV2stream()
{
        idmefv2_stream_destroy(_priv);
}





idmefv2_stream_offsetunit_t  IDMEFV2stream::get_offsetunit()
{
        return (idmefv2_stream_get_offsetunit(_priv));
}

void IDMEFV2stream::set_offsetunit(idmefv2_stream_offsetunit_t offsetunit)
{
        idmefv2_stream_set_offsetunit(this, offsetunit);
}




uint32_t * IDMEFV2stream::get_offset()
{
        return (idmefv2_stream_get_offset(_priv));
}

void IDMEFV2stream::set_offset(uint32_t offset)
{
        libidmefv2_return_if_fail(ptr);
        ptr->offset = offset;
        ptr->offset_is_set = 1;
}


void IDMEFV2stream::unset_offset()
{
        idmefv2_stream_unset_offset(_priv);
}



/**
 * idmefv2_stream_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_stream_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2stream::copy(IDMEFV2stream *dst)
{
        return idmefv2_stream_copy(_priv, dst->_priv);
}



/**
 * idmefv2_stream_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2stream *IDMEFV2stream::clone()
{
        int ret;
        idmefv2_stream_t *dst;
        IDMEFV2stream *ptr;

        ret = idmefv2_stream_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2stream();
        idmefv2_stream_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_stream_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2stream::compare(IDMEFV2stream *obj)
{
        return idmefv2_stream_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_file_new:
 * @ret: Pointer where to store the created #idmefv2_file_t object.
 *
 * Create a new #idmefv2_file_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file::IDMEFV2file()
{
        idmefv2_file_new(&_priv);
}


/**
 * idmefv2_file_destroy:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2file::~IDMEFV2file()
{
        idmefv2_file_destroy(_priv);
}





std::string  IDMEFV2file::get_ident()
{
        return to_string(idmefv2_file_get_ident(_priv));
}

void IDMEFV2file::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_file_set_ident(this, ident);
}




std::string  IDMEFV2file::get_name()
{
        return to_string(idmefv2_file_get_name(_priv));
}

void IDMEFV2file::set_name(libidmefv2_string_t *name)
{
        idmefv2_file_set_name(this, name);
}




std::string  IDMEFV2file::get_path()
{
        return to_string(idmefv2_file_get_path(_priv));
}

void IDMEFV2file::set_path(libidmefv2_string_t *path)
{
        idmefv2_file_set_path(this, path);
}




idmefv2_time_t  IDMEFV2file::get_create_time()
{
        return (idmefv2_file_get_create_time(_priv));
}

void IDMEFV2file::set_create_time(idmefv2_time_t *create_time)
{
        idmefv2_file_set_create_time(this, create_time);
}




idmefv2_time_t  IDMEFV2file::get_modify_time()
{
        return (idmefv2_file_get_modify_time(_priv));
}

void IDMEFV2file::set_modify_time(idmefv2_time_t *modify_time)
{
        idmefv2_file_set_modify_time(this, modify_time);
}




idmefv2_time_t  IDMEFV2file::get_access_time()
{
        return (idmefv2_file_get_access_time(_priv));
}

void IDMEFV2file::set_access_time(idmefv2_time_t *access_time)
{
        idmefv2_file_set_access_time(this, access_time);
}




uint64_t * IDMEFV2file::get_data_size()
{
        return (idmefv2_file_get_data_size(_priv));
}

void IDMEFV2file::set_data_size(uint64_t data_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->data_size = data_size;
        ptr->data_size_is_set = 1;
}


void IDMEFV2file::unset_data_size()
{
        idmefv2_file_unset_data_size(_priv);
}




uint64_t * IDMEFV2file::get_disk_size()
{
        return (idmefv2_file_get_disk_size(_priv));
}

void IDMEFV2file::set_disk_size(uint64_t disk_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->disk_size = disk_size;
        ptr->disk_size_is_set = 1;
}


void IDMEFV2file::unset_disk_size()
{
        idmefv2_file_unset_disk_size(_priv);
}




idmefv2_inode_t  IDMEFV2file::get_inode()
{
        return (idmefv2_file_get_inode(_priv));
}

void IDMEFV2file::set_inode(idmefv2_inode_t *inode)
{
        idmefv2_file_set_inode(this, inode);
}




idmefv2_file_category_t  IDMEFV2file::get_category()
{
        return (idmefv2_file_get_category(_priv));
}

void IDMEFV2file::set_category(idmefv2_file_category_t category)
{
        idmefv2_file_set_category(this, category);
}




std::string  IDMEFV2file::get_file_type()
{
        return to_string(idmefv2_file_get_file_type(_priv));
}

void IDMEFV2file::set_file_type(libidmefv2_string_t *file_type)
{
        idmefv2_file_set_file_type(this, file_type);
}




idmefv2_container_t  IDMEFV2file::get_container()
{
        return (idmefv2_file_get_container(_priv));
}

void IDMEFV2file::set_container(idmefv2_container_t *container)
{
        idmefv2_file_set_container(this, container);
}




idmefv2_stream_t  IDMEFV2file::get_stream()
{
        return (idmefv2_file_get_stream(_priv));
}

void IDMEFV2file::set_stream(idmefv2_stream_t *stream)
{
        idmefv2_file_set_stream(this, stream);
}



/**
 * idmefv2_file_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2file::copy(IDMEFV2file *dst)
{
        return idmefv2_file_copy(_priv, dst->_priv);
}



/**
 * idmefv2_file_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file *IDMEFV2file::clone()
{
        int ret;
        idmefv2_file_t *dst;
        IDMEFV2file *ptr;

        ret = idmefv2_file_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2file();
        idmefv2_file_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_file_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2file::compare(IDMEFV2file *obj)
{
        return idmefv2_file_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_linkage_new:
 * @ret: Pointer where to store the created #idmefv2_linkage_t object.
 *
 * Create a new #idmefv2_linkage_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage::IDMEFV2linkage()
{
        idmefv2_linkage_new(&_priv);
}


/**
 * idmefv2_linkage_destroy:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2linkage::~IDMEFV2linkage()
{
        idmefv2_linkage_destroy(_priv);
}





idmefv2_linkage_category_t  IDMEFV2linkage::get_category()
{
        return (idmefv2_linkage_get_category(_priv));
}

void IDMEFV2linkage::set_category(idmefv2_linkage_category_t category)
{
        idmefv2_linkage_set_category(this, category);
}




std::string  IDMEFV2linkage::get_name()
{
        return to_string(idmefv2_linkage_get_name(_priv));
}

void IDMEFV2linkage::set_name(libidmefv2_string_t *name)
{
        idmefv2_linkage_set_name(this, name);
}




std::string  IDMEFV2linkage::get_path()
{
        return to_string(idmefv2_linkage_get_path(_priv));
}

void IDMEFV2linkage::set_path(libidmefv2_string_t *path)
{
        idmefv2_linkage_set_path(this, path);
}




idmefv2_file_t  IDMEFV2linkage::get_file()
{
        return (idmefv2_linkage_get_file(_priv));
}

void IDMEFV2linkage::set_file(idmefv2_file_t *file)
{
        idmefv2_linkage_set_file(this, file);
}



/**
 * idmefv2_linkage_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_linkage_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2linkage::copy(IDMEFV2linkage *dst)
{
        return idmefv2_linkage_copy(_priv, dst->_priv);
}



/**
 * idmefv2_linkage_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage *IDMEFV2linkage::clone()
{
        int ret;
        idmefv2_linkage_t *dst;
        IDMEFV2linkage *ptr;

        ret = idmefv2_linkage_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2linkage();
        idmefv2_linkage_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_linkage_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2linkage::compare(IDMEFV2linkage *obj)
{
        return idmefv2_linkage_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_container_new:
 * @ret: Pointer where to store the created #idmefv2_container_t object.
 *
 * Create a new #idmefv2_container_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2container::IDMEFV2container()
{
        idmefv2_container_new(&_priv);
}


/**
 * idmefv2_container_destroy:
 * @ptr: pointer to a #idmefv2_container_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2container::~IDMEFV2container()
{
        idmefv2_container_destroy(_priv);
}





std::string  IDMEFV2container::get_name()
{
        return to_string(idmefv2_container_get_name(_priv));
}

void IDMEFV2container::set_name(libidmefv2_string_t *name)
{
        idmefv2_container_set_name(this, name);
}




std::string  IDMEFV2container::get_path()
{
        return to_string(idmefv2_container_get_path(_priv));
}

void IDMEFV2container::set_path(libidmefv2_string_t *path)
{
        idmefv2_container_set_path(this, path);
}




idmefv2_file_t  IDMEFV2container::get_file()
{
        return (idmefv2_container_get_file(_priv));
}

void IDMEFV2container::set_file(idmefv2_file_t *file)
{
        idmefv2_container_set_file(this, file);
}



/**
 * idmefv2_container_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_container_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2container::copy(IDMEFV2container *dst)
{
        return idmefv2_container_copy(_priv, dst->_priv);
}



/**
 * idmefv2_container_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2container *IDMEFV2container::clone()
{
        int ret;
        idmefv2_container_t *dst;
        IDMEFV2container *ptr;

        ret = idmefv2_container_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2container();
        idmefv2_container_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_container_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2container::compare(IDMEFV2container *obj)
{
        return idmefv2_container_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_process_new:
 * @ret: Pointer where to store the created #idmefv2_process_t object.
 *
 * Create a new #idmefv2_process_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2process::IDMEFV2process()
{
        idmefv2_process_new(&_priv);
}


/**
 * idmefv2_process_destroy:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2process::~IDMEFV2process()
{
        idmefv2_process_destroy(_priv);
}





std::string  IDMEFV2process::get_ident()
{
        return to_string(idmefv2_process_get_ident(_priv));
}

void IDMEFV2process::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_process_set_ident(this, ident);
}




std::string  IDMEFV2process::get_name()
{
        return to_string(idmefv2_process_get_name(_priv));
}

void IDMEFV2process::set_name(libidmefv2_string_t *name)
{
        idmefv2_process_set_name(this, name);
}




uint32_t * IDMEFV2process::get_pid()
{
        return (idmefv2_process_get_pid(_priv));
}

void IDMEFV2process::set_pid(uint32_t pid)
{
        libidmefv2_return_if_fail(ptr);
        ptr->pid = pid;
        ptr->pid_is_set = 1;
}


void IDMEFV2process::unset_pid()
{
        idmefv2_process_unset_pid(_priv);
}




std::string  IDMEFV2process::get_path()
{
        return to_string(idmefv2_process_get_path(_priv));
}

void IDMEFV2process::set_path(libidmefv2_string_t *path)
{
        idmefv2_process_set_path(this, path);
}




uint32_t * IDMEFV2process::get_tid()
{
        return (idmefv2_process_get_tid(_priv));
}

void IDMEFV2process::set_tid(uint32_t tid)
{
        libidmefv2_return_if_fail(ptr);
        ptr->tid = tid;
        ptr->tid_is_set = 1;
}


void IDMEFV2process::unset_tid()
{
        idmefv2_process_unset_tid(_priv);
}



/**
 * idmefv2_process_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_process_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2process::copy(IDMEFV2process *dst)
{
        return idmefv2_process_copy(_priv, dst->_priv);
}



/**
 * idmefv2_process_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2process *IDMEFV2process::clone()
{
        int ret;
        idmefv2_process_t *dst;
        IDMEFV2process *ptr;

        ret = idmefv2_process_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2process();
        idmefv2_process_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_process_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2process::compare(IDMEFV2process *obj)
{
        return idmefv2_process_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_service_new:
 * @ret: Pointer where to store the created #idmefv2_service_t object.
 *
 * Create a new #idmefv2_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2service::IDMEFV2service()
{
        idmefv2_service_new(&_priv);
}


/**
 * idmefv2_service_destroy:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2service::~IDMEFV2service()
{
        idmefv2_service_destroy(_priv);
}





std::string  IDMEFV2service::get_ident()
{
        return to_string(idmefv2_service_get_ident(_priv));
}

void IDMEFV2service::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_service_set_ident(this, ident);
}




uint32_t * IDMEFV2service::get_iana_protocol_number()
{
        return (idmefv2_service_get_iana_protocol_number(_priv));
}

void IDMEFV2service::set_iana_protocol_number(uint32_t iana_protocol_number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->iana_protocol_number = iana_protocol_number;
        ptr->iana_protocol_number_is_set = 1;
}


void IDMEFV2service::unset_iana_protocol_number()
{
        idmefv2_service_unset_iana_protocol_number(_priv);
}




std::string  IDMEFV2service::get_iana_protocol_name()
{
        return to_string(idmefv2_service_get_iana_protocol_name(_priv));
}

void IDMEFV2service::set_iana_protocol_name(libidmefv2_string_t *iana_protocol_name)
{
        idmefv2_service_set_iana_protocol_name(this, iana_protocol_name);
}




std::string  IDMEFV2service::get_name()
{
        return to_string(idmefv2_service_get_name(_priv));
}

void IDMEFV2service::set_name(libidmefv2_string_t *name)
{
        idmefv2_service_set_name(this, name);
}




uint32_t * IDMEFV2service::get_port()
{
        return (idmefv2_service_get_port(_priv));
}

void IDMEFV2service::set_port(uint32_t port)
{
        libidmefv2_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}


void IDMEFV2service::unset_port()
{
        idmefv2_service_unset_port(_priv);
}




std::string  IDMEFV2service::get_portlist()
{
        return to_string(idmefv2_service_get_portlist(_priv));
}

void IDMEFV2service::set_portlist(libidmefv2_string_t *portlist)
{
        idmefv2_service_set_portlist(this, portlist);
}




std::string  IDMEFV2service::get_protocol()
{
        return to_string(idmefv2_service_get_protocol(_priv));
}

void IDMEFV2service::set_protocol(libidmefv2_string_t *protocol)
{
        idmefv2_service_set_protocol(this, protocol);
}



/**
 * idmefv2_service_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2service::copy(IDMEFV2service *dst)
{
        return idmefv2_service_copy(_priv, dst->_priv);
}



/**
 * idmefv2_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2service *IDMEFV2service::clone()
{
        int ret;
        idmefv2_service_t *dst;
        IDMEFV2service *ptr;

        ret = idmefv2_service_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2service();
        idmefv2_service_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2service::compare(IDMEFV2service *obj)
{
        return idmefv2_service_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_node_new:
 * @ret: Pointer where to store the created #idmefv2_node_t object.
 *
 * Create a new #idmefv2_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node::IDMEFV2node()
{
        idmefv2_node_new(&_priv);
}


/**
 * idmefv2_node_destroy:
 * @ptr: pointer to a #idmefv2_node_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2node::~IDMEFV2node()
{
        idmefv2_node_destroy(_priv);
}





std::string  IDMEFV2node::get_ident()
{
        return to_string(idmefv2_node_get_ident(_priv));
}

void IDMEFV2node::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_node_set_ident(this, ident);
}




idmefv2_location_t  IDMEFV2node::get_location()
{
        return (idmefv2_node_get_location(_priv));
}

void IDMEFV2node::set_location(idmefv2_location_t *location)
{
        idmefv2_node_set_location(this, location);
}



/**
 * idmefv2_node_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2node::copy(IDMEFV2node *dst)
{
        return idmefv2_node_copy(_priv, dst->_priv);
}



/**
 * idmefv2_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node *IDMEFV2node::clone()
{
        int ret;
        idmefv2_node_t *dst;
        IDMEFV2node *ptr;

        ret = idmefv2_node_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2node();
        idmefv2_node_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2node::compare(IDMEFV2node *obj)
{
        return idmefv2_node_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_user_new:
 * @ret: Pointer where to store the created #idmefv2_user_t object.
 *
 * Create a new #idmefv2_user_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user::IDMEFV2user()
{
        idmefv2_user_new(&_priv);
}


/**
 * idmefv2_user_destroy:
 * @ptr: pointer to a #idmefv2_user_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2user::~IDMEFV2user()
{
        idmefv2_user_destroy(_priv);
}





std::string  IDMEFV2user::get_ident()
{
        return to_string(idmefv2_user_get_ident(_priv));
}

void IDMEFV2user::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_user_set_ident(this, ident);
}




idmefv2_user_category_t  IDMEFV2user::get_category()
{
        return (idmefv2_user_get_category(_priv));
}

void IDMEFV2user::set_category(idmefv2_user_category_t category)
{
        idmefv2_user_set_category(this, category);
}



/**
 * idmefv2_user_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2user::copy(IDMEFV2user *dst)
{
        return idmefv2_user_copy(_priv, dst->_priv);
}



/**
 * idmefv2_user_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user *IDMEFV2user::clone()
{
        int ret;
        idmefv2_user_t *dst;
        IDMEFV2user *ptr;

        ret = idmefv2_user_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2user();
        idmefv2_user_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_user_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2user::compare(IDMEFV2user *obj)
{
        return idmefv2_user_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_impact_type_new:
 * @ret: Pointer where to store the created #idmefv2_impact_type_t object.
 *
 * Create a new #idmefv2_impact_type_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact_type::IDMEFV2impact_type()
{
        idmefv2_impact_type_new(&_priv);
}


/**
 * idmefv2_impact_type_destroy:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2impact_type::~IDMEFV2impact_type()
{
        idmefv2_impact_type_destroy(_priv);
}





idmefv2_impact_type_origin_t  IDMEFV2impact_type::get_origin()
{
        return (idmefv2_impact_type_get_origin(_priv));
}

void IDMEFV2impact_type::set_origin(idmefv2_impact_type_origin_t origin)
{
        idmefv2_impact_type_set_origin(this, origin);
}




std::string  IDMEFV2impact_type::get_meaning()
{
        return to_string(idmefv2_impact_type_get_meaning(_priv));
}

void IDMEFV2impact_type::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_impact_type_set_meaning(this, meaning);
}




std::string  IDMEFV2impact_type::get_name()
{
        return to_string(idmefv2_impact_type_get_name(_priv));
}

void IDMEFV2impact_type::set_name(libidmefv2_string_t *name)
{
        idmefv2_impact_type_set_name(this, name);
}




std::string  IDMEFV2impact_type::get_url()
{
        return to_string(idmefv2_impact_type_get_url(_priv));
}

void IDMEFV2impact_type::set_url(libidmefv2_string_t *url)
{
        idmefv2_impact_type_set_url(this, url);
}



/**
 * idmefv2_impact_type_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_impact_type_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2impact_type::copy(IDMEFV2impact_type *dst)
{
        return idmefv2_impact_type_copy(_priv, dst->_priv);
}



/**
 * idmefv2_impact_type_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact_type *IDMEFV2impact_type::clone()
{
        int ret;
        idmefv2_impact_type_t *dst;
        IDMEFV2impact_type *ptr;

        ret = idmefv2_impact_type_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2impact_type();
        idmefv2_impact_type_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_impact_type_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2impact_type::compare(IDMEFV2impact_type *obj)
{
        return idmefv2_impact_type_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_source_new:
 * @ret: Pointer where to store the created #idmefv2_source_t object.
 *
 * Create a new #idmefv2_source_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2source::IDMEFV2source()
{
        idmefv2_source_new(&_priv);
}


/**
 * idmefv2_source_destroy:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2source::~IDMEFV2source()
{
        idmefv2_source_destroy(_priv);
}





std::string  IDMEFV2source::get_ident()
{
        return to_string(idmefv2_source_get_ident(_priv));
}

void IDMEFV2source::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_source_set_ident(this, ident);
}




idmefv2_source_spoofed_t  IDMEFV2source::get_spoofed()
{
        return (idmefv2_source_get_spoofed(_priv));
}

void IDMEFV2source::set_spoofed(idmefv2_source_spoofed_t spoofed)
{
        idmefv2_source_set_spoofed(this, spoofed);
}




idmefv2_node_t  IDMEFV2source::get_node()
{
        return (idmefv2_source_get_node(_priv));
}

void IDMEFV2source::set_node(idmefv2_node_t *node)
{
        idmefv2_source_set_node(this, node);
}




idmefv2_user_t  IDMEFV2source::get_user()
{
        return (idmefv2_source_get_user(_priv));
}

void IDMEFV2source::set_user(idmefv2_user_t *user)
{
        idmefv2_source_set_user(this, user);
}




idmefv2_process_t  IDMEFV2source::get_process()
{
        return (idmefv2_source_get_process(_priv));
}

void IDMEFV2source::set_process(idmefv2_process_t *process)
{
        idmefv2_source_set_process(this, process);
}




idmefv2_service_t  IDMEFV2source::get_service()
{
        return (idmefv2_source_get_service(_priv));
}

void IDMEFV2source::set_service(idmefv2_service_t *service)
{
        idmefv2_source_set_service(this, service);
}



/**
 * idmefv2_source_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_source_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2source::copy(IDMEFV2source *dst)
{
        return idmefv2_source_copy(_priv, dst->_priv);
}



/**
 * idmefv2_source_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2source *IDMEFV2source::clone()
{
        int ret;
        idmefv2_source_t *dst;
        IDMEFV2source *ptr;

        ret = idmefv2_source_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2source();
        idmefv2_source_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_source_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2source::compare(IDMEFV2source *obj)
{
        return idmefv2_source_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_target_new:
 * @ret: Pointer where to store the created #idmefv2_target_t object.
 *
 * Create a new #idmefv2_target_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2target::IDMEFV2target()
{
        idmefv2_target_new(&_priv);
}


/**
 * idmefv2_target_destroy:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2target::~IDMEFV2target()
{
        idmefv2_target_destroy(_priv);
}





std::string  IDMEFV2target::get_ident()
{
        return to_string(idmefv2_target_get_ident(_priv));
}

void IDMEFV2target::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_target_set_ident(this, ident);
}




idmefv2_target_decoy_t  IDMEFV2target::get_decoy()
{
        return (idmefv2_target_get_decoy(_priv));
}

void IDMEFV2target::set_decoy(idmefv2_target_decoy_t decoy)
{
        idmefv2_target_set_decoy(this, decoy);
}




idmefv2_node_t  IDMEFV2target::get_node()
{
        return (idmefv2_target_get_node(_priv));
}

void IDMEFV2target::set_node(idmefv2_node_t *node)
{
        idmefv2_target_set_node(this, node);
}




idmefv2_user_t  IDMEFV2target::get_user()
{
        return (idmefv2_target_get_user(_priv));
}

void IDMEFV2target::set_user(idmefv2_user_t *user)
{
        idmefv2_target_set_user(this, user);
}




idmefv2_process_t  IDMEFV2target::get_process()
{
        return (idmefv2_target_get_process(_priv));
}

void IDMEFV2target::set_process(idmefv2_process_t *process)
{
        idmefv2_target_set_process(this, process);
}




idmefv2_service_t  IDMEFV2target::get_service()
{
        return (idmefv2_target_get_service(_priv));
}

void IDMEFV2target::set_service(idmefv2_service_t *service)
{
        idmefv2_target_set_service(this, service);
}




idmefv2_file_t  IDMEFV2target::get_file()
{
        return (idmefv2_target_get_file(_priv));
}

void IDMEFV2target::set_file(idmefv2_file_t *file)
{
        idmefv2_target_set_file(this, file);
}



/**
 * idmefv2_target_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_target_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2target::copy(IDMEFV2target *dst)
{
        return idmefv2_target_copy(_priv, dst->_priv);
}



/**
 * idmefv2_target_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2target *IDMEFV2target::clone()
{
        int ret;
        idmefv2_target_t *dst;
        IDMEFV2target *ptr;

        ret = idmefv2_target_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2target();
        idmefv2_target_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_target_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2target::compare(IDMEFV2target *obj)
{
        return idmefv2_target_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_original_data_new:
 * @ret: Pointer where to store the created #idmefv2_original_data_t object.
 *
 * Create a new #idmefv2_original_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2original_data::IDMEFV2original_data()
{
        idmefv2_original_data_new(&_priv);
}


/**
 * idmefv2_original_data_destroy:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2original_data::~IDMEFV2original_data()
{
        idmefv2_original_data_destroy(_priv);
}





idmefv2_time_t  IDMEFV2original_data::get_timestamp()
{
        return (idmefv2_original_data_get_timestamp(_priv));
}

void IDMEFV2original_data::set_timestamp(idmefv2_time_t *timestamp)
{
        idmefv2_original_data_set_timestamp(this, timestamp);
}




std::string  IDMEFV2original_data::get_name()
{
        return to_string(idmefv2_original_data_get_name(_priv));
}

void IDMEFV2original_data::set_name(libidmefv2_string_t *name)
{
        idmefv2_original_data_set_name(this, name);
}




idmefv2_data_t  IDMEFV2original_data::get_data()
{
        return (idmefv2_original_data_get_data(_priv));
}

void IDMEFV2original_data::set_data(idmefv2_data_t *data)
{
        idmefv2_original_data_set_data(this, data);
}




idmefv2_node_t  IDMEFV2original_data::get_node()
{
        return (idmefv2_original_data_get_node(_priv));
}

void IDMEFV2original_data::set_node(idmefv2_node_t *node)
{
        idmefv2_original_data_set_node(this, node);
}




idmefv2_file_t  IDMEFV2original_data::get_file()
{
        return (idmefv2_original_data_get_file(_priv));
}

void IDMEFV2original_data::set_file(idmefv2_file_t *file)
{
        idmefv2_original_data_set_file(this, file);
}



/**
 * idmefv2_original_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_original_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2original_data::copy(IDMEFV2original_data *dst)
{
        return idmefv2_original_data_copy(_priv, dst->_priv);
}



/**
 * idmefv2_original_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2original_data *IDMEFV2original_data::clone()
{
        int ret;
        idmefv2_original_data_t *dst;
        IDMEFV2original_data *ptr;

        ret = idmefv2_original_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2original_data();
        idmefv2_original_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_original_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2original_data::compare(IDMEFV2original_data *obj)
{
        return idmefv2_original_data_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_observable_new:
 * @ret: Pointer where to store the created #idmefv2_observable_t object.
 *
 * Create a new #idmefv2_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2observable::IDMEFV2observable()
{
        idmefv2_observable_new(&_priv);
}


/**
 * idmefv2_observable_destroy:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2observable::~IDMEFV2observable()
{
        idmefv2_observable_destroy(_priv);
}





idmefv2_observable_origin_t  IDMEFV2observable::get_origin()
{
        return (idmefv2_observable_get_origin(_priv));
}

void IDMEFV2observable::set_origin(idmefv2_observable_origin_t origin)
{
        idmefv2_observable_set_origin(this, origin);
}




std::string  IDMEFV2observable::get_meaning()
{
        return to_string(idmefv2_observable_get_meaning(_priv));
}

void IDMEFV2observable::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_observable_set_meaning(this, meaning);
}




std::string  IDMEFV2observable::get_url()
{
        return to_string(idmefv2_observable_get_url(_priv));
}

void IDMEFV2observable::set_url(libidmefv2_string_t *url)
{
        idmefv2_observable_set_url(this, url);
}




std::string  IDMEFV2observable::get_name()
{
        return to_string(idmefv2_observable_get_name(_priv));
}

void IDMEFV2observable::set_name(libidmefv2_string_t *name)
{
        idmefv2_observable_set_name(this, name);
}



/**
 * idmefv2_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2observable::copy(IDMEFV2observable *dst)
{
        return idmefv2_observable_copy(_priv, dst->_priv);
}



/**
 * idmefv2_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2observable *IDMEFV2observable::clone()
{
        int ret;
        idmefv2_observable_t *dst;
        IDMEFV2observable *ptr;

        ret = idmefv2_observable_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2observable();
        idmefv2_observable_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2observable::compare(IDMEFV2observable *obj)
{
        return idmefv2_observable_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_taken_action_new:
 * @ret: Pointer where to store the created #idmefv2_taken_action_t object.
 *
 * Create a new #idmefv2_taken_action_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2taken_action::IDMEFV2taken_action()
{
        idmefv2_taken_action_new(&_priv);
}


/**
 * idmefv2_taken_action_destroy:
 * @ptr: pointer to a #idmefv2_taken_action_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2taken_action::~IDMEFV2taken_action()
{
        idmefv2_taken_action_destroy(_priv);
}





idmefv2_taken_action_category_t  IDMEFV2taken_action::get_category()
{
        return (idmefv2_taken_action_get_category(_priv));
}

void IDMEFV2taken_action::set_category(idmefv2_taken_action_category_t category)
{
        idmefv2_taken_action_set_category(this, category);
}



/**
 * idmefv2_taken_action_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_taken_action_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2taken_action::copy(IDMEFV2taken_action *dst)
{
        return idmefv2_taken_action_copy(_priv, dst->_priv);
}



/**
 * idmefv2_taken_action_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2taken_action *IDMEFV2taken_action::clone()
{
        int ret;
        idmefv2_taken_action_t *dst;
        IDMEFV2taken_action *ptr;

        ret = idmefv2_taken_action_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2taken_action();
        idmefv2_taken_action_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_taken_action_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2taken_action::compare(IDMEFV2taken_action *obj)
{
        return idmefv2_taken_action_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_reference_new:
 * @ret: Pointer where to store the created #idmefv2_reference_t object.
 *
 * Create a new #idmefv2_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2reference::IDMEFV2reference()
{
        idmefv2_reference_new(&_priv);
}


/**
 * idmefv2_reference_destroy:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2reference::~IDMEFV2reference()
{
        idmefv2_reference_destroy(_priv);
}





idmefv2_reference_origin_t  IDMEFV2reference::get_origin()
{
        return (idmefv2_reference_get_origin(_priv));
}

void IDMEFV2reference::set_origin(idmefv2_reference_origin_t origin)
{
        idmefv2_reference_set_origin(this, origin);
}




std::string  IDMEFV2reference::get_meaning()
{
        return to_string(idmefv2_reference_get_meaning(_priv));
}

void IDMEFV2reference::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_reference_set_meaning(this, meaning);
}




std::string  IDMEFV2reference::get_author()
{
        return to_string(idmefv2_reference_get_author(_priv));
}

void IDMEFV2reference::set_author(libidmefv2_string_t *author)
{
        idmefv2_reference_set_author(this, author);
}




idmefv2_time_t  IDMEFV2reference::get_publication_time()
{
        return (idmefv2_reference_get_publication_time(_priv));
}

void IDMEFV2reference::set_publication_time(idmefv2_time_t *publication_time)
{
        idmefv2_reference_set_publication_time(this, publication_time);
}




std::string  IDMEFV2reference::get_version()
{
        return to_string(idmefv2_reference_get_version(_priv));
}

void IDMEFV2reference::set_version(libidmefv2_string_t *version)
{
        idmefv2_reference_set_version(this, version);
}




std::string  IDMEFV2reference::get_name()
{
        return to_string(idmefv2_reference_get_name(_priv));
}

void IDMEFV2reference::set_name(libidmefv2_string_t *name)
{
        idmefv2_reference_set_name(this, name);
}




std::string  IDMEFV2reference::get_url()
{
        return to_string(idmefv2_reference_get_url(_priv));
}

void IDMEFV2reference::set_url(libidmefv2_string_t *url)
{
        idmefv2_reference_set_url(this, url);
}



/**
 * idmefv2_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2reference::copy(IDMEFV2reference *dst)
{
        return idmefv2_reference_copy(_priv, dst->_priv);
}



/**
 * idmefv2_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2reference *IDMEFV2reference::clone()
{
        int ret;
        idmefv2_reference_t *dst;
        IDMEFV2reference *ptr;

        ret = idmefv2_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2reference();
        idmefv2_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2reference::compare(IDMEFV2reference *obj)
{
        return idmefv2_reference_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_analyzer_new:
 * @ret: Pointer where to store the created #idmefv2_analyzer_t object.
 *
 * Create a new #idmefv2_analyzer_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer::IDMEFV2analyzer()
{
        idmefv2_analyzer_new(&_priv);
}


/**
 * idmefv2_analyzer_destroy:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2analyzer::~IDMEFV2analyzer()
{
        idmefv2_analyzer_destroy(_priv);
}





std::string  IDMEFV2analyzer::get_analyzerid()
{
        return to_string(idmefv2_analyzer_get_analyzerid(_priv));
}

void IDMEFV2analyzer::set_analyzerid(libidmefv2_string_t *analyzerid)
{
        idmefv2_analyzer_set_analyzerid(this, analyzerid);
}




std::string  IDMEFV2analyzer::get_name()
{
        return to_string(idmefv2_analyzer_get_name(_priv));
}

void IDMEFV2analyzer::set_name(libidmefv2_string_t *name)
{
        idmefv2_analyzer_set_name(this, name);
}




std::string  IDMEFV2analyzer::get_manufacturer()
{
        return to_string(idmefv2_analyzer_get_manufacturer(_priv));
}

void IDMEFV2analyzer::set_manufacturer(libidmefv2_string_t *manufacturer)
{
        idmefv2_analyzer_set_manufacturer(this, manufacturer);
}




std::string  IDMEFV2analyzer::get_model()
{
        return to_string(idmefv2_analyzer_get_model(_priv));
}

void IDMEFV2analyzer::set_model(libidmefv2_string_t *model)
{
        idmefv2_analyzer_set_model(this, model);
}




std::string  IDMEFV2analyzer::get_version()
{
        return to_string(idmefv2_analyzer_get_version(_priv));
}

void IDMEFV2analyzer::set_version(libidmefv2_string_t *version)
{
        idmefv2_analyzer_set_version(this, version);
}




idmefv2_analyzer_class_t  IDMEFV2analyzer::get_class()
{
        return (idmefv2_analyzer_get_class(_priv));
}

void IDMEFV2analyzer::set_class(idmefv2_analyzer_class_t class_str)
{
        idmefv2_analyzer_set_class(this, class_str);
}




std::string  IDMEFV2analyzer::get_ostype()
{
        return to_string(idmefv2_analyzer_get_ostype(_priv));
}

void IDMEFV2analyzer::set_ostype(libidmefv2_string_t *ostype)
{
        idmefv2_analyzer_set_ostype(this, ostype);
}




std::string  IDMEFV2analyzer::get_osversion()
{
        return to_string(idmefv2_analyzer_get_osversion(_priv));
}

void IDMEFV2analyzer::set_osversion(libidmefv2_string_t *osversion)
{
        idmefv2_analyzer_set_osversion(this, osversion);
}




std::string  IDMEFV2analyzer::get_ext_class()
{
        return to_string(idmefv2_analyzer_get_ext_class(_priv));
}

void IDMEFV2analyzer::set_ext_class(libidmefv2_string_t *ext_class)
{
        idmefv2_analyzer_set_ext_class(this, ext_class);
}




idmefv2_analyzer_analyzeraction_t  IDMEFV2analyzer::get_analyzeraction()
{
        return (idmefv2_analyzer_get_analyzeraction(_priv));
}

void IDMEFV2analyzer::set_analyzeraction(idmefv2_analyzer_analyzeraction_t analyzeraction)
{
        idmefv2_analyzer_set_analyzeraction(this, analyzeraction);
}




std::string  IDMEFV2analyzer::get_actionhistory()
{
        return to_string(idmefv2_analyzer_get_actionhistory(_priv));
}

void IDMEFV2analyzer::set_actionhistory(libidmefv2_string_t *actionhistory)
{
        idmefv2_analyzer_set_actionhistory(this, actionhistory);
}




idmefv2_node_t  IDMEFV2analyzer::get_node()
{
        return (idmefv2_analyzer_get_node(_priv));
}

void IDMEFV2analyzer::set_node(idmefv2_node_t *node)
{
        idmefv2_analyzer_set_node(this, node);
}




idmefv2_process_t  IDMEFV2analyzer::get_process()
{
        return (idmefv2_analyzer_get_process(_priv));
}

void IDMEFV2analyzer::set_process(idmefv2_process_t *process)
{
        idmefv2_analyzer_set_process(this, process);
}




idmefv2_time_t  IDMEFV2analyzer::get_analyzer_time()
{
        return (idmefv2_analyzer_get_analyzer_time(_priv));
}

void IDMEFV2analyzer::set_analyzer_time(idmefv2_time_t *analyzer_time)
{
        idmefv2_analyzer_set_analyzer_time(this, analyzer_time);
}



/**
 * idmefv2_analyzer_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analyzer_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2analyzer::copy(IDMEFV2analyzer *dst)
{
        return idmefv2_analyzer_copy(_priv, dst->_priv);
}



/**
 * idmefv2_analyzer_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer *IDMEFV2analyzer::clone()
{
        int ret;
        idmefv2_analyzer_t *dst;
        IDMEFV2analyzer *ptr;

        ret = idmefv2_analyzer_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2analyzer();
        idmefv2_analyzer_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_analyzer_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2analyzer::compare(IDMEFV2analyzer *obj)
{
        return idmefv2_analyzer_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_additional_data_new:
 * @ret: Pointer where to store the created #idmefv2_additional_data_t object.
 *
 * Create a new #idmefv2_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2additional_data::IDMEFV2additional_data()
{
        idmefv2_additional_data_new(&_priv);
}


/**
 * idmefv2_additional_data_destroy:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2additional_data::~IDMEFV2additional_data()
{
        idmefv2_additional_data_destroy(_priv);
}





std::string  IDMEFV2additional_data::get_meaning()
{
        return to_string(idmefv2_additional_data_get_meaning(_priv));
}

void IDMEFV2additional_data::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_additional_data_set_meaning(this, meaning);
}




idmefv2_additional_data_type_t  IDMEFV2additional_data::get_type()
{
        return (idmefv2_additional_data_get_type(_priv));
}

void IDMEFV2additional_data::set_type(idmefv2_additional_data_type_t type)
{
        idmefv2_additional_data_set_type(this, type);
}




idmefv2_data_t  IDMEFV2additional_data::get_data()
{
        return (idmefv2_additional_data_get_data(_priv));
}

void IDMEFV2additional_data::set_data(idmefv2_data_t *data)
{
        idmefv2_additional_data_set_data(this, data);
}



/**
 * idmefv2_additional_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2additional_data::copy(IDMEFV2additional_data *dst)
{
        return idmefv2_additional_data_copy(_priv, dst->_priv);
}



/**
 * idmefv2_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2additional_data *IDMEFV2additional_data::clone()
{
        int ret;
        idmefv2_additional_data_t *dst;
        IDMEFV2additional_data *ptr;

        ret = idmefv2_additional_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2additional_data();
        idmefv2_additional_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2additional_data::compare(IDMEFV2additional_data *obj)
{
        return idmefv2_additional_data_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_correlation_alert_new:
 * @ret: Pointer where to store the created #idmefv2_correlation_alert_t object.
 *
 * Create a new #idmefv2_correlation_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2correlation_alert::IDMEFV2correlation_alert()
{
        idmefv2_correlation_alert_new(&_priv);
}


/**
 * idmefv2_correlation_alert_destroy:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2correlation_alert::~IDMEFV2correlation_alert()
{
        idmefv2_correlation_alert_destroy(_priv);
}





std::string  IDMEFV2correlation_alert::get_name()
{
        return to_string(idmefv2_correlation_alert_get_name(_priv));
}

void IDMEFV2correlation_alert::set_name(libidmefv2_string_t *name)
{
        idmefv2_correlation_alert_set_name(this, name);
}




uint32_t * IDMEFV2correlation_alert::get_duration()
{
        return (idmefv2_correlation_alert_get_duration(_priv));
}

void IDMEFV2correlation_alert::set_duration(uint32_t duration)
{
        libidmefv2_return_if_fail(ptr);
        ptr->duration = duration;
        ptr->duration_is_set = 1;
}


void IDMEFV2correlation_alert::unset_duration()
{
        idmefv2_correlation_alert_unset_duration(_priv);
}




uint32_t * IDMEFV2correlation_alert::get_counter()
{
        return (idmefv2_correlation_alert_get_counter(_priv));
}

void IDMEFV2correlation_alert::set_counter(uint32_t counter)
{
        libidmefv2_return_if_fail(ptr);
        ptr->counter = counter;
        ptr->counter_is_set = 1;
}


void IDMEFV2correlation_alert::unset_counter()
{
        idmefv2_correlation_alert_unset_counter(_priv);
}



/**
 * idmefv2_correlation_alert_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_correlation_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2correlation_alert::copy(IDMEFV2correlation_alert *dst)
{
        return idmefv2_correlation_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_correlation_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2correlation_alert *IDMEFV2correlation_alert::clone()
{
        int ret;
        idmefv2_correlation_alert_t *dst;
        IDMEFV2correlation_alert *ptr;

        ret = idmefv2_correlation_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2correlation_alert();
        idmefv2_correlation_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_correlation_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2correlation_alert::compare(IDMEFV2correlation_alert *obj)
{
        return idmefv2_correlation_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_analysis_data_new:
 * @ret: Pointer where to store the created #idmefv2_analysis_data_t object.
 *
 * Create a new #idmefv2_analysis_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analysis_data::IDMEFV2analysis_data()
{
        idmefv2_analysis_data_new(&_priv);
}


/**
 * idmefv2_analysis_data_destroy:
 * @ptr: pointer to a #idmefv2_analysis_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2analysis_data::~IDMEFV2analysis_data()
{
        idmefv2_analysis_data_destroy(_priv);
}




/**
 * idmefv2_analysis_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analysis_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2analysis_data::copy(IDMEFV2analysis_data *dst)
{
        return idmefv2_analysis_data_copy(_priv, dst->_priv);
}



/**
 * idmefv2_analysis_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analysis_data *IDMEFV2analysis_data::clone()
{
        int ret;
        idmefv2_analysis_data_t *dst;
        IDMEFV2analysis_data *ptr;

        ret = idmefv2_analysis_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2analysis_data();
        idmefv2_analysis_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_analysis_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2analysis_data::compare(IDMEFV2analysis_data *obj)
{
        return idmefv2_analysis_data_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_confidence_new:
 * @ret: Pointer where to store the created #idmefv2_confidence_t object.
 *
 * Create a new #idmefv2_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2confidence::IDMEFV2confidence()
{
        idmefv2_confidence_new(&_priv);
}


/**
 * idmefv2_confidence_destroy:
 * @ptr: pointer to a #idmefv2_confidence_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2confidence::~IDMEFV2confidence()
{
        idmefv2_confidence_destroy(_priv);
}





idmefv2_confidence_rating_t  IDMEFV2confidence::get_rating()
{
        return (idmefv2_confidence_get_rating(_priv));
}

void IDMEFV2confidence::set_rating(idmefv2_confidence_rating_t rating)
{
        idmefv2_confidence_set_rating(this, rating);
}



/**
 * idmefv2_confidence_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2confidence::copy(IDMEFV2confidence *dst)
{
        return idmefv2_confidence_copy(_priv, dst->_priv);
}



/**
 * idmefv2_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2confidence *IDMEFV2confidence::clone()
{
        int ret;
        idmefv2_confidence_t *dst;
        IDMEFV2confidence *ptr;

        ret = idmefv2_confidence_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2confidence();
        idmefv2_confidence_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2confidence::compare(IDMEFV2confidence *obj)
{
        return idmefv2_confidence_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_impact_new:
 * @ret: Pointer where to store the created #idmefv2_impact_t object.
 *
 * Create a new #idmefv2_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact::IDMEFV2impact()
{
        idmefv2_impact_new(&_priv);
}


/**
 * idmefv2_impact_destroy:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2impact::~IDMEFV2impact()
{
        idmefv2_impact_destroy(_priv);
}





idmefv2_impact_severity_t  IDMEFV2impact::get_severity()
{
        return (idmefv2_impact_get_severity(_priv));
}

void IDMEFV2impact::set_severity(idmefv2_impact_severity_t severity)
{
        idmefv2_impact_set_severity(this, severity);
}




idmefv2_impact_completion_t  IDMEFV2impact::get_completion()
{
        return (idmefv2_impact_get_completion(_priv));
}

void IDMEFV2impact::set_completion(idmefv2_impact_completion_t completion)
{
        idmefv2_impact_set_completion(this, completion);
}




idmefv2_impact_availability_t  IDMEFV2impact::get_availability()
{
        return (idmefv2_impact_get_availability(_priv));
}

void IDMEFV2impact::set_availability(idmefv2_impact_availability_t availability)
{
        idmefv2_impact_set_availability(this, availability);
}




idmefv2_impact_integrity_t  IDMEFV2impact::get_integrity()
{
        return (idmefv2_impact_get_integrity(_priv));
}

void IDMEFV2impact::set_integrity(idmefv2_impact_integrity_t integrity)
{
        idmefv2_impact_set_integrity(this, integrity);
}




idmefv2_impact_confidentiality_t  IDMEFV2impact::get_confidentiality()
{
        return (idmefv2_impact_get_confidentiality(_priv));
}

void IDMEFV2impact::set_confidentiality(idmefv2_impact_confidentiality_t confidentiality)
{
        idmefv2_impact_set_confidentiality(this, confidentiality);
}




std::string  IDMEFV2impact::get_description()
{
        return to_string(idmefv2_impact_get_description(_priv));
}

void IDMEFV2impact::set_description(libidmefv2_string_t *description)
{
        idmefv2_impact_set_description(this, description);
}



/**
 * idmefv2_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2impact::copy(IDMEFV2impact *dst)
{
        return idmefv2_impact_copy(_priv, dst->_priv);
}



/**
 * idmefv2_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact *IDMEFV2impact::clone()
{
        int ret;
        idmefv2_impact_t *dst;
        IDMEFV2impact *ptr;

        ret = idmefv2_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2impact();
        idmefv2_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2impact::compare(IDMEFV2impact *obj)
{
        return idmefv2_impact_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_recommanded_action_new:
 * @ret: Pointer where to store the created #idmefv2_recommanded_action_t object.
 *
 * Create a new #idmefv2_recommanded_action_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2recommanded_action::IDMEFV2recommanded_action()
{
        idmefv2_recommanded_action_new(&_priv);
}


/**
 * idmefv2_recommanded_action_destroy:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2recommanded_action::~IDMEFV2recommanded_action()
{
        idmefv2_recommanded_action_destroy(_priv);
}





idmefv2_recommanded_action_action_t  IDMEFV2recommanded_action::get_action()
{
        return (idmefv2_recommanded_action_get_action(_priv));
}

void IDMEFV2recommanded_action::set_action(idmefv2_recommanded_action_action_t action)
{
        idmefv2_recommanded_action_set_action(this, action);
}




uint32_t * IDMEFV2recommanded_action::get_step()
{
        return (idmefv2_recommanded_action_get_step(_priv));
}

void IDMEFV2recommanded_action::set_step(uint32_t step)
{
        libidmefv2_return_if_fail(ptr);
        ptr->step = step;
        ptr->step_is_set = 1;
}


void IDMEFV2recommanded_action::unset_step()
{
        idmefv2_recommanded_action_unset_step(_priv);
}



/**
 * idmefv2_recommanded_action_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_recommanded_action_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2recommanded_action::copy(IDMEFV2recommanded_action *dst)
{
        return idmefv2_recommanded_action_copy(_priv, dst->_priv);
}



/**
 * idmefv2_recommanded_action_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2recommanded_action *IDMEFV2recommanded_action::clone()
{
        int ret;
        idmefv2_recommanded_action_t *dst;
        IDMEFV2recommanded_action *ptr;

        ret = idmefv2_recommanded_action_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2recommanded_action();
        idmefv2_recommanded_action_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_recommanded_action_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2recommanded_action::compare(IDMEFV2recommanded_action *obj)
{
        return idmefv2_recommanded_action_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_assessment_new:
 * @ret: Pointer where to store the created #idmefv2_assessment_t object.
 *
 * Create a new #idmefv2_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2assessment::IDMEFV2assessment()
{
        idmefv2_assessment_new(&_priv);
}


/**
 * idmefv2_assessment_destroy:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2assessment::~IDMEFV2assessment()
{
        idmefv2_assessment_destroy(_priv);
}





idmefv2_impact_t  IDMEFV2assessment::get_impact()
{
        return (idmefv2_assessment_get_impact(_priv));
}

void IDMEFV2assessment::set_impact(idmefv2_impact_t *impact)
{
        idmefv2_assessment_set_impact(this, impact);
}




idmefv2_confidence_t  IDMEFV2assessment::get_confidence()
{
        return (idmefv2_assessment_get_confidence(_priv));
}

void IDMEFV2assessment::set_confidence(idmefv2_confidence_t *confidence)
{
        idmefv2_assessment_set_confidence(this, confidence);
}



/**
 * idmefv2_assessment_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2assessment::copy(IDMEFV2assessment *dst)
{
        return idmefv2_assessment_copy(_priv, dst->_priv);
}



/**
 * idmefv2_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2assessment *IDMEFV2assessment::clone()
{
        int ret;
        idmefv2_assessment_t *dst;
        IDMEFV2assessment *ptr;

        ret = idmefv2_assessment_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2assessment();
        idmefv2_assessment_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2assessment::compare(IDMEFV2assessment *obj)
{
        return idmefv2_assessment_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_classification_new:
 * @ret: Pointer where to store the created #idmefv2_classification_t object.
 *
 * Create a new #idmefv2_classification_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2classification::IDMEFV2classification()
{
        idmefv2_classification_new(&_priv);
}


/**
 * idmefv2_classification_destroy:
 * @ptr: pointer to a #idmefv2_classification_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2classification::~IDMEFV2classification()
{
        idmefv2_classification_destroy(_priv);
}





std::string  IDMEFV2classification::get_ident()
{
        return to_string(idmefv2_classification_get_ident(_priv));
}

void IDMEFV2classification::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_classification_set_ident(this, ident);
}




std::string  IDMEFV2classification::get_text()
{
        return to_string(idmefv2_classification_get_text(_priv));
}

void IDMEFV2classification::set_text(libidmefv2_string_t *text)
{
        idmefv2_classification_set_text(this, text);
}



/**
 * idmefv2_classification_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_classification_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2classification::copy(IDMEFV2classification *dst)
{
        return idmefv2_classification_copy(_priv, dst->_priv);
}



/**
 * idmefv2_classification_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2classification *IDMEFV2classification::clone()
{
        int ret;
        idmefv2_classification_t *dst;
        IDMEFV2classification *ptr;

        ret = idmefv2_classification_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2classification();
        idmefv2_classification_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_classification_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2classification::compare(IDMEFV2classification *obj)
{
        return idmefv2_classification_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_heartbeat_new:
 * @ret: Pointer where to store the created #idmefv2_heartbeat_t object.
 *
 * Create a new #idmefv2_heartbeat_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2heartbeat::IDMEFV2heartbeat()
{
        idmefv2_heartbeat_new(&_priv);
}


/**
 * idmefv2_heartbeat_destroy:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2heartbeat::~IDMEFV2heartbeat()
{
        idmefv2_heartbeat_destroy(_priv);
}





std::string  IDMEFV2heartbeat::get_messageid()
{
        return to_string(idmefv2_heartbeat_get_messageid(_priv));
}

void IDMEFV2heartbeat::set_messageid(libidmefv2_string_t *messageid)
{
        idmefv2_heartbeat_set_messageid(this, messageid);
}




idmefv2_analyzer_t  IDMEFV2heartbeat::get_analyzer()
{
        return (idmefv2_heartbeat_get_analyzer(_priv));
}

void IDMEFV2heartbeat::set_analyzer(idmefv2_analyzer_t *analyzer)
{
        idmefv2_heartbeat_set_analyzer(this, analyzer);
}




idmefv2_time_t  IDMEFV2heartbeat::get_create_time()
{
        return (idmefv2_heartbeat_get_create_time(_priv));
}

void IDMEFV2heartbeat::set_create_time(idmefv2_time_t *create_time)
{
        idmefv2_heartbeat_set_create_time(this, create_time);
}




uint32_t * IDMEFV2heartbeat::get_heartbeat_interval()
{
        return (idmefv2_heartbeat_get_heartbeat_interval(_priv));
}

void IDMEFV2heartbeat::set_heartbeat_interval(uint32_t heartbeat_interval)
{
        libidmefv2_return_if_fail(ptr);
        ptr->heartbeat_interval = heartbeat_interval;
        ptr->heartbeat_interval_is_set = 1;
}


void IDMEFV2heartbeat::unset_heartbeat_interval()
{
        idmefv2_heartbeat_unset_heartbeat_interval(_priv);
}



/**
 * idmefv2_heartbeat_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_heartbeat_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2heartbeat::copy(IDMEFV2heartbeat *dst)
{
        return idmefv2_heartbeat_copy(_priv, dst->_priv);
}



/**
 * idmefv2_heartbeat_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2heartbeat *IDMEFV2heartbeat::clone()
{
        int ret;
        idmefv2_heartbeat_t *dst;
        IDMEFV2heartbeat *ptr;

        ret = idmefv2_heartbeat_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2heartbeat();
        idmefv2_heartbeat_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_heartbeat_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2heartbeat::compare(IDMEFV2heartbeat *obj)
{
        return idmefv2_heartbeat_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_alert_new:
 * @ret: Pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new #idmefv2_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2alert::IDMEFV2alert()
{
        idmefv2_alert_new(&_priv);
}


/**
 * idmefv2_alert_destroy:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IDMEFV2alert::~IDMEFV2alert()
{
        idmefv2_alert_destroy(_priv);
}





std::string  IDMEFV2alert::get_messageid()
{
        return to_string(idmefv2_alert_get_messageid(_priv));
}

void IDMEFV2alert::set_messageid(libidmefv2_string_t *messageid)
{
        idmefv2_alert_set_messageid(this, messageid);
}




std::string  IDMEFV2alert::get_analyzerhash()
{
        return to_string(idmefv2_alert_get_analyzerhash(_priv));
}

void IDMEFV2alert::set_analyzerhash(libidmefv2_string_t *analyzerhash)
{
        idmefv2_alert_set_analyzerhash(this, analyzerhash);
}




idmefv2_time_t  IDMEFV2alert::get_create_time()
{
        return (idmefv2_alert_get_create_time(_priv));
}

void IDMEFV2alert::set_create_time(idmefv2_time_t *create_time)
{
        idmefv2_alert_set_create_time(this, create_time);
}




idmefv2_classification_t  IDMEFV2alert::get_classification()
{
        return (idmefv2_alert_get_classification(_priv));
}

void IDMEFV2alert::set_classification(idmefv2_classification_t *classification)
{
        idmefv2_alert_set_classification(this, classification);
}




idmefv2_time_t  IDMEFV2alert::get_detect_time()
{
        return (idmefv2_alert_get_detect_time(_priv));
}

void IDMEFV2alert::set_detect_time(idmefv2_time_t *detect_time)
{
        idmefv2_alert_set_detect_time(this, detect_time);
}




idmefv2_analysis_data_t  IDMEFV2alert::get_analysis_data()
{
        return (idmefv2_alert_get_analysis_data(_priv));
}

void IDMEFV2alert::set_analysis_data(idmefv2_analysis_data_t *analysis_data)
{
        idmefv2_alert_set_analysis_data(this, analysis_data);
}




idmefv2_assessment_t  IDMEFV2alert::get_assessment()
{
        return (idmefv2_alert_get_assessment(_priv));
}

void IDMEFV2alert::set_assessment(idmefv2_assessment_t *assessment)
{
        idmefv2_alert_set_assessment(this, assessment);
}


/**
 * idmefv2_alert_get_type:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_type_t children, or NULL if it is not set.
 */
idmefv2_alert_type_t IDMEFV2alert::get_type()
{
        return idmefv2_alert_get_type(_priv);
}
/**
 * idmefv2_alert_get_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the correlation_alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_correlation_alert_t children, or NULL if it is not set.
 */
idmefv2_correlation_alert_t *IDMEFV2alert::get_correlation_alert()
{
        return idmefv2_alert_get_correlation_alert(_priv);
}
/**
 * idmefv2_alert_set_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @correlation_alert: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Set @correlation_alert object as a children of @ptr.
 * if @ptr already contain a @correlation_alert object, then it is destroyed,
 * and updated to point to the provided @correlation_alert object.
 */
void IDMEFV2alert::set_correlation_alert(idmefv2_correlation_alert_t *correlation_alert)
{
        idmefv2_alert_set_correlation_alert(_priv, correlation_alert);
}
/**
 * idmefv2_alert_new_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer where to store the created #idmefv2_correlation_alert_t object.
 *
 * Create a new idmefv2_correlation_alert_t object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_correlation_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2correlation_alert *IDMEFV2alert::new_correlation_alert()
{
        int ret;
        idmefv2_correlation_alert_t *ptr;
        IDMEFV2correlation_alert *obj;

        ret = idmefv2_alert_new_correlation_alert(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        obj = new IDMEFV2correlation_alert;
        idmefv2_correlation_alert_destroy(obj->_priv);
        obj->_priv = ptr;
}



/**
 * idmefv2_alert_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2alert::copy(IDMEFV2alert *dst)
{
        return idmefv2_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2alert *IDMEFV2alert::clone()
{
        int ret;
        idmefv2_alert_t *dst;
        IDMEFV2alert *ptr;

        ret = idmefv2_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2alert();
        idmefv2_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2alert::compare(IDMEFV2alert *obj)
{
        return idmefv2_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_message_new:
 * @ret: Pointer where to store the created #idmefv2_message_t object.
 *
 * Create a new #idmefv2_message_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2message::IDMEFV2message()
{
        idmefv2_message_new(&_priv);
}







std::string  IDMEFV2message::get_version()
{
        return to_string(idmefv2_message_get_version(_priv));
}

void IDMEFV2message::set_version(libidmefv2_string_t *version)
{
        idmefv2_message_set_version(this, version);
}


/**
 * idmefv2_message_get_type:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_message_type_t children, or NULL if it is not set.
 */
idmefv2_message_type_t IDMEFV2message::get_type()
{
        return idmefv2_message_get_type(_priv);
}
/**
 * idmefv2_message_get_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_t children, or NULL if it is not set.
 */
idmefv2_alert_t *IDMEFV2message::get_alert()
{
        return idmefv2_message_get_alert(_priv);
}
/**
 * idmefv2_message_set_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Set @alert object as a children of @ptr.
 * if @ptr already contain a @alert object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void IDMEFV2message::set_alert(idmefv2_alert_t *alert)
{
        idmefv2_message_set_alert(_priv, alert);
}
/**
 * idmefv2_message_new_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new idmefv2_alert_t object, children of #idmefv2_message_t.
 * If @ptr already contain a #idmefv2_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2alert *IDMEFV2message::new_alert()
{
        int ret;
        idmefv2_alert_t *ptr;
        IDMEFV2alert *obj;

        ret = idmefv2_message_new_alert(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        obj = new IDMEFV2alert;
        idmefv2_alert_destroy(obj->_priv);
        obj->_priv = ptr;
}
/**
 * idmefv2_message_get_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the heartbeat children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_heartbeat_t children, or NULL if it is not set.
 */
idmefv2_heartbeat_t *IDMEFV2message::get_heartbeat()
{
        return idmefv2_message_get_heartbeat(_priv);
}
/**
 * idmefv2_message_set_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @heartbeat: pointer to a #idmefv2_heartbeat_t object.
 *
 * Set @heartbeat object as a children of @ptr.
 * if @ptr already contain a @heartbeat object, then it is destroyed,
 * and updated to point to the provided @heartbeat object.
 */
void IDMEFV2message::set_heartbeat(idmefv2_heartbeat_t *heartbeat)
{
        idmefv2_message_set_heartbeat(_priv, heartbeat);
}
/**
 * idmefv2_message_new_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_heartbeat_t object.
 *
 * Create a new idmefv2_heartbeat_t object, children of #idmefv2_message_t.
 * If @ptr already contain a #idmefv2_heartbeat_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2heartbeat *IDMEFV2message::new_heartbeat()
{
        int ret;
        idmefv2_heartbeat_t *ptr;
        IDMEFV2heartbeat *obj;

        ret = idmefv2_message_new_heartbeat(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        obj = new IDMEFV2heartbeat;
        idmefv2_heartbeat_destroy(obj->_priv);
        obj->_priv = ptr;
}



/**
 * idmefv2_message_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_message_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2message::copy(IDMEFV2message *dst)
{
        return idmefv2_message_copy(_priv, dst->_priv);
}



/**
 * idmefv2_message_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2message *IDMEFV2message::clone()
{
        int ret;
        idmefv2_message_t *dst;
        IDMEFV2message *ptr;

        ret = idmefv2_message_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdmefv2Error(ret);

        ptr = new IDMEFV2message();
        idmefv2_message_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_message_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2message::compare(IDMEFV2message *obj)
{
        return idmefv2_message_compare(_priv, obj->_priv);
}



void IDMEFV2Message::set_pmsg(libidmefv2_msg_t *msg)
{
        idmefv2_message_set_pmsg(_priv, msg);
}


libidmefv2_msg_t *IDMEFV2Message::get_pmsg()
{
        return idmefv2_message_get_pmsg(_priv);
}


/**
 * idmefv2_message_destroy:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void IDMEFV2Message::~IDMEFV2Message()
{
        idmefv2_message_destroy(_priv);
}


