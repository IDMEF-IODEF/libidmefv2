
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the Libidmefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IDMEFV2 version : Not released yet
 * Template file: generate-top-level-class-read.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <unistd.h>

#define LIBIDMEFV2_ERROR_SOURCE_DEFAULT LIBIDMEFV2_ERROR_SOURCE_IDMEFV2_MESSAGE_READ
#include "libidmefv2-error.h"
#include "libidmefv2-inttypes.h"
#include "libidmefv2-list.h"
#include "libidmefv2-extract.h"
#include "libidmefv2-io.h"
#include "idmefv2-message-id.h"
#include "idmefv2.h"
#include "idmefv2-tree-wrap.h"

#include "idmefv2-message-read.h"

#define libidmefv2_extract_string_safe(out, buf, len, msg) extract_string_safe_f(__FUNCTION__, __LINE__, out, buf, len)

static inline int extract_string_safe_f(const char *f, int line, libidmefv2_string_t **out, char *buf, size_t len)
{
        int ret;

        /*
         * we use len - 1 since len is supposed to include \0 to avoid making a dup.
         */
        ret = libidmefv2_string_new_ref_fast(out, buf, len - 1);
        if ( ret < 0 )
                ret = libidmefv2_error_verbose(libidmefv2_error_get_code(ret), "%s:%d could not extract IDMEFV2 string: %s", f, line, libidmefv2_strerror(ret));

        return ret;
}


static inline int libidmefv2_extract_time_safe(idmefv2_time_t **out, void *buf, size_t len, libidmefv2_msg_t *msg)
{
        int ret;

        /*
         * sizeof(sec) + sizeof(usec) + sizeof(gmt offset).
         */
        if ( len != 12 )
                return libidmefv2_error_make(LIBIDMEFV2_ERROR_SOURCE_EXTRACT, LIBIDMEFV2_ERROR_INVAL_IDMEFV2_TIME);

        ret = idmefv2_time_new(out);
        if ( ret < 0 )
                return ret;

        idmefv2_time_set_sec(*out, libidmefv2_extract_uint32(buf));
        idmefv2_time_set_usec(*out, libidmefv2_extract_uint32((unsigned char *) buf + 4));
        idmefv2_time_set_gmt_offset(*out, libidmefv2_extract_int32((unsigned char *) buf + 8));

        return 0;
}


static inline int libidmefv2_extract_data_safe(idmefv2_data_t **out, void *buf, uint32_t len, libidmefv2_msg_t *msg)
{
        int ret;
        uint8_t tag;
        idmefv2_data_type_t type = 0;

        ret = libidmefv2_extract_uint32_safe(&type, buf, len);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
        if ( ret < 0 )
                return ret;

        *out = NULL;

        switch ( type ) {
        case IDMEFV2_DATA_TYPE_CHAR: {
                uint8_t tmp = 0;

                ret = libidmefv2_extract_uint8_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_char(out, (char) tmp);
                break;
        }

        case IDMEFV2_DATA_TYPE_BYTE: {
                uint8_t tmp = 0;

                ret = libidmefv2_extract_uint8_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_byte(out, tmp);
                break;
        }

        case IDMEFV2_DATA_TYPE_UINT32: {
                uint32_t tmp = 0;

                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_int(out, tmp);
                break;
        }

        case IDMEFV2_DATA_TYPE_INT: {
                uint64_t tmp = 0;

                ret = libidmefv2_extract_uint64_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_int(out, tmp);
                break;
        }

        case IDMEFV2_DATA_TYPE_FLOAT: {
                float tmp = 0;

                ret = libidmefv2_extract_float_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_float(out, tmp);
                break;
        }

        case IDMEFV2_DATA_TYPE_BYTE_STRING: {
                ret = idmefv2_data_new_ptr_ref_fast(out, type, buf, len);
                break;
        }

        case IDMEFV2_DATA_TYPE_CHAR_STRING: {
                const char *tmp = NULL;

                ret = libidmefv2_extract_characters_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_ptr_ref_fast(out, type, tmp, len);
                break;
        }

        case IDMEFV2_DATA_TYPE_TIME: {
                idmefv2_time_t *time;

                ret = libidmefv2_extract_time_safe(&time, buf, len, msg);
                if ( ret < 0 )
                        return ret;

                ret = idmefv2_data_new_time(out, time);
                break;
        }

        case IDMEFV2_DATA_TYPE_UNKNOWN:
                /* nop */;
        }

        return ret;
}

/**
 * idmefv2_address_read:
 * @address: Pointer to a #idmefv2_address_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_address from the @msg message, and
 * store it into @address.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_address_read(idmefv2_address_t *address, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_ADDRESS_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_ident(address, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ADDRESS_TRANSLATION : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_translation(address, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ADDRESS_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_category(address, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_ADDRESS_VLAN_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_vlan_name(address, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ADDRESS_VLAN_NUM : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_vlan_num(address, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ADDRESS_ADDRESS : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_address(address, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ADDRESS_NETMASK : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_address_set_netmask(address, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_address_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_user_id_read:
 * @user_id: Pointer to a #idmefv2_user_id_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_user_id from the @msg message, and
 * store it into @user_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_id_read(idmefv2_user_id_t *user_id, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_USER_ID_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_id_set_ident(user_id, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_USER_ID_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_id_set_category(user_id, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_USER_ID_TTY : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_id_set_tty(user_id, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_USER_ID_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_id_set_name(user_id, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_USER_ID_NUMBER : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_id_set_number(user_id, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_user_id_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_node_name_read:
 * @node_name: Pointer to a #idmefv2_node_name_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_node_name from the @msg message, and
 * store it into @node_name.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_name_read(idmefv2_node_name_t *node_name, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_NODE_NAME_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_node_name_set_category(node_name, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_NODE_NAME_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_node_name_set_name(node_name, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_node_name_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_location_read:
 * @location: Pointer to a #idmefv2_location_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_location from the @msg message, and
 * store it into @location.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_location_read(idmefv2_location_t *location, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_LOCATION_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_name(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_LATITUDE : {
                                float tmp = 0;

                                ret = libidmefv2_extract_float_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_latitude(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_LONGITUDE : {
                                float tmp = 0;

                                ret = libidmefv2_extract_float_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_longitude(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_ALTITUDE : {
                                float tmp = 0;

                                ret = libidmefv2_extract_float_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_altitude(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_COUNTRY : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_country(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_CITY : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_city(location, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LOCATION_POSTCODE : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_location_set_postcode(location, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_location_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_interface_read:
 * @interface: Pointer to a #idmefv2_interface_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_interface from the @msg message, and
 * store it into @interface.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_interface_read(idmefv2_interface_t *interface, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_INTERFACE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_interface_set_name(interface, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_INTERFACE_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_interface_set_category(interface, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_INTERFACE_MEANING : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_interface_set_meaning(interface, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ADDRESS_TAG: {
                                int ret;
                                idmefv2_address_t *tmp = NULL;
                                ret = idmefv2_interface_new_address(interface, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_address_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_interface_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_file_access_read:
 * @file_access: Pointer to a #idmefv2_file_access_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_file_access from the @msg message, and
 * store it into @file_access.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_access_read(idmefv2_file_access_t *file_access, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_USER_ID_TAG: {
                                int ret;
                                idmefv2_user_id_t *tmp = NULL;
                                ret = idmefv2_file_access_new_user_id(file_access, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_user_id_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_FILE_ACCESS_PERMISSION : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_access_set_permission(file_access, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_file_access_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_inode_read:
 * @inode: Pointer to a #idmefv2_inode_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_inode from the @msg message, and
 * store it into @inode.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_inode_read(idmefv2_inode_t *inode, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_INODE_NUMBER : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_number(inode, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_INODE_MAJOR_DEVICE : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_major_device(inode, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_INODE_MINOR_DEVICE : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_minor_device(inode, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_INODE_C_MAJOR_DEVICE : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_c_major_device(inode, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_INODE_C_MINOR_DEVICE : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_c_minor_device(inode, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_INODE_CHANGE_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_inode_set_change_time(inode, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_inode_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_checksum_read:
 * @checksum: Pointer to a #idmefv2_checksum_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_checksum from the @msg message, and
 * store it into @checksum.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_checksum_read(idmefv2_checksum_t *checksum, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_CHECKSUM_VALUE : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_checksum_set_value(checksum, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_CHECKSUM_KEY : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_checksum_set_key(checksum, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_CHECKSUM_ALGORITHM : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_checksum_set_algorithm(checksum, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_checksum_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_stream_read:
 * @stream: Pointer to a #idmefv2_stream_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_stream from the @msg message, and
 * store it into @stream.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_stream_read(idmefv2_stream_t *stream, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_STREAM_OFFSETUNIT : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_stream_set_offsetunit(stream, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_STREAM_OFFSET : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_stream_set_offset(stream, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_stream_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_file_read:
 * @file: Pointer to a #idmefv2_file_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_file from the @msg message, and
 * store it into @file.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_read(idmefv2_file_t *file, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_FILE_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_ident(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_name(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_PATH : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_path(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_CREATE_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_create_time(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_MODIFY_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_modify_time(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_ACCESS_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_access_time(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_DATA_SIZE : {
                                uint64_t tmp = 0;

                                ret = libidmefv2_extract_uint64_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_data_size(file, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_FILE_DISK_SIZE : {
                                uint64_t tmp = 0;

                                ret = libidmefv2_extract_uint64_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_disk_size(file, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_FILE_ACCESS_TAG: {
                                int ret;
                                idmefv2_file_access_t *tmp = NULL;
                                ret = idmefv2_file_new_file_access(file, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_file_access_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_LINKAGE_TAG: {
                                int ret;
                                idmefv2_linkage_t *tmp = NULL;
                                ret = idmefv2_file_new_linkage(file, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_linkage_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_INODE_TAG: {
                                int ret;
                                idmefv2_inode_t *tmp = NULL;
                                ret = idmefv2_file_new_inode(file, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_inode_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_CHECKSUM_TAG: {
                                int ret;
                                idmefv2_checksum_t *tmp = NULL;
                                ret = idmefv2_file_new_checksum(file, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_checksum_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_FILE_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_category(file, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_FILE_FILE_TYPE : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_file_set_file_type(file, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_CONTAINER_TAG: {
                                int ret;
                                idmefv2_container_t *tmp = NULL;
                                ret = idmefv2_file_new_container(file, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_container_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_STREAM_TAG: {
                                int ret;
                                idmefv2_stream_t *tmp = NULL;
                                ret = idmefv2_file_new_stream(file, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_stream_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_file_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_linkage_read:
 * @linkage: Pointer to a #idmefv2_linkage_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_linkage from the @msg message, and
 * store it into @linkage.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_linkage_read(idmefv2_linkage_t *linkage, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_LINKAGE_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_linkage_set_category(linkage, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_LINKAGE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_linkage_set_name(linkage, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_LINKAGE_PATH : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_linkage_set_path(linkage, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_FILE_TAG: {
                                int ret;
                                idmefv2_file_t *tmp = NULL;
                                ret = idmefv2_linkage_new_file(linkage, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_file_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_linkage_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_container_read:
 * @container: Pointer to a #idmefv2_container_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_container from the @msg message, and
 * store it into @container.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_container_read(idmefv2_container_t *container, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_CONTAINER_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_container_set_name(container, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_CONTAINER_PATH : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_container_set_path(container, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_FILE_TAG: {
                                int ret;
                                idmefv2_file_t *tmp = NULL;
                                ret = idmefv2_container_new_file(container, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_file_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_container_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_process_read:
 * @process: Pointer to a #idmefv2_process_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_process from the @msg message, and
 * store it into @process.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_process_read(idmefv2_process_t *process, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_PROCESS_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_ident(process, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_PROCESS_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_name(process, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_PROCESS_PID : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_pid(process, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_PROCESS_PATH : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_path(process, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_PROCESS_ARG : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_arg(process, tmp, -1);
                                break;
                        }


                        case IDMEFV2_MSG_PROCESS_ENV : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_env(process, tmp, -1);
                                break;
                        }



                        case IDMEFV2_MSG_PROCESS_TID : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_process_set_tid(process, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_process_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_service_read:
 * @service: Pointer to a #idmefv2_service_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_service from the @msg message, and
 * store it into @service.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_service_read(idmefv2_service_t *service, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_SERVICE_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_ident(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_IANA_PROTOCOL_NUMBER : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_iana_protocol_number(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_IANA_PROTOCOL_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_iana_protocol_name(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_name(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_PORT : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_port(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_PORTLIST : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_portlist(service, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_SERVICE_PROTOCOL : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_service_set_protocol(service, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_service_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_node_read:
 * @node: Pointer to a #idmefv2_node_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_node from the @msg message, and
 * store it into @node.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_read(idmefv2_node_t *node, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_NODE_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_node_set_ident(node, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_LOCATION_TAG: {
                                int ret;
                                idmefv2_location_t *tmp = NULL;
                                ret = idmefv2_node_new_location(node, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_location_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_NODE_NAME_TAG: {
                                int ret;
                                idmefv2_node_name_t *tmp = NULL;
                                ret = idmefv2_node_new_node_name(node, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_node_name_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_INTERFACE_TAG: {
                                int ret;
                                idmefv2_interface_t *tmp = NULL;
                                ret = idmefv2_node_new_interface(node, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_interface_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_node_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_user_read:
 * @user: Pointer to a #idmefv2_user_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_user from the @msg message, and
 * store it into @user.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_read(idmefv2_user_t *user, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_USER_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_set_ident(user, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_USER_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_user_set_category(user, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_USER_ID_TAG: {
                                int ret;
                                idmefv2_user_id_t *tmp = NULL;
                                ret = idmefv2_user_new_user_id(user, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_user_id_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_user_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_impact_type_read:
 * @impact_type: Pointer to a #idmefv2_impact_type_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_impact_type from the @msg message, and
 * store it into @impact_type.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_type_read(idmefv2_impact_type_t *impact_type, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_IMPACT_TYPE_ORIGIN : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_type_set_origin(impact_type, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_IMPACT_TYPE_MEANING : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_type_set_meaning(impact_type, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_TYPE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_type_set_name(impact_type, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_TYPE_URL : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_type_set_url(impact_type, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_impact_type_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_source_read:
 * @source: Pointer to a #idmefv2_source_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_source from the @msg message, and
 * store it into @source.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_source_read(idmefv2_source_t *source, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_SOURCE_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_source_set_ident(source, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_SOURCE_SPOOFED : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_source_set_spoofed(source, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_NODE_TAG: {
                                int ret;
                                idmefv2_node_t *tmp = NULL;
                                ret = idmefv2_source_new_node(source, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_node_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_USER_TAG: {
                                int ret;
                                idmefv2_user_t *tmp = NULL;
                                ret = idmefv2_source_new_user(source, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_user_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_PROCESS_TAG: {
                                int ret;
                                idmefv2_process_t *tmp = NULL;
                                ret = idmefv2_source_new_process(source, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_process_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_SERVICE_TAG: {
                                int ret;
                                idmefv2_service_t *tmp = NULL;
                                ret = idmefv2_source_new_service(source, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_service_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_source_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_target_read:
 * @target: Pointer to a #idmefv2_target_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_target from the @msg message, and
 * store it into @target.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_target_read(idmefv2_target_t *target, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_TARGET_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_target_set_ident(target, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_TARGET_DECOY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_target_set_decoy(target, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_NODE_TAG: {
                                int ret;
                                idmefv2_node_t *tmp = NULL;
                                ret = idmefv2_target_new_node(target, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_node_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_USER_TAG: {
                                int ret;
                                idmefv2_user_t *tmp = NULL;
                                ret = idmefv2_target_new_user(target, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_user_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_PROCESS_TAG: {
                                int ret;
                                idmefv2_process_t *tmp = NULL;
                                ret = idmefv2_target_new_process(target, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_process_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_SERVICE_TAG: {
                                int ret;
                                idmefv2_service_t *tmp = NULL;
                                ret = idmefv2_target_new_service(target, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_service_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_FILE_TAG: {
                                int ret;
                                idmefv2_file_t *tmp = NULL;
                                ret = idmefv2_target_new_file(target, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_file_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_target_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_original_data_read:
 * @original_data: Pointer to a #idmefv2_original_data_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_original_data from the @msg message, and
 * store it into @original_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_original_data_read(idmefv2_original_data_t *original_data, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_ORIGINAL_DATA_TIMESTAMP : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_original_data_set_timestamp(original_data, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ORIGINAL_DATA_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_original_data_set_name(original_data, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ORIGINAL_DATA_DATA : {
                                idmefv2_data_t *tmp = NULL;

                                ret = libidmefv2_extract_data_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_original_data_set_data(original_data, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_NODE_TAG: {
                                int ret;
                                idmefv2_node_t *tmp = NULL;
                                ret = idmefv2_original_data_new_node(original_data, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_node_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_FILE_TAG: {
                                int ret;
                                idmefv2_file_t *tmp = NULL;
                                ret = idmefv2_original_data_new_file(original_data, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_file_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_original_data_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_observable_read:
 * @observable: Pointer to a #idmefv2_observable_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_observable from the @msg message, and
 * store it into @observable.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_observable_read(idmefv2_observable_t *observable, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_OBSERVABLE_ORIGIN : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_observable_set_origin(observable, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_OBSERVABLE_MEANING : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_observable_set_meaning(observable, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_OBSERVABLE_URL : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_observable_set_url(observable, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_OBSERVABLE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_observable_set_name(observable, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_observable_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_taken_action_read:
 * @taken_action: Pointer to a #idmefv2_taken_action_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_taken_action from the @msg message, and
 * store it into @taken_action.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_taken_action_read(idmefv2_taken_action_t *taken_action, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_TAKEN_ACTION_CATEGORY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_taken_action_set_category(taken_action, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_taken_action_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_reference_read:
 * @reference: Pointer to a #idmefv2_reference_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_reference from the @msg message, and
 * store it into @reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_reference_read(idmefv2_reference_t *reference, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_REFERENCE_ORIGIN : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_origin(reference, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_REFERENCE_MEANING : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_meaning(reference, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_REFERENCE_AUTHOR : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_author(reference, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_REFERENCE_PUBLICATION_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_publication_time(reference, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_REFERENCE_VERSION : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_version(reference, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_REFERENCE_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_name(reference, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_REFERENCE_URL : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_reference_set_url(reference, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_reference_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_analyzer_read:
 * @analyzer: Pointer to a #idmefv2_analyzer_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_analyzer from the @msg message, and
 * store it into @analyzer.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analyzer_read(idmefv2_analyzer_t *analyzer, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_ANALYZER_ANALYZERID : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_analyzerid(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_name(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_MANUFACTURER : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_manufacturer(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_MODEL : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_model(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_VERSION : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_version(analyzer, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ANALYZER_CLASS : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_class(analyzer, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_ANALYZER_OSTYPE : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_ostype(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_OSVERSION : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_osversion(analyzer, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_EXT_CLASS : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_ext_class(analyzer, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ANALYZER_ANALYZERACTION : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_analyzeraction(analyzer, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_ANALYZER_ACTIONHISTORY : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_actionhistory(analyzer, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_NODE_TAG: {
                                int ret;
                                idmefv2_node_t *tmp = NULL;
                                ret = idmefv2_analyzer_new_node(analyzer, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_node_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_PROCESS_TAG: {
                                int ret;
                                idmefv2_process_t *tmp = NULL;
                                ret = idmefv2_analyzer_new_process(analyzer, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_process_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }



                        case IDMEFV2_MSG_ANALYZER_ANALYZER_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_analyzer_set_analyzer_time(analyzer, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_analyzer_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_additional_data_read:
 * @additional_data: Pointer to a #idmefv2_additional_data_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_additional_data from the @msg message, and
 * store it into @additional_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_additional_data_read(idmefv2_additional_data_t *additional_data, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_ADDITIONAL_DATA_MEANING : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_additional_data_set_meaning(additional_data, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ADDITIONAL_DATA_TYPE : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_additional_data_set_type(additional_data, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_ADDITIONAL_DATA_DATA : {
                                idmefv2_data_t *tmp = NULL;

                                ret = libidmefv2_extract_data_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_additional_data_set_data(additional_data, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_additional_data_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_correlation_alert_read:
 * @correlation_alert: Pointer to a #idmefv2_correlation_alert_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_correlation_alert from the @msg message, and
 * store it into @correlation_alert.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_correlation_alert_read(idmefv2_correlation_alert_t *correlation_alert, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_CORRELATION_ALERT_NAME : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_correlation_alert_set_name(correlation_alert, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_CORRELATION_ALERT_ALERTIDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_correlation_alert_set_alertident(correlation_alert, tmp, -1);
                                break;
                        }



                        case IDMEFV2_MSG_CORRELATION_ALERT_DURATION : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_correlation_alert_set_duration(correlation_alert, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_CORRELATION_ALERT_COUNTER : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_correlation_alert_set_counter(correlation_alert, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_correlation_alert_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_analysis_data_read:
 * @analysis_data: Pointer to a #idmefv2_analysis_data_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_analysis_data from the @msg message, and
 * store it into @analysis_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analysis_data_read(idmefv2_analysis_data_t *analysis_data, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_OBSERVABLE_TAG: {
                                int ret;
                                idmefv2_observable_t *tmp = NULL;
                                ret = idmefv2_analysis_data_new_observable(analysis_data, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_observable_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_ORIGINAL_DATA_TAG: {
                                int ret;
                                idmefv2_original_data_t *tmp = NULL;
                                ret = idmefv2_analysis_data_new_original_data(analysis_data, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_original_data_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_analysis_data_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_confidence_read:
 * @confidence: Pointer to a #idmefv2_confidence_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_confidence from the @msg message, and
 * store it into @confidence.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_confidence_read(idmefv2_confidence_t *confidence, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_CONFIDENCE_RATING : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_confidence_set_rating(confidence, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_confidence_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_impact_read:
 * @impact: Pointer to a #idmefv2_impact_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_impact from the @msg message, and
 * store it into @impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_read(idmefv2_impact_t *impact, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_IMPACT_SEVERITY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_severity(impact, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_COMPLETION : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_completion(impact, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_AVAILABILITY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_availability(impact, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_INTEGRITY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_integrity(impact, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_IMPACT_CONFIDENTIALITY : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_confidentiality(impact, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_IMPACT_DESCRIPTION : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_impact_set_description(impact, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_IMPACT_TYPE_TAG: {
                                int ret;
                                idmefv2_impact_type_t *tmp = NULL;
                                ret = idmefv2_impact_new_impact_type(impact, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_impact_type_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_impact_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_recommanded_action_read:
 * @recommanded_action: Pointer to a #idmefv2_recommanded_action_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_recommanded_action from the @msg message, and
 * store it into @recommanded_action.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_recommanded_action_read(idmefv2_recommanded_action_t *recommanded_action, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_RECOMMANDED_ACTION_ACTION : {
                                int32_t tmp = 0;

                                ret = libidmefv2_extract_int32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_recommanded_action_set_action(recommanded_action, tmp);
                                break;
                        }




                        case IDMEFV2_MSG_RECOMMANDED_ACTION_STEP : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_recommanded_action_set_step(recommanded_action, tmp);
                                break;
                        }

                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_recommanded_action_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_assessment_read:
 * @assessment: Pointer to a #idmefv2_assessment_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_assessment from the @msg message, and
 * store it into @assessment.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_assessment_read(idmefv2_assessment_t *assessment, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {


                        case IDMEFV2_MSG_IMPACT_TAG: {
                                int ret;
                                idmefv2_impact_t *tmp = NULL;
                                ret = idmefv2_assessment_new_impact(assessment, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_impact_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_TAKEN_ACTION_TAG: {
                                int ret;
                                idmefv2_taken_action_t *tmp = NULL;
                                ret = idmefv2_assessment_new_taken_action(assessment, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_taken_action_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_CONFIDENCE_TAG: {
                                int ret;
                                idmefv2_confidence_t *tmp = NULL;
                                ret = idmefv2_assessment_new_confidence(assessment, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_confidence_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_RECOMMANDED_ACTION_TAG: {
                                int ret;
                                idmefv2_recommanded_action_t *tmp = NULL;
                                ret = idmefv2_assessment_new_recommanded_action(assessment, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_recommanded_action_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_assessment_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_classification_read:
 * @classification: Pointer to a #idmefv2_classification_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_classification from the @msg message, and
 * store it into @classification.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_classification_read(idmefv2_classification_t *classification, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_CLASSIFICATION_IDENT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_classification_set_ident(classification, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_CLASSIFICATION_TEXT : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_classification_set_text(classification, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_REFERENCE_TAG: {
                                int ret;
                                idmefv2_reference_t *tmp = NULL;
                                ret = idmefv2_classification_new_reference(classification, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_reference_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_classification_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_heartbeat_read:
 * @heartbeat: Pointer to a #idmefv2_heartbeat_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_heartbeat from the @msg message, and
 * store it into @heartbeat.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_heartbeat_read(idmefv2_heartbeat_t *heartbeat, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_HEARTBEAT_MESSAGEID : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_heartbeat_set_messageid(heartbeat, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ANALYZER_TAG: {
                                int ret;
                                idmefv2_analyzer_t *tmp = NULL;
                                ret = idmefv2_heartbeat_new_analyzer(heartbeat, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_analyzer_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }



                        case IDMEFV2_MSG_HEARTBEAT_CREATE_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_heartbeat_set_create_time(heartbeat, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_HEARTBEAT_HEARTBEAT_INTERVAL : {
                                uint32_t tmp = 0;

                                ret = libidmefv2_extract_uint32_safe(&tmp, buf, len);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_heartbeat_set_heartbeat_interval(heartbeat, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ADDITIONAL_DATA_TAG: {
                                int ret;
                                idmefv2_additional_data_t *tmp = NULL;
                                ret = idmefv2_heartbeat_new_additional_data(heartbeat, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_additional_data_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_heartbeat_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_alert_read:
 * @alert: Pointer to a #idmefv2_alert_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_alert from the @msg message, and
 * store it into @alert.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_alert_read(idmefv2_alert_t *alert, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_ALERT_MESSAGEID : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_alert_set_messageid(alert, tmp);
                                break;
                        }



                        case IDMEFV2_MSG_ALERT_ANALYZERHASH : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_alert_set_analyzerhash(alert, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ANALYZER_TAG: {
                                int ret;
                                idmefv2_analyzer_t *tmp = NULL;
                                ret = idmefv2_alert_new_analyzer(alert, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_analyzer_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_ALERT_CREATE_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_alert_set_create_time(alert, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_CLASSIFICATION_TAG: {
                                int ret;
                                idmefv2_classification_t *tmp = NULL;
                                ret = idmefv2_alert_new_classification(alert, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_classification_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }



                        case IDMEFV2_MSG_ALERT_DETECT_TIME : {
                                idmefv2_time_t *tmp = NULL;

                                ret = libidmefv2_extract_time_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_alert_set_detect_time(alert, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ANALYSIS_DATA_TAG: {
                                int ret;
                                idmefv2_analysis_data_t *tmp = NULL;
                                ret = idmefv2_alert_new_analysis_data(alert, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_analysis_data_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_SOURCE_TAG: {
                                int ret;
                                idmefv2_source_t *tmp = NULL;
                                ret = idmefv2_alert_new_source(alert, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_source_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_TARGET_TAG: {
                                int ret;
                                idmefv2_target_t *tmp = NULL;
                                ret = idmefv2_alert_new_target(alert, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_target_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_ASSESSMENT_TAG: {
                                int ret;
                                idmefv2_assessment_t *tmp = NULL;
                                ret = idmefv2_alert_new_assessment(alert, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_assessment_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }


                        case IDMEFV2_MSG_ADDITIONAL_DATA_TAG: {
                                int ret;
                                idmefv2_additional_data_t *tmp = NULL;
                                ret = idmefv2_alert_new_additional_data(alert, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_additional_data_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_CORRELATION_ALERT_TAG: {
                                int ret;
                                idmefv2_correlation_alert_t *tmp = NULL;
                                ret = idmefv2_alert_new_correlation_alert(alert, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_correlation_alert_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_alert_t: '%u'", tag);
                }

        }

        return 0;
}
/**
 * idmefv2_message_read:
 * @message: Pointer to a #idmefv2_message_t object.
 * @msg: Pointer to a #libidmefv2_msg_t object, containing a message.
 *
 * Read an idmefv2_message from the @msg message, and
 * store it into @message.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_message_read(idmefv2_message_t *message, libidmefv2_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = libidmefv2_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {



                        case IDMEFV2_MSG_MESSAGE_VERSION : {
                                libidmefv2_string_t *tmp = NULL;

                                ret = libidmefv2_extract_string_safe(&tmp, buf, len, msg);
                                if ( ret < 0 )
                                        return ret;
                                idmefv2_message_set_version(message, tmp);
                                break;
                        }


                        case IDMEFV2_MSG_ALERT_TAG: {
                                int ret;
                                idmefv2_alert_t *tmp = NULL;
                                ret = idmefv2_message_new_alert(message, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_alert_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }

                        case IDMEFV2_MSG_HEARTBEAT_TAG: {
                                int ret;
                                idmefv2_heartbeat_t *tmp = NULL;
                                ret = idmefv2_message_new_heartbeat(message, &tmp);
                                if ( ret < 0 )
                                        return ret;


                                ret = idmefv2_heartbeat_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
                        case IDMEFV2_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_TAG, "Unknown tag while readingidmefv2_message_t: '%u'", tag);
                }

        }

        return 0;
}
