

















/*****
*
* Based on GenerateIDMEFV2TreeWrapC.pm
* Author: Sebastien Tricaud <stricaud@inl.fr>
*
* This file is part of the LibIdemfv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIDMEFV2TreeWrapCppBindings package */

#include "config.h"

#include "idmefv2-tree-wrap.hxx"
#include "common.h"


static std::string *to_string(libidmefv2_string_t *str)
{
        return new std::string(libidmefv2_string_get_string(str));
}


static libidmefv2_string_t *from_string(std::string *str)
{
        int ret;
        libidmefv2_string_t *pstr;

        ret = libidmefv2_string_new_dup_fast(&pstr, str->c_str(), str->length());
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        return pstr;
}

    

/**
 * idmefv2_linkage_new:
 * @ret: Pointer where to store the created #idmefv2_linkage_t object.
 *
 * Create a new #idmefv2_linkage_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage::IDMEFV2linkage()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}






/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_linkage_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2linkage::copy(IDMEFV2linkage *dst)
{
        return idmefv2_linkage_copy(_priv, dst->_priv);
}



/**
 * idmefv2_linkage_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage *IDMEFV2linkage::clone()
{
        int ret;
        idmefv2_linkage_t *dst;
        IDMEFV2linkage *ptr;

        ret = idmefv2_linkage_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2linkage();
        idmefv2_linkage_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_linkage_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2linkage::compare(IDMEFV2linkage *obj)
{
        return idmefv2_linkage_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_idmefv2_message_new:
 * @ret: Pointer where to store the created #idmefv2_idmefv2_message_t object.
 *
 * Create a new #idmefv2_idmefv2_message_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2idmefv2_message::IDMEFV2idmefv2_message()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}





/**
 * idmefv2_idmefv2_message_get_type_:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 *
 * Access the type_ children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_IDMEFV2_Message_type__t children, or NULL if it is not set.
 */
idmefv2_IDMEFV2_Message_type__t IDMEFV2idmefv2_message::get_type_()
{
        return idmefv2_idmefv2_message_get_type_(_priv);
}
/**
 * idmefv2_idmefv2_message_get_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 *
 * Access the idmefv2_message children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_idmefv2_message_t children, or NULL if it is not set.
 */
idmefv2_idmefv2_message_t *IDMEFV2idmefv2_message::get_idmefv2_message()
{
        return idmefv2_idmefv2_message_get_idmefv2_message(_priv);
}
/**
 * idmefv2_idmefv2_message_set_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 * @idmefv2_message: pointer to a #idmefv2_idmefv2_message_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @idmefv2_message object.
 */
void IDMEFV2idmefv2_message::set_idmefv2_message(idmefv2_idmefv2_message_t *idmefv2_message)
{
        idmefv2_idmefv2_message_set_idmefv2_message(_priv, idmefv2_message);
}
/**
 * idmefv2_$struct->{short_type_name}_new_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_idmefv2_message_t object.
 *
 * Create a new idmefv2_idmefv2_message_t object, children of #idmefv2_idmefv2_message_t.
 * If @ptr already contain a #idmefv2_idmefv2_message_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2idmefv2_message::new_idmefv2_message()
{
        int ret;
        idmefv2_idmefv2_message_t *ptr;
        IDMEFV2idmefv2_message *obj;

        ret = idmefv2_idmefv2_message_new_idmefv2_message(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2idmefv2_message;
        idmefv2_idmefv2_message_destroy(obj->_priv);
        obj->_priv = ptr;
}
/**
 * idmefv2_idmefv2_message_get_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 *
 * Access the idmefv2_message children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_idmefv2_message_t children, or NULL if it is not set.
 */
idmefv2_idmefv2_message_t *IDMEFV2idmefv2_message::get_idmefv2_message()
{
        return idmefv2_idmefv2_message_get_idmefv2_message(_priv);
}
/**
 * idmefv2_idmefv2_message_set_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 * @idmefv2_message: pointer to a #idmefv2_idmefv2_message_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @idmefv2_message object.
 */
void IDMEFV2idmefv2_message::set_idmefv2_message(idmefv2_idmefv2_message_t *idmefv2_message)
{
        idmefv2_idmefv2_message_set_idmefv2_message(_priv, idmefv2_message);
}
/**
 * idmefv2_$struct->{short_type_name}_new_idmefv2_message:
 * @ptr: pointer to a #idmefv2_idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_idmefv2_message_t object.
 *
 * Create a new idmefv2_idmefv2_message_t object, children of #idmefv2_idmefv2_message_t.
 * If @ptr already contain a #idmefv2_idmefv2_message_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2idmefv2_message::new_idmefv2_message()
{
        int ret;
        idmefv2_idmefv2_message_t *ptr;
        IDMEFV2idmefv2_message *obj;

        ret = idmefv2_idmefv2_message_new_idmefv2_message(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2idmefv2_message;
        idmefv2_idmefv2_message_destroy(obj->_priv);
        obj->_priv = ptr;
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_idmefv2_message_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2idmefv2_message::copy(IDMEFV2idmefv2_message *dst)
{
        return idmefv2_idmefv2_message_copy(_priv, dst->_priv);
}



/**
 * idmefv2_idmefv2_message_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2idmefv2_message *IDMEFV2idmefv2_message::clone()
{
        int ret;
        idmefv2_idmefv2_message_t *dst;
        IDMEFV2idmefv2_message *ptr;

        ret = idmefv2_idmefv2_message_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2idmefv2_message();
        idmefv2_idmefv2_message_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_idmefv2_message_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2idmefv2_message::compare(IDMEFV2idmefv2_message *obj)
{
        return idmefv2_idmefv2_message_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_alert_new:
 * @ret: Pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new #idmefv2_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2alert::IDMEFV2alert()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2alert::get_messageid()
{
        return $tocast(idmefv2_alert_get_messageid(_priv));
} 
  


void IDMEFV2alert::set_messageid(libidmefv2_string_t *messageid)
{
        idmefv2_alert_set_messageid(this, messageid);
}        




idmefv2_detect_time_t  IDMEFV2alert::get_detect_time()
{
        return $tocast(idmefv2_alert_get_detect_time(_priv));
} 
  
void IDMEFV2alert::set_detect_time(idmefv2_detect_time_t detect_time)
{
        idmefv2_alert_set_detect_time(this, detect_time);
}




idmefv2_analyzer_time_t  IDMEFV2alert::get_analyzer_time()
{
        return $tocast(idmefv2_alert_get_analyzer_time(_priv));
} 
  
void IDMEFV2alert::set_analyzer_time(idmefv2_analyzer_time_t analyzer_time)
{
        idmefv2_alert_set_analyzer_time(this, analyzer_time);
}




idmefv2_assessment_t  IDMEFV2alert::get_assessment()
{
        return $tocast(idmefv2_alert_get_assessment(_priv));
} 
  
void IDMEFV2alert::set_assessment(idmefv2_assessment_t assessment)
{
        idmefv2_alert_set_assessment(this, assessment);
}



/**
 * idmefv2_alert_get_next_additional_data:
 * @alert: pointer to a #idmefv2_alert_t object.
 * @additional_data_cur: pointer to a #idmefv2_additional_data_t object.
 *
 * Get the next #idmefv2_additional_data_t object listed in @ptr.
 * When iterating over the idmefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_additional_data_t object.
 *
 * Returns: the next #idmefv2_additional_data_t in the list.
 */
idmefv2_additional_data_t *IDMEFV2alert::get_next_additional_data(idmefv2_additional_data_t *additional_data_cur)
{
        return idmefv2_alert_get_next_additional_data(_priv, additional_data_cur);
}


/**
 * idmefv2_alert_set_additional_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @object: pointer to a #idmefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #$field->{type_name} object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void IDMEFV2alertset_additional_data(idmefv2_additional_data_t *object, int pos)
{
        idmefv2_alert_set_additional_data(_priv, object, pos);
}


/**
 * idmefv2_alert_new_additional_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #idmefv2_additional_data_t children of @ptr, and add it to position @pos of
 * \@ptr list of #idmefv2_additional_data_t object. The created #idmefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int IDMEFV2alert::new_additional_data(idmefv2_additional_data_t **ret, int pos)
{
        return idmefv2_alert_new_additional_data(_priv, ret, pos);
}


/**
 * idmefv2_alert_get_type_:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the type_ children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_type__t children, or NULL if it is not set.
 */
idmefv2_alert_type__t IDMEFV2alert::get_type_()
{
        return idmefv2_alert_get_type_(_priv);
}
/**
 * idmefv2_alert_get_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_t children, or NULL if it is not set.
 */
idmefv2_alert_t *IDMEFV2alert::get_alert()
{
        return idmefv2_alert_get_alert(_priv);
}
/**
 * idmefv2_alert_set_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void IDMEFV2alert::set_alert(idmefv2_alert_t *alert)
{
        idmefv2_alert_set_alert(_priv, alert);
}
/**
 * idmefv2_$struct->{short_type_name}_new_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new idmefv2_alert_t object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2alert::new_alert()
{
        int ret;
        idmefv2_alert_t *ptr;
        IDMEFV2alert *obj;

        ret = idmefv2_alert_new_alert(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2alert;
        idmefv2_alert_destroy(obj->_priv);
        obj->_priv = ptr;
}
/**
 * idmefv2_alert_get_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_t children, or NULL if it is not set.
 */
idmefv2_alert_t *IDMEFV2alert::get_alert()
{
        return idmefv2_alert_get_alert(_priv);
}
/**
 * idmefv2_alert_set_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void IDMEFV2alert::set_alert(idmefv2_alert_t *alert)
{
        idmefv2_alert_set_alert(_priv, alert);
}
/**
 * idmefv2_$struct->{short_type_name}_new_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new idmefv2_alert_t object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2alert::new_alert()
{
        int ret;
        idmefv2_alert_t *ptr;
        IDMEFV2alert *obj;

        ret = idmefv2_alert_new_alert(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2alert;
        idmefv2_alert_destroy(obj->_priv);
        obj->_priv = ptr;
}
/**
 * idmefv2_alert_get_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_t children, or NULL if it is not set.
 */
idmefv2_alert_t *IDMEFV2alert::get_alert()
{
        return idmefv2_alert_get_alert(_priv);
}
/**
 * idmefv2_alert_set_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void IDMEFV2alert::set_alert(idmefv2_alert_t *alert)
{
        idmefv2_alert_set_alert(_priv, alert);
}
/**
 * idmefv2_$struct->{short_type_name}_new_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new idmefv2_alert_t object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2alert::new_alert()
{
        int ret;
        idmefv2_alert_t *ptr;
        IDMEFV2alert *obj;

        ret = idmefv2_alert_new_alert(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2alert;
        idmefv2_alert_destroy(obj->_priv);
        obj->_priv = ptr;
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2alert::copy(IDMEFV2alert *dst)
{
        return idmefv2_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2alert *IDMEFV2alert::clone()
{
        int ret;
        idmefv2_alert_t *dst;
        IDMEFV2alert *ptr;

        ret = idmefv2_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2alert();
        idmefv2_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2alert::compare(IDMEFV2alert *obj)
{
        return idmefv2_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_additional_data_new:
 * @ret: Pointer where to store the created #idmefv2_additional_data_t object.
 *
 * Create a new #idmefv2_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2additional_data::IDMEFV2additional_data()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2additional_data::get_meaning()
{
        return $tocast(idmefv2_additional_data_get_meaning(_priv));
} 
  


void IDMEFV2additional_data::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_additional_data_set_meaning(this, meaning);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2additional_data::copy(IDMEFV2additional_data *dst)
{
        return idmefv2_additional_data_copy(_priv, dst->_priv);
}



/**
 * idmefv2_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2additional_data *IDMEFV2additional_data::clone()
{
        int ret;
        idmefv2_additional_data_t *dst;
        IDMEFV2additional_data *ptr;

        ret = idmefv2_additional_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2additional_data();
        idmefv2_additional_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2additional_data::compare(IDMEFV2additional_data *obj)
{
        return idmefv2_additional_data_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_source_spoofed_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_source_spoofed_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_source_spoofed_t IDMEFV2source_spoofed::source_spoofed_to_numeric(const char *name)
{
        return idmefv2_source_spoofed_to_numeric(name);
}

/**
 * idmefv2_source_spoofed_to_string:
 * @val: an enumeration value for #idmefv2_source_spoofed_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_source_spoofed_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2source_spoofed::to_string(idmefv2_source_spoofed_t val)
{
        return idmefv2_source_spoofed_to_string(val);
}

    

/**
 * idmefv2_source_new:
 * @ret: Pointer where to store the created #idmefv2_source_t object.
 *
 * Create a new #idmefv2_source_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2source::IDMEFV2source()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2source::get_ident()
{
        return $tocast(idmefv2_source_get_ident(_priv));
} 
  


void IDMEFV2source::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_source_set_ident(this, ident);
}        




idmefv2_source_spoofed_t  IDMEFV2source::get_spoofed()
{
        return $tocast(idmefv2_source_get_spoofed(_priv));
} 
  
void IDMEFV2source::set_spoofed(idmefv2_source_spoofed_t spoofed)
{
        idmefv2_source_set_spoofed(this, spoofed);
}




std::string * IDMEFV2source::get_interface()
{
        return $tocast(idmefv2_source_get_interface(_priv));
} 
  


void IDMEFV2source::set_interface(libidmefv2_string_t *interface)
{
        idmefv2_source_set_interface(this, interface);
}        




idmefv2_node_t  IDMEFV2source::get_node()
{
        return $tocast(idmefv2_source_get_node(_priv));
} 
  
void IDMEFV2source::set_node(idmefv2_node_t node)
{
        idmefv2_source_set_node(this, node);
}




idmefv2_user_t  IDMEFV2source::get_user()
{
        return $tocast(idmefv2_source_get_user(_priv));
} 
  
void IDMEFV2source::set_user(idmefv2_user_t user)
{
        idmefv2_source_set_user(this, user);
}




idmefv2_process_t  IDMEFV2source::get_process()
{
        return $tocast(idmefv2_source_get_process(_priv));
} 
  
void IDMEFV2source::set_process(idmefv2_process_t process)
{
        idmefv2_source_set_process(this, process);
}




idmefv2_service_t  IDMEFV2source::get_service()
{
        return $tocast(idmefv2_source_get_service(_priv));
} 
  
void IDMEFV2source::set_service(idmefv2_service_t service)
{
        idmefv2_source_set_service(this, service);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_source_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2source::copy(IDMEFV2source *dst)
{
        return idmefv2_source_copy(_priv, dst->_priv);
}



/**
 * idmefv2_source_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2source *IDMEFV2source::clone()
{
        int ret;
        idmefv2_source_t *dst;
        IDMEFV2source *ptr;

        ret = idmefv2_source_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2source();
        idmefv2_source_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_source_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2source::compare(IDMEFV2source *obj)
{
        return idmefv2_source_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_target_decoy_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_target_decoy_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_target_decoy_t IDMEFV2target_decoy::target_decoy_to_numeric(const char *name)
{
        return idmefv2_target_decoy_to_numeric(name);
}

/**
 * idmefv2_target_decoy_to_string:
 * @val: an enumeration value for #idmefv2_target_decoy_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_target_decoy_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2target_decoy::to_string(idmefv2_target_decoy_t val)
{
        return idmefv2_target_decoy_to_string(val);
}

    

/**
 * idmefv2_target_new:
 * @ret: Pointer where to store the created #idmefv2_target_t object.
 *
 * Create a new #idmefv2_target_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2target::IDMEFV2target()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2target::get_ident()
{
        return $tocast(idmefv2_target_get_ident(_priv));
} 
  


void IDMEFV2target::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_target_set_ident(this, ident);
}        




idmefv2_target_decoy_t  IDMEFV2target::get_decoy()
{
        return $tocast(idmefv2_target_get_decoy(_priv));
} 
  
void IDMEFV2target::set_decoy(idmefv2_target_decoy_t decoy)
{
        idmefv2_target_set_decoy(this, decoy);
}




std::string * IDMEFV2target::get_interface()
{
        return $tocast(idmefv2_target_get_interface(_priv));
} 
  


void IDMEFV2target::set_interface(libidmefv2_string_t *interface)
{
        idmefv2_target_set_interface(this, interface);
}        




idmefv2_node_t  IDMEFV2target::get_node()
{
        return $tocast(idmefv2_target_get_node(_priv));
} 
  
void IDMEFV2target::set_node(idmefv2_node_t node)
{
        idmefv2_target_set_node(this, node);
}




idmefv2_user_t  IDMEFV2target::get_user()
{
        return $tocast(idmefv2_target_get_user(_priv));
} 
  
void IDMEFV2target::set_user(idmefv2_user_t user)
{
        idmefv2_target_set_user(this, user);
}




idmefv2_process_t  IDMEFV2target::get_process()
{
        return $tocast(idmefv2_target_get_process(_priv));
} 
  
void IDMEFV2target::set_process(idmefv2_process_t process)
{
        idmefv2_target_set_process(this, process);
}




idmefv2_service_t  IDMEFV2target::get_service()
{
        return $tocast(idmefv2_target_get_service(_priv));
} 
  
void IDMEFV2target::set_service(idmefv2_service_t service)
{
        idmefv2_target_set_service(this, service);
}




idmefv2_file_t  IDMEFV2target::get_file()
{
        return $tocast(idmefv2_target_get_file(_priv));
} 
  
void IDMEFV2target::set_file(idmefv2_file_t file)
{
        idmefv2_target_set_file(this, file);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_target_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2target::copy(IDMEFV2target *dst)
{
        return idmefv2_target_copy(_priv, dst->_priv);
}



/**
 * idmefv2_target_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2target *IDMEFV2target::clone()
{
        int ret;
        idmefv2_target_t *dst;
        IDMEFV2target *ptr;

        ret = idmefv2_target_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2target();
        idmefv2_target_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_target_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2target::compare(IDMEFV2target *obj)
{
        return idmefv2_target_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_assessment_new:
 * @ret: Pointer where to store the created #idmefv2_assessment_t object.
 *
 * Create a new #idmefv2_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2assessment::IDMEFV2assessment()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_impact_t  IDMEFV2assessment::get_impact()
{
        return $tocast(idmefv2_assessment_get_impact(_priv));
} 
  
void IDMEFV2assessment::set_impact(idmefv2_impact_t impact)
{
        idmefv2_assessment_set_impact(this, impact);
}




idmefv2_confidence_t  IDMEFV2assessment::get_confidence()
{
        return $tocast(idmefv2_assessment_get_confidence(_priv));
} 
  
void IDMEFV2assessment::set_confidence(idmefv2_confidence_t confidence)
{
        idmefv2_assessment_set_confidence(this, confidence);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2assessment::copy(IDMEFV2assessment *dst)
{
        return idmefv2_assessment_copy(_priv, dst->_priv);
}



/**
 * idmefv2_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2assessment *IDMEFV2assessment::clone()
{
        int ret;
        idmefv2_assessment_t *dst;
        IDMEFV2assessment *ptr;

        ret = idmefv2_assessment_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2assessment();
        idmefv2_assessment_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2assessment::compare(IDMEFV2assessment *obj)
{
        return idmefv2_assessment_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_action_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_action_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_action_category_t IDMEFV2action_category::action_category_to_numeric(const char *name)
{
        return idmefv2_action_category_to_numeric(name);
}

/**
 * idmefv2_action_category_to_string:
 * @val: an enumeration value for #idmefv2_action_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_action_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2action_category::to_string(idmefv2_action_category_t val)
{
        return idmefv2_action_category_to_string(val);
}

    

/**
 * idmefv2_action_new:
 * @ret: Pointer where to store the created #idmefv2_action_t object.
 *
 * Create a new #idmefv2_action_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2action::IDMEFV2action()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_action_category_t  IDMEFV2action::get_category()
{
        return $tocast(idmefv2_action_get_category(_priv));
} 
  
void IDMEFV2action::set_category(idmefv2_action_category_t category)
{
        idmefv2_action_set_category(this, category);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_action_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2action::copy(IDMEFV2action *dst)
{
        return idmefv2_action_copy(_priv, dst->_priv);
}



/**
 * idmefv2_action_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2action *IDMEFV2action::clone()
{
        int ret;
        idmefv2_action_t *dst;
        IDMEFV2action *ptr;

        ret = idmefv2_action_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2action();
        idmefv2_action_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_action_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2action::compare(IDMEFV2action *obj)
{
        return idmefv2_action_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_confidence_rating_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_confidence_rating_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_confidence_rating_t IDMEFV2confidence_rating::confidence_rating_to_numeric(const char *name)
{
        return idmefv2_confidence_rating_to_numeric(name);
}

/**
 * idmefv2_confidence_rating_to_string:
 * @val: an enumeration value for #idmefv2_confidence_rating_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_confidence_rating_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2confidence_rating::to_string(idmefv2_confidence_rating_t val)
{
        return idmefv2_confidence_rating_to_string(val);
}

    

/**
 * idmefv2_confidence_new:
 * @ret: Pointer where to store the created #idmefv2_confidence_t object.
 *
 * Create a new #idmefv2_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2confidence::IDMEFV2confidence()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_confidence_rating_t  IDMEFV2confidence::get_rating()
{
        return $tocast(idmefv2_confidence_get_rating(_priv));
} 
  
void IDMEFV2confidence::set_rating(idmefv2_confidence_rating_t rating)
{
        idmefv2_confidence_set_rating(this, rating);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2confidence::copy(IDMEFV2confidence *dst)
{
        return idmefv2_confidence_copy(_priv, dst->_priv);
}



/**
 * idmefv2_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2confidence *IDMEFV2confidence::clone()
{
        int ret;
        idmefv2_confidence_t *dst;
        IDMEFV2confidence *ptr;

        ret = idmefv2_confidence_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2confidence();
        idmefv2_confidence_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2confidence::compare(IDMEFV2confidence *obj)
{
        return idmefv2_confidence_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_impact_severity_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_severity_t IDMEFV2impact_severity::impact_severity_to_numeric(const char *name)
{
        return idmefv2_impact_severity_to_numeric(name);
}

/**
 * idmefv2_impact_severity_to_string:
 * @val: an enumeration value for #idmefv2_impact_severity_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2impact_severity::to_string(idmefv2_impact_severity_t val)
{
        return idmefv2_impact_severity_to_string(val);
}

    
/*****
 * idmefv2_impact_completion_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_completion_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_completion_t IDMEFV2impact_completion::impact_completion_to_numeric(const char *name)
{
        return idmefv2_impact_completion_to_numeric(name);
}

/**
 * idmefv2_impact_completion_to_string:
 * @val: an enumeration value for #idmefv2_impact_completion_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_completion_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2impact_completion::to_string(idmefv2_impact_completion_t val)
{
        return idmefv2_impact_completion_to_string(val);
}

    
/*****
 * idmefv2_impact_type_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_type_t IDMEFV2impact_type::impact_type_to_numeric(const char *name)
{
        return idmefv2_impact_type_to_numeric(name);
}

/**
 * idmefv2_impact_type_to_string:
 * @val: an enumeration value for #idmefv2_impact_type_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2impact_type::to_string(idmefv2_impact_type_t val)
{
        return idmefv2_impact_type_to_string(val);
}

    

/**
 * idmefv2_impact_new:
 * @ret: Pointer where to store the created #idmefv2_impact_t object.
 *
 * Create a new #idmefv2_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact::IDMEFV2impact()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_impact_severity_t  IDMEFV2impact::get_severity()
{
        return $tocast(idmefv2_impact_get_severity(_priv));
} 
  
void IDMEFV2impact::set_severity(idmefv2_impact_severity_t severity)
{
        idmefv2_impact_set_severity(this, severity);
}




idmefv2_impact_completion_t  IDMEFV2impact::get_completion()
{
        return $tocast(idmefv2_impact_get_completion(_priv));
} 
  
void IDMEFV2impact::set_completion(idmefv2_impact_completion_t completion)
{
        idmefv2_impact_set_completion(this, completion);
}




idmefv2_impact_type_t  IDMEFV2impact::get_type()
{
        return $tocast(idmefv2_impact_get_type(_priv));
} 
  
void IDMEFV2impact::set_type(idmefv2_impact_type_t type)
{
        idmefv2_impact_set_type(this, type);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2impact::copy(IDMEFV2impact *dst)
{
        return idmefv2_impact_copy(_priv, dst->_priv);
}



/**
 * idmefv2_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2impact *IDMEFV2impact::clone()
{
        int ret;
        idmefv2_impact_t *dst;
        IDMEFV2impact *ptr;

        ret = idmefv2_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2impact();
        idmefv2_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2impact::compare(IDMEFV2impact *obj)
{
        return idmefv2_impact_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_classification_new:
 * @ret: Pointer where to store the created #idmefv2_classification_t object.
 *
 * Create a new #idmefv2_classification_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2classification::IDMEFV2classification()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2classification::get_ident()
{
        return $tocast(idmefv2_classification_get_ident(_priv));
} 
  


void IDMEFV2classification::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_classification_set_ident(this, ident);
}        




std::string * IDMEFV2classification::get_text()
{
        return $tocast(idmefv2_classification_get_text(_priv));
} 
  


void IDMEFV2classification::set_text(libidmefv2_string_t *text)
{
        idmefv2_classification_set_text(this, text);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_classification_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2classification::copy(IDMEFV2classification *dst)
{
        return idmefv2_classification_copy(_priv, dst->_priv);
}



/**
 * idmefv2_classification_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2classification *IDMEFV2classification::clone()
{
        int ret;
        idmefv2_classification_t *dst;
        IDMEFV2classification *ptr;

        ret = idmefv2_classification_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2classification();
        idmefv2_classification_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_classification_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2classification::compare(IDMEFV2classification *obj)
{
        return idmefv2_classification_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_reference_origin_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_reference_origin_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_reference_origin_t IDMEFV2reference_origin::reference_origin_to_numeric(const char *name)
{
        return idmefv2_reference_origin_to_numeric(name);
}

/**
 * idmefv2_reference_origin_to_string:
 * @val: an enumeration value for #idmefv2_reference_origin_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_reference_origin_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2reference_origin::to_string(idmefv2_reference_origin_t val)
{
        return idmefv2_reference_origin_to_string(val);
}

    

/**
 * idmefv2_reference_new:
 * @ret: Pointer where to store the created #idmefv2_reference_t object.
 *
 * Create a new #idmefv2_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2reference::IDMEFV2reference()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_reference_origin_t  IDMEFV2reference::get_origin()
{
        return $tocast(idmefv2_reference_get_origin(_priv));
} 
  
void IDMEFV2reference::set_origin(idmefv2_reference_origin_t origin)
{
        idmefv2_reference_set_origin(this, origin);
}




std::string * IDMEFV2reference::get_meaning()
{
        return $tocast(idmefv2_reference_get_meaning(_priv));
} 
  


void IDMEFV2reference::set_meaning(libidmefv2_string_t *meaning)
{
        idmefv2_reference_set_meaning(this, meaning);
}        




std::string * IDMEFV2reference::get_name()
{
        return $tocast(idmefv2_reference_get_name(_priv));
} 
  


void IDMEFV2reference::set_name(libidmefv2_string_t *name)
{
        idmefv2_reference_set_name(this, name);
}        




std::string * IDMEFV2reference::get_url()
{
        return $tocast(idmefv2_reference_get_url(_priv));
} 
  


void IDMEFV2reference::set_url(libidmefv2_string_t *url)
{
        idmefv2_reference_set_url(this, url);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2reference::copy(IDMEFV2reference *dst)
{
        return idmefv2_reference_copy(_priv, dst->_priv);
}



/**
 * idmefv2_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2reference *IDMEFV2reference::clone()
{
        int ret;
        idmefv2_reference_t *dst;
        IDMEFV2reference *ptr;

        ret = idmefv2_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2reference();
        idmefv2_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2reference::compare(IDMEFV2reference *obj)
{
        return idmefv2_reference_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_node_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_node_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_node_category_t IDMEFV2node_category::node_category_to_numeric(const char *name)
{
        return idmefv2_node_category_to_numeric(name);
}

/**
 * idmefv2_node_category_to_string:
 * @val: an enumeration value for #idmefv2_node_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_node_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2node_category::to_string(idmefv2_node_category_t val)
{
        return idmefv2_node_category_to_string(val);
}

    

/**
 * idmefv2_node_new:
 * @ret: Pointer where to store the created #idmefv2_node_t object.
 *
 * Create a new #idmefv2_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node::IDMEFV2node()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2node::get_ident()
{
        return $tocast(idmefv2_node_get_ident(_priv));
} 
  


void IDMEFV2node::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_node_set_ident(this, ident);
}        




idmefv2_node_category_t  IDMEFV2node::get_category()
{
        return $tocast(idmefv2_node_get_category(_priv));
} 
  
void IDMEFV2node::set_category(idmefv2_node_category_t category)
{
        idmefv2_node_set_category(this, category);
}




std::string * IDMEFV2node::get_location()
{
        return $tocast(idmefv2_node_get_location(_priv));
} 
  


void IDMEFV2node::set_location(libidmefv2_string_t *location)
{
        idmefv2_node_set_location(this, location);
}        




std::string * IDMEFV2node::get_name()
{
        return $tocast(idmefv2_node_get_name(_priv));
} 
  


void IDMEFV2node::set_name(libidmefv2_string_t *name)
{
        idmefv2_node_set_name(this, name);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2node::copy(IDMEFV2node *dst)
{
        return idmefv2_node_copy(_priv, dst->_priv);
}



/**
 * idmefv2_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2node *IDMEFV2node::clone()
{
        int ret;
        idmefv2_node_t *dst;
        IDMEFV2node *ptr;

        ret = idmefv2_node_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2node();
        idmefv2_node_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2node::compare(IDMEFV2node *obj)
{
        return idmefv2_node_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_heartbeat_new:
 * @ret: Pointer where to store the created #idmefv2_heartbeat_t object.
 *
 * Create a new #idmefv2_heartbeat_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2heartbeat::IDMEFV2heartbeat()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2heartbeat::get_messageid()
{
        return $tocast(idmefv2_heartbeat_get_messageid(_priv));
} 
  


void IDMEFV2heartbeat::set_messageid(libidmefv2_string_t *messageid)
{
        idmefv2_heartbeat_set_messageid(this, messageid);
}        




uint32_t * IDMEFV2heartbeat::get_heartbeat_interval()
{
        return $tocast(idmefv2_heartbeat_get_heartbeat_interval(_priv));
} 
  
void IDMEFV2heartbeat::set_heartbeat_interval(uint32_t heartbeat_interval)
{
        libidmefv2_return_if_fail(ptr);
        ptr->heartbeat_interval = heartbeat_interval;
        ptr->heartbeat_interval_is_set = 1;
}


void IDMEFV2heartbeat::unset_heartbeat_interval()
{
        idmefv2_heartbeat_unset_heartbeat_interval(_priv);
}




idmefv2_analyzer_time_t  IDMEFV2heartbeat::get_analyzer_time()
{
        return $tocast(idmefv2_heartbeat_get_analyzer_time(_priv));
} 
  
void IDMEFV2heartbeat::set_analyzer_time(idmefv2_analyzer_time_t analyzer_time)
{
        idmefv2_heartbeat_set_analyzer_time(this, analyzer_time);
}



/**
 * idmefv2_heartbeat_get_next_additional_data:
 * @heartbeat: pointer to a #idmefv2_heartbeat_t object.
 * @additional_data_cur: pointer to a #idmefv2_additional_data_t object.
 *
 * Get the next #idmefv2_additional_data_t object listed in @ptr.
 * When iterating over the idmefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_additional_data_t object.
 *
 * Returns: the next #idmefv2_additional_data_t in the list.
 */
idmefv2_additional_data_t *IDMEFV2heartbeat::get_next_additional_data(idmefv2_additional_data_t *additional_data_cur)
{
        return idmefv2_heartbeat_get_next_additional_data(_priv, additional_data_cur);
}


/**
 * idmefv2_heartbeat_set_additional_data:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @object: pointer to a #idmefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #$field->{type_name} object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void IDMEFV2heartbeatset_additional_data(idmefv2_additional_data_t *object, int pos)
{
        idmefv2_heartbeat_set_additional_data(_priv, object, pos);
}


/**
 * idmefv2_heartbeat_new_additional_data:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @ret: pointer to an address where to store the created #idmefv2_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #idmefv2_additional_data_t children of @ptr, and add it to position @pos of
 * \@ptr list of #idmefv2_additional_data_t object. The created #idmefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int IDMEFV2heartbeat::new_additional_data(idmefv2_additional_data_t **ret, int pos)
{
        return idmefv2_heartbeat_new_additional_data(_priv, ret, pos);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_heartbeat_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2heartbeat::copy(IDMEFV2heartbeat *dst)
{
        return idmefv2_heartbeat_copy(_priv, dst->_priv);
}



/**
 * idmefv2_heartbeat_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2heartbeat *IDMEFV2heartbeat::clone()
{
        int ret;
        idmefv2_heartbeat_t *dst;
        IDMEFV2heartbeat *ptr;

        ret = idmefv2_heartbeat_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2heartbeat();
        idmefv2_heartbeat_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_heartbeat_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2heartbeat::compare(IDMEFV2heartbeat *obj)
{
        return idmefv2_heartbeat_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_address_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_address_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_address_category_t IDMEFV2address_category::address_category_to_numeric(const char *name)
{
        return idmefv2_address_category_to_numeric(name);
}

/**
 * idmefv2_address_category_to_string:
 * @val: an enumeration value for #idmefv2_address_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_address_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2address_category::to_string(idmefv2_address_category_t val)
{
        return idmefv2_address_category_to_string(val);
}

    

/**
 * idmefv2_address_new:
 * @ret: Pointer where to store the created #idmefv2_address_t object.
 *
 * Create a new #idmefv2_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2address::IDMEFV2address()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2address::get_ident()
{
        return $tocast(idmefv2_address_get_ident(_priv));
} 
  


void IDMEFV2address::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_address_set_ident(this, ident);
}        




idmefv2_address_category_t  IDMEFV2address::get_category()
{
        return $tocast(idmefv2_address_get_category(_priv));
} 
  
void IDMEFV2address::set_category(idmefv2_address_category_t category)
{
        idmefv2_address_set_category(this, category);
}




std::string * IDMEFV2address::get_vlan_name()
{
        return $tocast(idmefv2_address_get_vlan_name(_priv));
} 
  


void IDMEFV2address::set_vlan_name(libidmefv2_string_t *vlan_name)
{
        idmefv2_address_set_vlan_name(this, vlan_name);
}        




uint32_t * IDMEFV2address::get_vlan_num()
{
        return $tocast(idmefv2_address_get_vlan_num(_priv));
} 
  
void IDMEFV2address::set_vlan_num(uint32_t vlan_num)
{
        libidmefv2_return_if_fail(ptr);
        ptr->vlan_num = vlan_num;
        ptr->vlan_num_is_set = 1;
}


void IDMEFV2address::unset_vlan_num()
{
        idmefv2_address_unset_vlan_num(_priv);
}




std::string * IDMEFV2address::get_address()
{
        return $tocast(idmefv2_address_get_address(_priv));
} 
  


void IDMEFV2address::set_address(libidmefv2_string_t *address)
{
        idmefv2_address_set_address(this, address);
}        




std::string * IDMEFV2address::get_netmask()
{
        return $tocast(idmefv2_address_get_netmask(_priv));
} 
  


void IDMEFV2address::set_netmask(libidmefv2_string_t *netmask)
{
        idmefv2_address_set_netmask(this, netmask);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2address::copy(IDMEFV2address *dst)
{
        return idmefv2_address_copy(_priv, dst->_priv);
}



/**
 * idmefv2_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2address *IDMEFV2address::clone()
{
        int ret;
        idmefv2_address_t *dst;
        IDMEFV2address *ptr;

        ret = idmefv2_address_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2address();
        idmefv2_address_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2address::compare(IDMEFV2address *obj)
{
        return idmefv2_address_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_process_new:
 * @ret: Pointer where to store the created #idmefv2_process_t object.
 *
 * Create a new #idmefv2_process_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2process::IDMEFV2process()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2process::get_ident()
{
        return $tocast(idmefv2_process_get_ident(_priv));
} 
  


void IDMEFV2process::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_process_set_ident(this, ident);
}        




std::string * IDMEFV2process::get_name()
{
        return $tocast(idmefv2_process_get_name(_priv));
} 
  


void IDMEFV2process::set_name(libidmefv2_string_t *name)
{
        idmefv2_process_set_name(this, name);
}        




uint32_t * IDMEFV2process::get_pid()
{
        return $tocast(idmefv2_process_get_pid(_priv));
} 
  
void IDMEFV2process::set_pid(uint32_t pid)
{
        libidmefv2_return_if_fail(ptr);
        ptr->pid = pid;
        ptr->pid_is_set = 1;
}


void IDMEFV2process::unset_pid()
{
        idmefv2_process_unset_pid(_priv);
}




std::string * IDMEFV2process::get_path()
{
        return $tocast(idmefv2_process_get_path(_priv));
} 
  


void IDMEFV2process::set_path(libidmefv2_string_t *path)
{
        idmefv2_process_set_path(this, path);
}        



/**
 * idmefv2_process_get_next_arg:
 * @process: pointer to a #idmefv2_process_t object.
 * @string__cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *IDMEFV2process::get_next_arg(libidmefv2_string_t *string__cur)
{
        return idmefv2_process_get_next_arg(_priv, string__cur);
}


/**
 * idmefv2_process_set_arg:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #$field->{type_name} object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void IDMEFV2processset_arg(libidmefv2_string_t *object, int pos)
{
        idmefv2_process_set_arg(_priv, object, pos);
}


/**
 * idmefv2_process_new_arg:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * \@ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int IDMEFV2process::new_arg(libidmefv2_string_t **ret, int pos)
{
        return idmefv2_process_new_arg(_priv, ret, pos);
}



/**
 * idmefv2_process_get_next_env:
 * @process: pointer to a #idmefv2_process_t object.
 * @string__cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *IDMEFV2process::get_next_env(libidmefv2_string_t *string__cur)
{
        return idmefv2_process_get_next_env(_priv, string__cur);
}


/**
 * idmefv2_process_set_env:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #$field->{type_name} object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void IDMEFV2processset_env(libidmefv2_string_t *object, int pos)
{
        idmefv2_process_set_env(_priv, object, pos);
}


/**
 * idmefv2_process_new_env:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * \@ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int IDMEFV2process::new_env(libidmefv2_string_t **ret, int pos)
{
        return idmefv2_process_new_env(_priv, ret, pos);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_process_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2process::copy(IDMEFV2process *dst)
{
        return idmefv2_process_copy(_priv, dst->_priv);
}



/**
 * idmefv2_process_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2process *IDMEFV2process::clone()
{
        int ret;
        idmefv2_process_t *dst;
        IDMEFV2process *ptr;

        ret = idmefv2_process_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2process();
        idmefv2_process_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_process_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2process::compare(IDMEFV2process *obj)
{
        return idmefv2_process_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_user_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_user_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_user_category_t IDMEFV2user_category::user_category_to_numeric(const char *name)
{
        return idmefv2_user_category_to_numeric(name);
}

/**
 * idmefv2_user_category_to_string:
 * @val: an enumeration value for #idmefv2_user_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_user_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2user_category::to_string(idmefv2_user_category_t val)
{
        return idmefv2_user_category_to_string(val);
}

    

/**
 * idmefv2_user_new:
 * @ret: Pointer where to store the created #idmefv2_user_t object.
 *
 * Create a new #idmefv2_user_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user::IDMEFV2user()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2user::get_ident()
{
        return $tocast(idmefv2_user_get_ident(_priv));
} 
  


void IDMEFV2user::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_user_set_ident(this, ident);
}        




idmefv2_user_category_t  IDMEFV2user::get_category()
{
        return $tocast(idmefv2_user_get_category(_priv));
} 
  
void IDMEFV2user::set_category(idmefv2_user_category_t category)
{
        idmefv2_user_set_category(this, category);
}




idmefv2_user_id_t  IDMEFV2user::get_user_id()
{
        return $tocast(idmefv2_user_get_user_id(_priv));
} 
  
void IDMEFV2user::set_user_id(idmefv2_user_id_t user_id)
{
        idmefv2_user_set_user_id(this, user_id);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2user::copy(IDMEFV2user *dst)
{
        return idmefv2_user_copy(_priv, dst->_priv);
}



/**
 * idmefv2_user_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user *IDMEFV2user::clone()
{
        int ret;
        idmefv2_user_t *dst;
        IDMEFV2user *ptr;

        ret = idmefv2_user_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2user();
        idmefv2_user_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_user_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2user::compare(IDMEFV2user *obj)
{
        return idmefv2_user_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_user_id_type_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_user_id_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_user_id_type_t IDMEFV2user_id_type::user_id_type_to_numeric(const char *name)
{
        return idmefv2_user_id_type_to_numeric(name);
}

/**
 * idmefv2_user_id_type_to_string:
 * @val: an enumeration value for #idmefv2_user_id_type_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_user_id_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2user_id_type::to_string(idmefv2_user_id_type_t val)
{
        return idmefv2_user_id_type_to_string(val);
}

    

/**
 * idmefv2_user_id_new:
 * @ret: Pointer where to store the created #idmefv2_user_id_t object.
 *
 * Create a new #idmefv2_user_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user_id::IDMEFV2user_id()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2user_id::get_ident()
{
        return $tocast(idmefv2_user_id_get_ident(_priv));
} 
  


void IDMEFV2user_id::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_user_id_set_ident(this, ident);
}        




idmefv2_user_id_type_t  IDMEFV2user_id::get_type()
{
        return $tocast(idmefv2_user_id_get_type(_priv));
} 
  
void IDMEFV2user_id::set_type(idmefv2_user_id_type_t type)
{
        idmefv2_user_id_set_type(this, type);
}




std::string * IDMEFV2user_id::get_tty()
{
        return $tocast(idmefv2_user_id_get_tty(_priv));
} 
  


void IDMEFV2user_id::set_tty(libidmefv2_string_t *tty)
{
        idmefv2_user_id_set_tty(this, tty);
}        




std::string * IDMEFV2user_id::get_name()
{
        return $tocast(idmefv2_user_id_get_name(_priv));
} 
  


void IDMEFV2user_id::set_name(libidmefv2_string_t *name)
{
        idmefv2_user_id_set_name(this, name);
}        




uint32_t * IDMEFV2user_id::get_number()
{
        return $tocast(idmefv2_user_id_get_number(_priv));
} 
  
void IDMEFV2user_id::set_number(uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}


void IDMEFV2user_id::unset_number()
{
        idmefv2_user_id_unset_number(_priv);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2user_id::copy(IDMEFV2user_id *dst)
{
        return idmefv2_user_id_copy(_priv, dst->_priv);
}



/**
 * idmefv2_user_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2user_id *IDMEFV2user_id::clone()
{
        int ret;
        idmefv2_user_id_t *dst;
        IDMEFV2user_id *ptr;

        ret = idmefv2_user_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2user_id();
        idmefv2_user_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_user_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2user_id::compare(IDMEFV2user_id *obj)
{
        return idmefv2_user_id_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_service_new:
 * @ret: Pointer where to store the created #idmefv2_service_t object.
 *
 * Create a new #idmefv2_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2service::IDMEFV2service()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2service::get_ident()
{
        return $tocast(idmefv2_service_get_ident(_priv));
} 
  


void IDMEFV2service::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_service_set_ident(this, ident);
}        




uint32_t * IDMEFV2service::get_ip_version()
{
        return $tocast(idmefv2_service_get_ip_version(_priv));
} 
  
void IDMEFV2service::set_ip_version(uint32_t ip_version)
{
        libidmefv2_return_if_fail(ptr);
        ptr->ip_version = ip_version;
        ptr->ip_version_is_set = 1;
}


void IDMEFV2service::unset_ip_version()
{
        idmefv2_service_unset_ip_version(_priv);
}




uint8_t * IDMEFV2service::get_iana_protocol_number()
{
        return $tocast(idmefv2_service_get_iana_protocol_number(_priv));
} 
  
void IDMEFV2service::set_iana_protocol_number(uint8_t iana_protocol_number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->iana_protocol_number = iana_protocol_number;
        ptr->iana_protocol_number_is_set = 1;
}


void IDMEFV2service::unset_iana_protocol_number()
{
        idmefv2_service_unset_iana_protocol_number(_priv);
}




std::string * IDMEFV2service::get_iana_protocol_name()
{
        return $tocast(idmefv2_service_get_iana_protocol_name(_priv));
} 
  


void IDMEFV2service::set_iana_protocol_name(libidmefv2_string_t *iana_protocol_name)
{
        idmefv2_service_set_iana_protocol_name(this, iana_protocol_name);
}        




std::string * IDMEFV2service::get_name()
{
        return $tocast(idmefv2_service_get_name(_priv));
} 
  


void IDMEFV2service::set_name(libidmefv2_string_t *name)
{
        idmefv2_service_set_name(this, name);
}        




uint32_t * IDMEFV2service::get_port()
{
        return $tocast(idmefv2_service_get_port(_priv));
} 
  
void IDMEFV2service::set_port(uint32_t port)
{
        libidmefv2_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}


void IDMEFV2service::unset_port()
{
        idmefv2_service_unset_port(_priv);
}




idmefv2_portlist_t  IDMEFV2service::get_portlist()
{
        return $tocast(idmefv2_service_get_portlist(_priv));
} 
  
void IDMEFV2service::set_portlist(idmefv2_portlist_t portlist)
{
        idmefv2_service_set_portlist(this, portlist);
}




std::string * IDMEFV2service::get_protocol()
{
        return $tocast(idmefv2_service_get_protocol(_priv));
} 
  


void IDMEFV2service::set_protocol(libidmefv2_string_t *protocol)
{
        idmefv2_service_set_protocol(this, protocol);
}        


/**
 * idmefv2_service_get_type_:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Access the type_ children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_service_type__t children, or NULL if it is not set.
 */
idmefv2_service_type__t IDMEFV2service::get_type_()
{
        return idmefv2_service_get_type_(_priv);
}
/**
 * idmefv2_service_get_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Access the service children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_service_t children, or NULL if it is not set.
 */
idmefv2_service_t *IDMEFV2service::get_service()
{
        return idmefv2_service_get_service(_priv);
}
/**
 * idmefv2_service_set_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @service: pointer to a #idmefv2_service_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @service object.
 */
void IDMEFV2service::set_service(idmefv2_service_t *service)
{
        idmefv2_service_set_service(_priv, service);
}
/**
 * idmefv2_$struct->{short_type_name}_new_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer where to store the created #idmefv2_service_t object.
 *
 * Create a new idmefv2_service_t object, children of #idmefv2_service_t.
 * If @ptr already contain a #idmefv2_service_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2service::new_service()
{
        int ret;
        idmefv2_service_t *ptr;
        IDMEFV2service *obj;

        ret = idmefv2_service_new_service(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2service;
        idmefv2_service_destroy(obj->_priv);
        obj->_priv = ptr;
}
/**
 * idmefv2_service_get_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Access the service children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_service_t children, or NULL if it is not set.
 */
idmefv2_service_t *IDMEFV2service::get_service()
{
        return idmefv2_service_get_service(_priv);
}
/**
 * idmefv2_service_set_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @service: pointer to a #idmefv2_service_t object.
 *
 * Set @{$member.name} object as a children of \@ptr.
 * if @ptr already contain a @$member->{name} object, then it is destroyed,
 * and updated to point to the provided @service object.
 */
void IDMEFV2service::set_service(idmefv2_service_t *service)
{
        idmefv2_service_set_service(_priv, service);
}
/**
 * idmefv2_$struct->{short_type_name}_new_service:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer where to store the created #idmefv2_service_t object.
 *
 * Create a new idmefv2_service_t object, children of #idmefv2_service_t.
 * If @ptr already contain a #idmefv2_service_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
IDMEFV2$member->{short_type_name} *IDMEFV2service::new_service()
{
        int ret;
        idmefv2_service_t *ptr;
        IDMEFV2service *obj;

        ret = idmefv2_service_new_service(_priv, &ptr);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        obj = new IDMEFV2service;
        idmefv2_service_destroy(obj->_priv);
        obj->_priv = ptr;
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2service::copy(IDMEFV2service *dst)
{
        return idmefv2_service_copy(_priv, dst->_priv);
}



/**
 * idmefv2_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2service *IDMEFV2service::clone()
{
        int ret;
        idmefv2_service_t *dst;
        IDMEFV2service *ptr;

        ret = idmefv2_service_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2service();
        idmefv2_service_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2service::compare(IDMEFV2service *obj)
{
        return idmefv2_service_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_snmp_service_new:
 * @ret: Pointer where to store the created #idmefv2_snmp_service_t object.
 *
 * Create a new #idmefv2_snmp_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2snmp_service::IDMEFV2snmp_service()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2snmp_service::get_oid()
{
        return $tocast(idmefv2_snmp_service_get_oid(_priv));
} 
  


void IDMEFV2snmp_service::set_oid(libidmefv2_string_t *oid)
{
        idmefv2_snmp_service_set_oid(this, oid);
}        




uint32_t * IDMEFV2snmp_service::get_message__model()
{
        return $tocast(idmefv2_snmp_service_get_message__model(_priv));
} 
  
void IDMEFV2snmp_service::set_message__model(uint32_t message__model)
{
        libidmefv2_return_if_fail(ptr);
        ptr->message__model = message__model;
        ptr->message__model_is_set = 1;
}


void IDMEFV2snmp_service::unset_message__model()
{
        idmefv2_snmp_service_unset_message__model(_priv);
}




uint32_t * IDMEFV2snmp_service::get_security_model()
{
        return $tocast(idmefv2_snmp_service_get_security_model(_priv));
} 
  
void IDMEFV2snmp_service::set_security_model(uint32_t security_model)
{
        libidmefv2_return_if_fail(ptr);
        ptr->security_model = security_model;
        ptr->security_model_is_set = 1;
}


void IDMEFV2snmp_service::unset_security_model()
{
        idmefv2_snmp_service_unset_security_model(_priv);
}




std::string * IDMEFV2snmp_service::get_security_name()
{
        return $tocast(idmefv2_snmp_service_get_security_name(_priv));
} 
  


void IDMEFV2snmp_service::set_security_name(libidmefv2_string_t *security_name)
{
        idmefv2_snmp_service_set_security_name(this, security_name);
}        




uint32_t * IDMEFV2snmp_service::get_security_level()
{
        return $tocast(idmefv2_snmp_service_get_security_level(_priv));
} 
  
void IDMEFV2snmp_service::set_security_level(uint32_t security_level)
{
        libidmefv2_return_if_fail(ptr);
        ptr->security_level = security_level;
        ptr->security_level_is_set = 1;
}


void IDMEFV2snmp_service::unset_security_level()
{
        idmefv2_snmp_service_unset_security_level(_priv);
}




std::string * IDMEFV2snmp_service::get_context_name()
{
        return $tocast(idmefv2_snmp_service_get_context_name(_priv));
} 
  


void IDMEFV2snmp_service::set_context_name(libidmefv2_string_t *context_name)
{
        idmefv2_snmp_service_set_context_name(this, context_name);
}        




std::string * IDMEFV2snmp_service::get_context___d()
{
        return $tocast(idmefv2_snmp_service_get_context___d(_priv));
} 
  


void IDMEFV2snmp_service::set_context___d(libidmefv2_string_t *context___d)
{
        idmefv2_snmp_service_set_context___d(this, context___d);
}        




std::string * IDMEFV2snmp_service::get_command()
{
        return $tocast(idmefv2_snmp_service_get_command(_priv));
} 
  


void IDMEFV2snmp_service::set_command(libidmefv2_string_t *command)
{
        idmefv2_snmp_service_set_command(this, command);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_snmp_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2snmp_service::copy(IDMEFV2snmp_service *dst)
{
        return idmefv2_snmp_service_copy(_priv, dst->_priv);
}



/**
 * idmefv2_snmp_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2snmp_service *IDMEFV2snmp_service::clone()
{
        int ret;
        idmefv2_snmp_service_t *dst;
        IDMEFV2snmp_service *ptr;

        ret = idmefv2_snmp_service_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2snmp_service();
        idmefv2_snmp_service_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_snmp_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2snmp_service::compare(IDMEFV2snmp_service *obj)
{
        return idmefv2_snmp_service_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_web_service_new:
 * @ret: Pointer where to store the created #idmefv2_web_service_t object.
 *
 * Create a new #idmefv2_web_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2web_service::IDMEFV2web_service()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2web_service::get_url()
{
        return $tocast(idmefv2_web_service_get_url(_priv));
} 
  


void IDMEFV2web_service::set_url(libidmefv2_string_t *url)
{
        idmefv2_web_service_set_url(this, url);
}        




std::string * IDMEFV2web_service::get_cgi()
{
        return $tocast(idmefv2_web_service_get_cgi(_priv));
} 
  


void IDMEFV2web_service::set_cgi(libidmefv2_string_t *cgi)
{
        idmefv2_web_service_set_cgi(this, cgi);
}        




std::string * IDMEFV2web_service::get_http_method()
{
        return $tocast(idmefv2_web_service_get_http_method(_priv));
} 
  


void IDMEFV2web_service::set_http_method(libidmefv2_string_t *http_method)
{
        idmefv2_web_service_set_http_method(this, http_method);
}        



/**
 * idmefv2_web_service_get_next_arg:
 * @web_service: pointer to a #idmefv2_web_service_t object.
 * @string__cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *IDMEFV2web_service::get_next_arg(libidmefv2_string_t *string__cur)
{
        return idmefv2_web_service_get_next_arg(_priv, string__cur);
}


/**
 * idmefv2_web_service_set_arg:
 * @ptr: pointer to a #idmefv2_web_service_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #$field->{type_name} object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void IDMEFV2web_serviceset_arg(libidmefv2_string_t *object, int pos)
{
        idmefv2_web_service_set_arg(_priv, object, pos);
}


/**
 * idmefv2_web_service_new_arg:
 * @ptr: pointer to a #idmefv2_web_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * \@ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int IDMEFV2web_service::new_arg(libidmefv2_string_t **ret, int pos)
{
        return idmefv2_web_service_new_arg(_priv, ret, pos);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_web_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2web_service::copy(IDMEFV2web_service *dst)
{
        return idmefv2_web_service_copy(_priv, dst->_priv);
}



/**
 * idmefv2_web_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2web_service *IDMEFV2web_service::clone()
{
        int ret;
        idmefv2_web_service_t *dst;
        IDMEFV2web_service *ptr;

        ret = idmefv2_web_service_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2web_service();
        idmefv2_web_service_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_web_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2web_service::compare(IDMEFV2web_service *obj)
{
        return idmefv2_web_service_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_file_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_file_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_file_category_t IDMEFV2file_category::file_category_to_numeric(const char *name)
{
        return idmefv2_file_category_to_numeric(name);
}

/**
 * idmefv2_file_category_to_string:
 * @val: an enumeration value for #idmefv2_file_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_file_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2file_category::to_string(idmefv2_file_category_t val)
{
        return idmefv2_file_category_to_string(val);
}

    

/**
 * idmefv2_file_new:
 * @ret: Pointer where to store the created #idmefv2_file_t object.
 *
 * Create a new #idmefv2_file_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file::IDMEFV2file()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2file::get_name()
{
        return $tocast(idmefv2_file_get_name(_priv));
} 
  


void IDMEFV2file::set_name(libidmefv2_string_t *name)
{
        idmefv2_file_set_name(this, name);
}        




std::string * IDMEFV2file::get_path()
{
        return $tocast(idmefv2_file_get_path(_priv));
} 
  


void IDMEFV2file::set_path(libidmefv2_string_t *path)
{
        idmefv2_file_set_path(this, path);
}        




std::string * IDMEFV2file::get_ident()
{
        return $tocast(idmefv2_file_get_ident(_priv));
} 
  


void IDMEFV2file::set_ident(libidmefv2_string_t *ident)
{
        idmefv2_file_set_ident(this, ident);
}        




idmefv2_file_category_t  IDMEFV2file::get_category()
{
        return $tocast(idmefv2_file_get_category(_priv));
} 
  
void IDMEFV2file::set_category(idmefv2_file_category_t category)
{
        idmefv2_file_set_category(this, category);
}




std::string * IDMEFV2file::get_file_type()
{
        return $tocast(idmefv2_file_get_file_type(_priv));
} 
  


void IDMEFV2file::set_file_type(libidmefv2_string_t *file_type)
{
        idmefv2_file_set_file_type(this, file_type);
}        




idmefv2_create-time_t  IDMEFV2file::get_create_time()
{
        return $tocast(idmefv2_file_get_create_time(_priv));
} 
  
void IDMEFV2file::set_create_time(idmefv2_create-time_t create_time)
{
        idmefv2_file_set_create_time(this, create_time);
}




idmefv2_modify-time_t  IDMEFV2file::get_modify_time()
{
        return $tocast(idmefv2_file_get_modify_time(_priv));
} 
  
void IDMEFV2file::set_modify_time(idmefv2_modify-time_t modify_time)
{
        idmefv2_file_set_modify_time(this, modify_time);
}




idmefv2_access-time_t  IDMEFV2file::get_access_time()
{
        return $tocast(idmefv2_file_get_access_time(_priv));
} 
  
void IDMEFV2file::set_access_time(idmefv2_access-time_t access_time)
{
        idmefv2_file_set_access_time(this, access_time);
}




uint64_t * IDMEFV2file::get_data_size()
{
        return $tocast(idmefv2_file_get_data_size(_priv));
} 
  
void IDMEFV2file::set_data_size(uint64_t data_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->data_size = data_size;
        ptr->data_size_is_set = 1;
}


void IDMEFV2file::unset_data_size()
{
        idmefv2_file_unset_data_size(_priv);
}




uint64_t * IDMEFV2file::get_disk_size()
{
        return $tocast(idmefv2_file_get_disk_size(_priv));
} 
  
void IDMEFV2file::set_disk_size(uint64_t disk_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->disk_size = disk_size;
        ptr->disk_size_is_set = 1;
}


void IDMEFV2file::unset_disk_size()
{
        idmefv2_file_unset_disk_size(_priv);
}




idmefv2_inode_t  IDMEFV2file::get_inode()
{
        return $tocast(idmefv2_file_get_inode(_priv));
} 
  
void IDMEFV2file::set_inode(idmefv2_inode_t inode)
{
        idmefv2_file_set_inode(this, inode);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2file::copy(IDMEFV2file *dst)
{
        return idmefv2_file_copy(_priv, dst->_priv);
}



/**
 * idmefv2_file_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file *IDMEFV2file::clone()
{
        int ret;
        idmefv2_file_t *dst;
        IDMEFV2file *ptr;

        ret = idmefv2_file_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2file();
        idmefv2_file_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_file_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2file::compare(IDMEFV2file *obj)
{
        return idmefv2_file_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_checksum_algorithm_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_checksum_algorithm_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_checksum_algorithm_t IDMEFV2checksum_algorithm::checksum_algorithm_to_numeric(const char *name)
{
        return idmefv2_checksum_algorithm_to_numeric(name);
}

/**
 * idmefv2_checksum_algorithm_to_string:
 * @val: an enumeration value for #idmefv2_checksum_algorithm_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_checksum_algorithm_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2checksum_algorithm::to_string(idmefv2_checksum_algorithm_t val)
{
        return idmefv2_checksum_algorithm_to_string(val);
}

    

/**
 * idmefv2_checksum_new:
 * @ret: Pointer where to store the created #idmefv2_checksum_t object.
 *
 * Create a new #idmefv2_checksum_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2checksum::IDMEFV2checksum()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_checksum_algorithm_t  IDMEFV2checksum::get_algorithm()
{
        return $tocast(idmefv2_checksum_get_algorithm(_priv));
} 
  
void IDMEFV2checksum::set_algorithm(idmefv2_checksum_algorithm_t algorithm)
{
        idmefv2_checksum_set_algorithm(this, algorithm);
}




std::string * IDMEFV2checksum::get_value()
{
        return $tocast(idmefv2_checksum_get_value(_priv));
} 
  


void IDMEFV2checksum::set_value(libidmefv2_string_t *value)
{
        idmefv2_checksum_set_value(this, value);
}        




std::string * IDMEFV2checksum::get_key()
{
        return $tocast(idmefv2_checksum_get_key(_priv));
} 
  


void IDMEFV2checksum::set_key(libidmefv2_string_t *key)
{
        idmefv2_checksum_set_key(this, key);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_checksum_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2checksum::copy(IDMEFV2checksum *dst)
{
        return idmefv2_checksum_copy(_priv, dst->_priv);
}



/**
 * idmefv2_checksum_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2checksum *IDMEFV2checksum::clone()
{
        int ret;
        idmefv2_checksum_t *dst;
        IDMEFV2checksum *ptr;

        ret = idmefv2_checksum_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2checksum();
        idmefv2_checksum_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_checksum_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2checksum::compare(IDMEFV2checksum *obj)
{
        return idmefv2_checksum_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_file_access_permission_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_file_access_permission_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_file_access_permission_t IDMEFV2file_access_permission::file_access_permission_to_numeric(const char *name)
{
        return idmefv2_file_access_permission_to_numeric(name);
}

/**
 * idmefv2_file_access_permission_to_string:
 * @val: an enumeration value for #idmefv2_file_access_permission_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_file_access_permission_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2file_access_permission::to_string(idmefv2_file_access_permission_t val)
{
        return idmefv2_file_access_permission_to_string(val);
}

    

/**
 * idmefv2_file_access_new:
 * @ret: Pointer where to store the created #idmefv2_file_access_t object.
 *
 * Create a new #idmefv2_file_access_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file_access::IDMEFV2file_access()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_file_access_permission_t  IDMEFV2file_access::get_permission()
{
        return $tocast(idmefv2_file_access_get_permission(_priv));
} 
  
void IDMEFV2file_access::set_permission(idmefv2_file_access_permission_t permission)
{
        idmefv2_file_access_set_permission(this, permission);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_access_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2file_access::copy(IDMEFV2file_access *dst)
{
        return idmefv2_file_access_copy(_priv, dst->_priv);
}



/**
 * idmefv2_file_access_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2file_access *IDMEFV2file_access::clone()
{
        int ret;
        idmefv2_file_access_t *dst;
        IDMEFV2file_access *ptr;

        ret = idmefv2_file_access_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2file_access();
        idmefv2_file_access_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_file_access_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2file_access::compare(IDMEFV2file_access *obj)
{
        return idmefv2_file_access_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_correlation_alert_new:
 * @ret: Pointer where to store the created #idmefv2_correlation_alert_t object.
 *
 * Create a new #idmefv2_correlation_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2correlation_alert::IDMEFV2correlation_alert()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2correlation_alert::get_name()
{
        return $tocast(idmefv2_correlation_alert_get_name(_priv));
} 
  


void IDMEFV2correlation_alert::set_name(libidmefv2_string_t *name)
{
        idmefv2_correlation_alert_set_name(this, name);
}        




std::string * IDMEFV2correlation_alert::get_alertident()
{
        return $tocast(idmefv2_correlation_alert_get_alertident(_priv));
} 
  


void IDMEFV2correlation_alert::set_alertident(libidmefv2_string_t *alertident)
{
        idmefv2_correlation_alert_set_alertident(this, alertident);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_correlation_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2correlation_alert::copy(IDMEFV2correlation_alert *dst)
{
        return idmefv2_correlation_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_correlation_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2correlation_alert *IDMEFV2correlation_alert::clone()
{
        int ret;
        idmefv2_correlation_alert_t *dst;
        IDMEFV2correlation_alert *ptr;

        ret = idmefv2_correlation_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2correlation_alert();
        idmefv2_correlation_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_correlation_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2correlation_alert::compare(IDMEFV2correlation_alert *obj)
{
        return idmefv2_correlation_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_inode_new:
 * @ret: Pointer where to store the created #idmefv2_inode_t object.
 *
 * Create a new #idmefv2_inode_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2inode::IDMEFV2inode()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_change-time_t  IDMEFV2inode::get_change_time()
{
        return $tocast(idmefv2_inode_get_change_time(_priv));
} 
  
void IDMEFV2inode::set_change_time(idmefv2_change-time_t change_time)
{
        idmefv2_inode_set_change_time(this, change_time);
}




uint32_t * IDMEFV2inode::get_number()
{
        return $tocast(idmefv2_inode_get_number(_priv));
} 
  
void IDMEFV2inode::set_number(uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}


void IDMEFV2inode::unset_number()
{
        idmefv2_inode_unset_number(_priv);
}




uint32_t * IDMEFV2inode::get_major_device()
{
        return $tocast(idmefv2_inode_get_major_device(_priv));
} 
  
void IDMEFV2inode::set_major_device(uint32_t major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->major_device = major_device;
        ptr->major_device_is_set = 1;
}


void IDMEFV2inode::unset_major_device()
{
        idmefv2_inode_unset_major_device(_priv);
}




uint32_t * IDMEFV2inode::get_minor_device()
{
        return $tocast(idmefv2_inode_get_minor_device(_priv));
} 
  
void IDMEFV2inode::set_minor_device(uint32_t minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->minor_device = minor_device;
        ptr->minor_device_is_set = 1;
}


void IDMEFV2inode::unset_minor_device()
{
        idmefv2_inode_unset_minor_device(_priv);
}




uint32_t * IDMEFV2inode::get_c_major_device()
{
        return $tocast(idmefv2_inode_get_c_major_device(_priv));
} 
  
void IDMEFV2inode::set_c_major_device(uint32_t c_major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_major_device = c_major_device;
        ptr->c_major_device_is_set = 1;
}


void IDMEFV2inode::unset_c_major_device()
{
        idmefv2_inode_unset_c_major_device(_priv);
}




uint32_t * IDMEFV2inode::get_c_minor_device()
{
        return $tocast(idmefv2_inode_get_c_minor_device(_priv));
} 
  
void IDMEFV2inode::set_c_minor_device(uint32_t c_minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_minor_device = c_minor_device;
        ptr->c_minor_device_is_set = 1;
}


void IDMEFV2inode::unset_c_minor_device()
{
        idmefv2_inode_unset_c_minor_device(_priv);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_inode_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2inode::copy(IDMEFV2inode *dst)
{
        return idmefv2_inode_copy(_priv, dst->_priv);
}



/**
 * idmefv2_inode_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2inode *IDMEFV2inode::clone()
{
        int ret;
        idmefv2_inode_t *dst;
        IDMEFV2inode *ptr;

        ret = idmefv2_inode_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2inode();
        idmefv2_inode_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_inode_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2inode::compare(IDMEFV2inode *obj)
{
        return idmefv2_inode_compare(_priv, obj->_priv);
}


    
/*****
 * idmefv2_linkage_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_linkage_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_linkage_category_t IDMEFV2linkage_category::linkage_category_to_numeric(const char *name)
{
        return idmefv2_linkage_category_to_numeric(name);
}

/**
 * idmefv2_linkage_category_to_string:
 * @val: an enumeration value for #idmefv2_linkage_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_linkage_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *IDMEFV2linkage_category::to_string(idmefv2_linkage_category_t val)
{
        return idmefv2_linkage_category_to_string(val);
}

    

/**
 * idmefv2_linkage_new:
 * @ret: Pointer where to store the created #idmefv2_linkage_t object.
 *
 * Create a new #idmefv2_linkage_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage::IDMEFV2linkage()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







idmefv2_linkage_category_t  IDMEFV2linkage::get_category()
{
        return $tocast(idmefv2_linkage_get_category(_priv));
} 
  
void IDMEFV2linkage::set_category(idmefv2_linkage_category_t category)
{
        idmefv2_linkage_set_category(this, category);
}




std::string * IDMEFV2linkage::get_name()
{
        return $tocast(idmefv2_linkage_get_name(_priv));
} 
  


void IDMEFV2linkage::set_name(libidmefv2_string_t *name)
{
        idmefv2_linkage_set_name(this, name);
}        




std::string * IDMEFV2linkage::get_path()
{
        return $tocast(idmefv2_linkage_get_path(_priv));
} 
  


void IDMEFV2linkage::set_path(libidmefv2_string_t *path)
{
        idmefv2_linkage_set_path(this, path);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_linkage_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2linkage::copy(IDMEFV2linkage *dst)
{
        return idmefv2_linkage_copy(_priv, dst->_priv);
}



/**
 * idmefv2_linkage_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2linkage *IDMEFV2linkage::clone()
{
        int ret;
        idmefv2_linkage_t *dst;
        IDMEFV2linkage *ptr;

        ret = idmefv2_linkage_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2linkage();
        idmefv2_linkage_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_linkage_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2linkage::compare(IDMEFV2linkage *obj)
{
        return idmefv2_linkage_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_overflow_alert_new:
 * @ret: Pointer where to store the created #idmefv2_overflow_alert_t object.
 *
 * Create a new #idmefv2_overflow_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2overflow_alert::IDMEFV2overflow_alert()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2overflow_alert::get_program()
{
        return $tocast(idmefv2_overflow_alert_get_program(_priv));
} 
  


void IDMEFV2overflow_alert::set_program(libidmefv2_string_t *program)
{
        idmefv2_overflow_alert_set_program(this, program);
}        




uint32_t * IDMEFV2overflow_alert::get_size()
{
        return $tocast(idmefv2_overflow_alert_get_size(_priv));
} 
  
void IDMEFV2overflow_alert::set_size(uint32_t size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->size = size;
        ptr->size_is_set = 1;
}


void IDMEFV2overflow_alert::unset_size()
{
        idmefv2_overflow_alert_unset_size(_priv);
}




idmefv2_data_t * IDMEFV2overflow_alert::get_buffer()
{
        return $tocast(idmefv2_overflow_alert_get_buffer(_priv));
} 
  


void IDMEFV2overflow_alert::set_buffer(idmefv2_data_t *buffer)
{
        idmefv2_overflow_alert_set_buffer(this, buffer);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_overflow_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2overflow_alert::copy(IDMEFV2overflow_alert *dst)
{
        return idmefv2_overflow_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_overflow_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2overflow_alert *IDMEFV2overflow_alert::clone()
{
        int ret;
        idmefv2_overflow_alert_t *dst;
        IDMEFV2overflow_alert *ptr;

        ret = idmefv2_overflow_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2overflow_alert();
        idmefv2_overflow_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_overflow_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2overflow_alert::compare(IDMEFV2overflow_alert *obj)
{
        return idmefv2_overflow_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_tool_alert_new:
 * @ret: Pointer where to store the created #idmefv2_tool_alert_t object.
 *
 * Create a new #idmefv2_tool_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2tool_alert::IDMEFV2tool_alert()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2tool_alert::get_name()
{
        return $tocast(idmefv2_tool_alert_get_name(_priv));
} 
  


void IDMEFV2tool_alert::set_name(libidmefv2_string_t *name)
{
        idmefv2_tool_alert_set_name(this, name);
}        




std::string * IDMEFV2tool_alert::get_command()
{
        return $tocast(idmefv2_tool_alert_get_command(_priv));
} 
  


void IDMEFV2tool_alert::set_command(libidmefv2_string_t *command)
{
        idmefv2_tool_alert_set_command(this, command);
}        




std::string * IDMEFV2tool_alert::get_alertident()
{
        return $tocast(idmefv2_tool_alert_get_alertident(_priv));
} 
  


void IDMEFV2tool_alert::set_alertident(libidmefv2_string_t *alertident)
{
        idmefv2_tool_alert_set_alertident(this, alertident);
}        



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_tool_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2tool_alert::copy(IDMEFV2tool_alert *dst)
{
        return idmefv2_tool_alert_copy(_priv, dst->_priv);
}



/**
 * idmefv2_tool_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2tool_alert *IDMEFV2tool_alert::clone()
{
        int ret;
        idmefv2_tool_alert_t *dst;
        IDMEFV2tool_alert *ptr;

        ret = idmefv2_tool_alert_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2tool_alert();
        idmefv2_tool_alert_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_tool_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2tool_alert::compare(IDMEFV2tool_alert *obj)
{
        return idmefv2_tool_alert_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_analyzer_time_new:
 * @ret: Pointer where to store the created #idmefv2_analyzer_time_t object.
 *
 * Create a new #idmefv2_analyzer_time_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer_time::IDMEFV2analyzer_time()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}






/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analyzer_time_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2analyzer_time::copy(IDMEFV2analyzer_time *dst)
{
        return idmefv2_analyzer_time_copy(_priv, dst->_priv);
}



/**
 * idmefv2_analyzer_time_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer_time *IDMEFV2analyzer_time::clone()
{
        int ret;
        idmefv2_analyzer_time_t *dst;
        IDMEFV2analyzer_time *ptr;

        ret = idmefv2_analyzer_time_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2analyzer_time();
        idmefv2_analyzer_time_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_analyzer_time_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2analyzer_time::compare(IDMEFV2analyzer_time *obj)
{
        return idmefv2_analyzer_time_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_create_time_new:
 * @ret: Pointer where to store the created #idmefv2_create_time_t object.
 *
 * Create a new #idmefv2_create_time_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2create_time::IDMEFV2create_time()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}






/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_create_time_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2create_time::copy(IDMEFV2create_time *dst)
{
        return idmefv2_create_time_copy(_priv, dst->_priv);
}



/**
 * idmefv2_create_time_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2create_time *IDMEFV2create_time::clone()
{
        int ret;
        idmefv2_create_time_t *dst;
        IDMEFV2create_time *ptr;

        ret = idmefv2_create_time_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2create_time();
        idmefv2_create_time_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_create_time_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2create_time::compare(IDMEFV2create_time *obj)
{
        return idmefv2_create_time_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_detect_time_new:
 * @ret: Pointer where to store the created #idmefv2_detect_time_t object.
 *
 * Create a new #idmefv2_detect_time_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2detect_time::IDMEFV2detect_time()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}






/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_detect_time_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2detect_time::copy(IDMEFV2detect_time *dst)
{
        return idmefv2_detect_time_copy(_priv, dst->_priv);
}



/**
 * idmefv2_detect_time_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2detect_time *IDMEFV2detect_time::clone()
{
        int ret;
        idmefv2_detect_time_t *dst;
        IDMEFV2detect_time *ptr;

        ret = idmefv2_detect_time_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2detect_time();
        idmefv2_detect_time_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_detect_time_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2detect_time::compare(IDMEFV2detect_time *obj)
{
        return idmefv2_detect_time_compare(_priv, obj->_priv);
}


    

/**
 * idmefv2_analyzer_new:
 * @ret: Pointer where to store the created #idmefv2_analyzer_t object.
 *
 * Create a new #idmefv2_analyzer_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer::IDMEFV2analyzer()
{
        idmefv2_$struct->{short_type_name}_new(&_priv);
}







std::string * IDMEFV2analyzer::get_osversion()
{
        return $tocast(idmefv2_analyzer_get_osversion(_priv));
} 
  


void IDMEFV2analyzer::set_osversion(libidmefv2_string_t *osversion)
{
        idmefv2_analyzer_set_osversion(this, osversion);
}        




std::string * IDMEFV2analyzer::get_analyzerid()
{
        return $tocast(idmefv2_analyzer_get_analyzerid(_priv));
} 
  


void IDMEFV2analyzer::set_analyzerid(libidmefv2_string_t *analyzerid)
{
        idmefv2_analyzer_set_analyzerid(this, analyzerid);
}        




std::string * IDMEFV2analyzer::get_name()
{
        return $tocast(idmefv2_analyzer_get_name(_priv));
} 
  


void IDMEFV2analyzer::set_name(libidmefv2_string_t *name)
{
        idmefv2_analyzer_set_name(this, name);
}        




std::string * IDMEFV2analyzer::get_manufacturer()
{
        return $tocast(idmefv2_analyzer_get_manufacturer(_priv));
} 
  


void IDMEFV2analyzer::set_manufacturer(libidmefv2_string_t *manufacturer)
{
        idmefv2_analyzer_set_manufacturer(this, manufacturer);
}        




std::string * IDMEFV2analyzer::get_model()
{
        return $tocast(idmefv2_analyzer_get_model(_priv));
} 
  


void IDMEFV2analyzer::set_model(libidmefv2_string_t *model)
{
        idmefv2_analyzer_set_model(this, model);
}        




std::string * IDMEFV2analyzer::get_version()
{
        return $tocast(idmefv2_analyzer_get_version(_priv));
} 
  


void IDMEFV2analyzer::set_version(libidmefv2_string_t *version)
{
        idmefv2_analyzer_set_version(this, version);
}        




std::string * IDMEFV2analyzer::get_class()
{
        return $tocast(idmefv2_analyzer_get_class(_priv));
} 
  


void IDMEFV2analyzer::set_class_str(libidmefv2_string_t *class_str)
{
        idmefv2_analyzer_set_class(this, class_str);
}        




std::string * IDMEFV2analyzer::get_ostype()
{
        return $tocast(idmefv2_analyzer_get_ostype(_priv));
} 
  


void IDMEFV2analyzer::set_ostype(libidmefv2_string_t *ostype)
{
        idmefv2_analyzer_set_ostype(this, ostype);
}        




idmefv2_node_t  IDMEFV2analyzer::get_node()
{
        return $tocast(idmefv2_analyzer_get_node(_priv));
} 
  
void IDMEFV2analyzer::set_node(idmefv2_node_t node)
{
        idmefv2_analyzer_set_node(this, node);
}




idmefv2_process_t  IDMEFV2analyzer::get_process()
{
        return $tocast(idmefv2_analyzer_get_process(_priv));
} 
  
void IDMEFV2analyzer::set_process(idmefv2_process_t process)
{
        idmefv2_analyzer_set_process(this, process);
}




idmefv2_analyzer_t  IDMEFV2analyzer::get_analyzer()
{
        return $tocast(idmefv2_analyzer_get_analyzer(_priv));
} 
  
void IDMEFV2analyzer::set_analyzer(idmefv2_analyzer_t analyzer)
{
        idmefv2_analyzer_set_analyzer(this, analyzer);
}



/**
 * idmefv2_$struct->{short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analyzer_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IDMEFV2analyzer::copy(IDMEFV2analyzer *dst)
{
        return idmefv2_analyzer_copy(_priv, dst->_priv);
}



/**
 * idmefv2_analyzer_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IDMEFV2analyzer *IDMEFV2analyzer::clone()
{
        int ret;
        idmefv2_analyzer_t *dst;
        IDMEFV2analyzer *ptr;

        ret = idmefv2_analyzer_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IDMEFV2analyzer();
        idmefv2_analyzer_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * idmefv2_analyzer_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IDMEFV2analyzer::compare(IDMEFV2analyzer *obj)
{
        return idmefv2_analyzer_compare(_priv, obj->_priv);
}



void IDMEFV2Message::set_pmsg(libidmefv2_msg_t *msg)
{
        idmefv2_message_set_pmsg(_priv, msg);
}


libidmefv2_msg_t *IDMEFV2Message::get_pmsg()
{
        return idmefv2_message_get_pmsg(_priv);
}


/**
 * idmefv2_message_destroy:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void IDMEFV2Message::~IDMEFV2Message()
{
        idmefv2_message_destroy(_priv);
}




