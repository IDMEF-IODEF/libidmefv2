
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the Libidmefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IDMEFV2 version : Not released yet
 * Template file: generate-top-level-class-write.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "libidmefv2-inttypes.h"
#include "libidmefv2-list.h"
#include "libidmefv2-log.h"
#include "libidmefv2-io.h"
#include "libidmefv2-ident.h"
#include "libidmefv2-message-id.h"
#include "idmefv2-message-id.h"
#include "idmefv2.h"
#include "idmefv2-tree-wrap.h"
#include "idmefv2-message-write.h"
#include "common.h"



/*
 * If you wonder why we do this, and why life is complicated,
 * then wonder why the hell the guys that wrote IDMEFV2 choose to use XML.
 * XML is dog slow. And XML'll never achieve performance needed for real time IDS.
 *
 * Here we are trying to communicate using a home made, binary version of IDMEFV2.
 */
int binary_write(libidmefv2_io_t*, uint8_t, uint32_t, const void*);
int binary_write(libidmefv2_io_t *fd, uint8_t tag, uint32_t len, const void *data)
{
        uint32_t l;

        l = htonl(len);

        libidmefv2_io_write(fd, &tag, sizeof(tag));
        libidmefv2_io_write(fd, &l, sizeof(l));

        if ( len > 0 )
                libidmefv2_io_write(fd, data, len);

        return 1;
}



static inline int libidmefv2_string_write(libidmefv2_string_t *string, libidmefv2_io_t *fd, uint8_t tag)
{
        if ( ! string || libidmefv2_string_is_empty(string) )
                return 0;

        return binary_write(fd, tag, libidmefv2_string_get_len(string) + 1, libidmefv2_string_get_string(string));
}



static inline int uint64_write(uint64_t data, libidmefv2_io_t *fd, uint8_t tag)
{
        uint64_t dst;

        dst = libidmefv2_hton64(data);

        return binary_write(fd, tag, sizeof(dst), &dst);
}



static inline int uint32_write(uint32_t data, libidmefv2_io_t *fd, uint8_t tag)
{
        data = htonl(data);
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int int32_write(uint32_t data, libidmefv2_io_t *fd, uint8_t tag)
{
        return uint32_write(data, fd, tag);
}



static inline int uint8_write(uint8_t data, libidmefv2_io_t *fd, uint8_t tag)
{
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int uint16_write(uint16_t data, libidmefv2_io_t *fd, uint8_t tag)
{
        data = htons(data);
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int float_write(float data, libidmefv2_io_t *fd, uint8_t tag)
{
        uint32_t tmp = libidmefv2_htonf(data);
        return binary_write(fd, tag, sizeof(tmp), &tmp);
}


static inline int idmefv2_time_write(const idmefv2_time_t *data, libidmefv2_io_t *fd, uint8_t tag)
{
        uint32_t tmp;
        unsigned char buf[12];

        if ( ! data )
                return 0;

        tmp = htonl(idmefv2_time_get_sec(data));
        memcpy(buf, &tmp, sizeof(tmp));

        tmp = htonl(idmefv2_time_get_usec(data));
        memcpy(buf + 4, &tmp, sizeof(tmp));

        tmp = htonl(idmefv2_time_get_gmt_offset(data));
        memcpy(buf + 8, &tmp, sizeof(tmp));

        return binary_write(fd, tag, sizeof (buf), buf);
}



static inline int idmefv2_data_write(idmefv2_data_t *data, libidmefv2_io_t *fd, uint8_t tag)
{
        int ret;
        idmefv2_data_type_t type;

        if ( ! data )
                return 0;

        type = idmefv2_data_get_type(data);
        if ( type == IDMEFV2_DATA_TYPE_UNKNOWN )
                return 0;

        ret = uint32_write(idmefv2_data_get_type(data), fd, tag);
        if ( ret < 0 )
                return ret;

        switch ( type ) {
        case IDMEFV2_DATA_TYPE_CHAR:
        case IDMEFV2_DATA_TYPE_BYTE:
                ret = uint8_write(* (const uint8_t *) idmefv2_data_get_data(data), fd, tag);
                break;

        case IDMEFV2_DATA_TYPE_UINT32:
                ret = uint32_write(idmefv2_data_get_int(data), fd, tag);
                break;

        case IDMEFV2_DATA_TYPE_INT:
                ret = uint64_write(idmefv2_data_get_int(data), fd, tag);
                break;

        case IDMEFV2_DATA_TYPE_FLOAT:
                ret = float_write(idmefv2_data_get_float(data), fd, tag);
                break;

        case IDMEFV2_DATA_TYPE_CHAR_STRING:
        case IDMEFV2_DATA_TYPE_BYTE_STRING:
                ret = binary_write(fd, tag, idmefv2_data_get_len(data), idmefv2_data_get_data(data));
                break;

        case IDMEFV2_DATA_TYPE_TIME:
                ret = idmefv2_time_write(idmefv2_data_get_data(data), fd, tag);
                break;

        case IDMEFV2_DATA_TYPE_UNKNOWN:
                /* nop */;
        }

        return ret;
}


/**
 * idmefv2_address_write:
 * @address: Pointer to a #idmefv2_address_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @address within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_address_write(idmefv2_address_t *address, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! address )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ADDRESS_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_address_get_ident(address), fd, IDMEFV2_MSG_ADDRESS_IDENT);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_address_get_translation(address), fd, IDMEFV2_MSG_ADDRESS_TRANSLATION);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_address_get_category(address), fd, IDMEFV2_MSG_ADDRESS_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_address_get_vlan_name(address), fd, IDMEFV2_MSG_ADDRESS_VLAN_NAME);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_address_get_vlan_num(address);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_ADDRESS_VLAN_NUM);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = libidmefv2_string_write(idmefv2_address_get_address(address), fd, IDMEFV2_MSG_ADDRESS_ADDRESS);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_address_get_netmask(address), fd, IDMEFV2_MSG_ADDRESS_NETMASK);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_user_id_write:
 * @user_id: Pointer to a #idmefv2_user_id_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @user_id within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_id_write(idmefv2_user_id_t *user_id, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! user_id )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_USER_ID_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_user_id_get_ident(user_id), fd, IDMEFV2_MSG_USER_ID_IDENT);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_user_id_get_category(user_id), fd, IDMEFV2_MSG_USER_ID_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_user_id_get_tty(user_id), fd, IDMEFV2_MSG_USER_ID_TTY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_user_id_get_name(user_id), fd, IDMEFV2_MSG_USER_ID_NAME);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_user_id_get_number(user_id);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_USER_ID_NUMBER);
                        if ( ret < 0 )
                                return ret;
                }
        }

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_node_name_write:
 * @node_name: Pointer to a #idmefv2_node_name_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @node_name within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_name_write(idmefv2_node_name_t *node_name, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! node_name )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_NODE_NAME_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_node_name_get_category(node_name), fd, IDMEFV2_MSG_NODE_NAME_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_node_name_get_name(node_name), fd, IDMEFV2_MSG_NODE_NAME_NAME);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_location_write:
 * @location: Pointer to a #idmefv2_location_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @location within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_location_write(idmefv2_location_t *location, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! location )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_LOCATION_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_location_get_name(location), fd, IDMEFV2_MSG_LOCATION_NAME);
        if ( ret < 0 )
                return ret;


        {
                float *tmp;

                tmp = idmefv2_location_get_latitude(location);
                if ( tmp ) {
                        ret = float_write(*tmp, fd, IDMEFV2_MSG_LOCATION_LATITUDE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                float *tmp;

                tmp = idmefv2_location_get_longitude(location);
                if ( tmp ) {
                        ret = float_write(*tmp, fd, IDMEFV2_MSG_LOCATION_LONGITUDE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                float *tmp;

                tmp = idmefv2_location_get_altitude(location);
                if ( tmp ) {
                        ret = float_write(*tmp, fd, IDMEFV2_MSG_LOCATION_ALTITUDE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = libidmefv2_string_write(idmefv2_location_get_country(location), fd, IDMEFV2_MSG_LOCATION_COUNTRY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_location_get_city(location), fd, IDMEFV2_MSG_LOCATION_CITY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_location_get_postcode(location), fd, IDMEFV2_MSG_LOCATION_POSTCODE);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_interface_write:
 * @interface: Pointer to a #idmefv2_interface_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @interface within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_interface_write(idmefv2_interface_t *interface, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! interface )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_INTERFACE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_interface_get_name(interface), fd, IDMEFV2_MSG_INTERFACE_NAME);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_interface_get_category(interface), fd, IDMEFV2_MSG_INTERFACE_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_interface_get_meaning(interface), fd, IDMEFV2_MSG_INTERFACE_MEANING);
        if ( ret < 0 )
                return ret;

        {
                idmefv2_address_t *address = NULL;


                while ( (address = idmefv2_interface_get_next_address(interface, address)) ) {
                        ret = idmefv2_address_write(address, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_file_access_write:
 * @file_access: Pointer to a #idmefv2_file_access_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @file_access within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_access_write(idmefv2_file_access_t *file_access, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! file_access )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_FILE_ACCESS_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;
         ret = idmefv2_user_id_write(idmefv2_file_access_get_user_id(file_access), fd);
         if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_file_access_get_permission(file_access), fd, IDMEFV2_MSG_FILE_ACCESS_PERMISSION);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_inode_write:
 * @inode: Pointer to a #idmefv2_inode_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @inode within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_inode_write(idmefv2_inode_t *inode, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! inode )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_INODE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        {
                uint32_t *tmp;

                tmp = idmefv2_inode_get_number(inode);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_INODE_NUMBER);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint32_t *tmp;

                tmp = idmefv2_inode_get_major_device(inode);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_INODE_MAJOR_DEVICE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint32_t *tmp;

                tmp = idmefv2_inode_get_minor_device(inode);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_INODE_MINOR_DEVICE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint32_t *tmp;

                tmp = idmefv2_inode_get_c_major_device(inode);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_INODE_C_MAJOR_DEVICE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint32_t *tmp;

                tmp = idmefv2_inode_get_c_minor_device(inode);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_INODE_C_MINOR_DEVICE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = idmefv2_time_write(idmefv2_inode_get_change_time(inode), fd, IDMEFV2_MSG_INODE_CHANGE_TIME);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_checksum_write:
 * @checksum: Pointer to a #idmefv2_checksum_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @checksum within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_checksum_write(idmefv2_checksum_t *checksum, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! checksum )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_CHECKSUM_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_checksum_get_value(checksum), fd, IDMEFV2_MSG_CHECKSUM_VALUE);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_checksum_get_key(checksum), fd, IDMEFV2_MSG_CHECKSUM_KEY);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_checksum_get_algorithm(checksum), fd, IDMEFV2_MSG_CHECKSUM_ALGORITHM);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

int idmefv2_linkage_write(idmefv2_linkage_t *, libidmefv2_io_t *);

int idmefv2_container_write(idmefv2_container_t *, libidmefv2_io_t *);


/**
 * idmefv2_stream_write:
 * @stream: Pointer to a #idmefv2_stream_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @stream within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_stream_write(idmefv2_stream_t *stream, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! stream )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_STREAM_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_stream_get_offsetunit(stream), fd, IDMEFV2_MSG_STREAM_OFFSETUNIT);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_stream_get_offset(stream);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_STREAM_OFFSET);
                        if ( ret < 0 )
                                return ret;
                }
        }

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_file_write:
 * @file: Pointer to a #idmefv2_file_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @file within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_write(idmefv2_file_t *file, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! file )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_FILE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_file_get_ident(file), fd, IDMEFV2_MSG_FILE_IDENT);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_file_get_name(file), fd, IDMEFV2_MSG_FILE_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_file_get_path(file), fd, IDMEFV2_MSG_FILE_PATH);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_file_get_create_time(file), fd, IDMEFV2_MSG_FILE_CREATE_TIME);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_file_get_modify_time(file), fd, IDMEFV2_MSG_FILE_MODIFY_TIME);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_file_get_access_time(file), fd, IDMEFV2_MSG_FILE_ACCESS_TIME);
        if ( ret < 0 )
                return ret;


        {
                uint64_t *tmp;

                tmp = idmefv2_file_get_data_size(file);
                if ( tmp ) {
                        ret = uint64_write(*tmp, fd, IDMEFV2_MSG_FILE_DATA_SIZE);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint64_t *tmp;

                tmp = idmefv2_file_get_disk_size(file);
                if ( tmp ) {
                        ret = uint64_write(*tmp, fd, IDMEFV2_MSG_FILE_DISK_SIZE);
                        if ( ret < 0 )
                                return ret;
                }
        }

        {
                idmefv2_file_access_t *file_access = NULL;


                while ( (file_access = idmefv2_file_get_next_file_access(file, file_access)) ) {
                        ret = idmefv2_file_access_write(file_access, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        {
                idmefv2_linkage_t *linkage = NULL;


                while ( (linkage = idmefv2_file_get_next_linkage(file, linkage)) ) {
                        ret = idmefv2_linkage_write(linkage, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
         ret = idmefv2_inode_write(idmefv2_file_get_inode(file), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_checksum_t *checksum = NULL;


                while ( (checksum = idmefv2_file_get_next_checksum(file, checksum)) ) {
                        ret = idmefv2_checksum_write(checksum, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }

        ret = uint32_write(idmefv2_file_get_category(file), fd, IDMEFV2_MSG_FILE_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_file_get_file_type(file), fd, IDMEFV2_MSG_FILE_FILE_TYPE);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_container_write(idmefv2_file_get_container(file), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_stream_write(idmefv2_file_get_stream(file), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_linkage_write:
 * @linkage: Pointer to a #idmefv2_linkage_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @linkage within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_linkage_write(idmefv2_linkage_t *linkage, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! linkage )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_LINKAGE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_linkage_get_category(linkage), fd, IDMEFV2_MSG_LINKAGE_CATEGORY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_linkage_get_name(linkage), fd, IDMEFV2_MSG_LINKAGE_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_linkage_get_path(linkage), fd, IDMEFV2_MSG_LINKAGE_PATH);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_file_write(idmefv2_linkage_get_file(linkage), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_container_write:
 * @container: Pointer to a #idmefv2_container_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @container within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_container_write(idmefv2_container_t *container, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! container )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_CONTAINER_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_container_get_name(container), fd, IDMEFV2_MSG_CONTAINER_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_container_get_path(container), fd, IDMEFV2_MSG_CONTAINER_PATH);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_file_write(idmefv2_container_get_file(container), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_process_write:
 * @process: Pointer to a #idmefv2_process_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @process within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_process_write(idmefv2_process_t *process, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! process )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_PROCESS_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_process_get_ident(process), fd, IDMEFV2_MSG_PROCESS_IDENT);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_process_get_name(process), fd, IDMEFV2_MSG_PROCESS_NAME);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_process_get_pid(process);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_PROCESS_PID);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = libidmefv2_string_write(idmefv2_process_get_path(process), fd, IDMEFV2_MSG_PROCESS_PATH);
        if ( ret < 0 )
                return ret;

        {
                libidmefv2_string_t *arg = NULL;


                while ( (arg = idmefv2_process_get_next_arg(process, arg)) ) {
                        ret = libidmefv2_string_write(arg, fd, IDMEFV2_MSG_PROCESS_ARG );
                        if ( ret < 0 )
                                return ret;
            }
        }
        {
                libidmefv2_string_t *env = NULL;


                while ( (env = idmefv2_process_get_next_env(process, env)) ) {
                        ret = libidmefv2_string_write(env, fd, IDMEFV2_MSG_PROCESS_ENV );
                        if ( ret < 0 )
                                return ret;
            }
        }

        {
                uint32_t *tmp;

                tmp = idmefv2_process_get_tid(process);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_PROCESS_TID);
                        if ( ret < 0 )
                                return ret;
                }
        }

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_service_write:
 * @service: Pointer to a #idmefv2_service_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @service within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_service_write(idmefv2_service_t *service, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! service )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_SERVICE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_service_get_ident(service), fd, IDMEFV2_MSG_SERVICE_IDENT);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_service_get_iana_protocol_number(service);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_SERVICE_IANA_PROTOCOL_NUMBER);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = libidmefv2_string_write(idmefv2_service_get_iana_protocol_name(service), fd, IDMEFV2_MSG_SERVICE_IANA_PROTOCOL_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_service_get_name(service), fd, IDMEFV2_MSG_SERVICE_NAME);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_service_get_port(service);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_SERVICE_PORT);
                        if ( ret < 0 )
                                return ret;
                }
        }


        ret = libidmefv2_string_write(idmefv2_service_get_portlist(service), fd, IDMEFV2_MSG_SERVICE_PORTLIST);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_service_get_protocol(service), fd, IDMEFV2_MSG_SERVICE_PROTOCOL);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_node_write:
 * @node: Pointer to a #idmefv2_node_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @node within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_write(idmefv2_node_t *node, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! node )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_NODE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_node_get_ident(node), fd, IDMEFV2_MSG_NODE_IDENT);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_location_write(idmefv2_node_get_location(node), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_node_name_t *node_name = NULL;


                while ( (node_name = idmefv2_node_get_next_node_name(node, node_name)) ) {
                        ret = idmefv2_node_name_write(node_name, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        {
                idmefv2_interface_t *interface = NULL;


                while ( (interface = idmefv2_node_get_next_interface(node, interface)) ) {
                        ret = idmefv2_interface_write(interface, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_user_write:
 * @user: Pointer to a #idmefv2_user_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @user within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_write(idmefv2_user_t *user, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! user )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_USER_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_user_get_ident(user), fd, IDMEFV2_MSG_USER_IDENT);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_user_get_category(user), fd, IDMEFV2_MSG_USER_CATEGORY);
        if ( ret < 0 )
                return ret;

        {
                idmefv2_user_id_t *user_id = NULL;


                while ( (user_id = idmefv2_user_get_next_user_id(user, user_id)) ) {
                        ret = idmefv2_user_id_write(user_id, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_impact_type_write:
 * @impact_type: Pointer to a #idmefv2_impact_type_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @impact_type within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_type_write(idmefv2_impact_type_t *impact_type, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! impact_type )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_IMPACT_TYPE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_impact_type_get_origin(impact_type), fd, IDMEFV2_MSG_IMPACT_TYPE_ORIGIN);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_impact_type_get_meaning(impact_type), fd, IDMEFV2_MSG_IMPACT_TYPE_MEANING);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_impact_type_get_name(impact_type), fd, IDMEFV2_MSG_IMPACT_TYPE_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_impact_type_get_url(impact_type), fd, IDMEFV2_MSG_IMPACT_TYPE_URL);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_source_write:
 * @source: Pointer to a #idmefv2_source_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @source within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_source_write(idmefv2_source_t *source, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! source )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_SOURCE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_source_get_ident(source), fd, IDMEFV2_MSG_SOURCE_IDENT);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_source_get_spoofed(source), fd, IDMEFV2_MSG_SOURCE_SPOOFED);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_node_write(idmefv2_source_get_node(source), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_user_write(idmefv2_source_get_user(source), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_process_write(idmefv2_source_get_process(source), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_service_write(idmefv2_source_get_service(source), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_target_write:
 * @target: Pointer to a #idmefv2_target_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @target within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_target_write(idmefv2_target_t *target, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! target )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_TARGET_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_target_get_ident(target), fd, IDMEFV2_MSG_TARGET_IDENT);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_target_get_decoy(target), fd, IDMEFV2_MSG_TARGET_DECOY);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_node_write(idmefv2_target_get_node(target), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_user_write(idmefv2_target_get_user(target), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_process_write(idmefv2_target_get_process(target), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_service_write(idmefv2_target_get_service(target), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_file_write(idmefv2_target_get_file(target), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_original_data_write:
 * @original_data: Pointer to a #idmefv2_original_data_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @original_data within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_original_data_write(idmefv2_original_data_t *original_data, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! original_data )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ORIGINAL_DATA_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = idmefv2_time_write(idmefv2_original_data_get_timestamp(original_data), fd, IDMEFV2_MSG_ORIGINAL_DATA_TIMESTAMP);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_original_data_get_name(original_data), fd, IDMEFV2_MSG_ORIGINAL_DATA_NAME);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_data_write(idmefv2_original_data_get_data(original_data), fd, IDMEFV2_MSG_ORIGINAL_DATA_DATA);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_node_write(idmefv2_original_data_get_node(original_data), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_file_write(idmefv2_original_data_get_file(original_data), fd);
         if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_observable_write:
 * @observable: Pointer to a #idmefv2_observable_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @observable within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_observable_write(idmefv2_observable_t *observable, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! observable )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_OBSERVABLE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_observable_get_origin(observable), fd, IDMEFV2_MSG_OBSERVABLE_ORIGIN);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_observable_get_meaning(observable), fd, IDMEFV2_MSG_OBSERVABLE_MEANING);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_observable_get_url(observable), fd, IDMEFV2_MSG_OBSERVABLE_URL);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_observable_get_name(observable), fd, IDMEFV2_MSG_OBSERVABLE_NAME);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_taken_action_write:
 * @taken_action: Pointer to a #idmefv2_taken_action_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @taken_action within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_taken_action_write(idmefv2_taken_action_t *taken_action, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! taken_action )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_TAKEN_ACTION_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_taken_action_get_category(taken_action), fd, IDMEFV2_MSG_TAKEN_ACTION_CATEGORY);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_reference_write:
 * @reference: Pointer to a #idmefv2_reference_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @reference within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_reference_write(idmefv2_reference_t *reference, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! reference )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_REFERENCE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_reference_get_origin(reference), fd, IDMEFV2_MSG_REFERENCE_ORIGIN);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_reference_get_meaning(reference), fd, IDMEFV2_MSG_REFERENCE_MEANING);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_reference_get_author(reference), fd, IDMEFV2_MSG_REFERENCE_AUTHOR);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_reference_get_publication_time(reference), fd, IDMEFV2_MSG_REFERENCE_PUBLICATION_TIME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_reference_get_version(reference), fd, IDMEFV2_MSG_REFERENCE_VERSION);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_reference_get_name(reference), fd, IDMEFV2_MSG_REFERENCE_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_reference_get_url(reference), fd, IDMEFV2_MSG_REFERENCE_URL);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}



/**
 * idmefv2_analyzer_write:
 * @analyzer: Pointer to a #idmefv2_analyzer_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @analyzer within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analyzer_write(idmefv2_analyzer_t *analyzer, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! analyzer )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ANALYZER_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_analyzer_get_analyzerid(analyzer), fd, IDMEFV2_MSG_ANALYZER_ANALYZERID);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_name(analyzer), fd, IDMEFV2_MSG_ANALYZER_NAME);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_manufacturer(analyzer), fd, IDMEFV2_MSG_ANALYZER_MANUFACTURER);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_model(analyzer), fd, IDMEFV2_MSG_ANALYZER_MODEL);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_version(analyzer), fd, IDMEFV2_MSG_ANALYZER_VERSION);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_analyzer_get_class(analyzer), fd, IDMEFV2_MSG_ANALYZER_CLASS);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_ostype(analyzer), fd, IDMEFV2_MSG_ANALYZER_OSTYPE);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_osversion(analyzer), fd, IDMEFV2_MSG_ANALYZER_OSVERSION);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_ext_class(analyzer), fd, IDMEFV2_MSG_ANALYZER_EXT_CLASS);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_analyzer_get_analyzeraction(analyzer), fd, IDMEFV2_MSG_ANALYZER_ANALYZERACTION);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_analyzer_get_actionhistory(analyzer), fd, IDMEFV2_MSG_ANALYZER_ACTIONHISTORY);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_node_write(idmefv2_analyzer_get_node(analyzer), fd);
         if ( ret < 0 )
                return ret;

         ret = idmefv2_process_write(idmefv2_analyzer_get_process(analyzer), fd);
         if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_analyzer_get_analyzer_time(analyzer), fd, IDMEFV2_MSG_ANALYZER_ANALYZER_TIME);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_additional_data_write:
 * @additional_data: Pointer to a #idmefv2_additional_data_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @additional_data within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_additional_data_write(idmefv2_additional_data_t *additional_data, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! additional_data )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ADDITIONAL_DATA_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_additional_data_get_meaning(additional_data), fd, IDMEFV2_MSG_ADDITIONAL_DATA_MEANING);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_additional_data_get_type(additional_data), fd, IDMEFV2_MSG_ADDITIONAL_DATA_TYPE);
        if ( ret < 0 )
                return ret;


        ret = idmefv2_data_write(idmefv2_additional_data_get_data(additional_data), fd, IDMEFV2_MSG_ADDITIONAL_DATA_DATA);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_correlation_alert_write:
 * @correlation_alert: Pointer to a #idmefv2_correlation_alert_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @correlation_alert within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_correlation_alert_write(idmefv2_correlation_alert_t *correlation_alert, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! correlation_alert )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_CORRELATION_ALERT_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_correlation_alert_get_name(correlation_alert), fd, IDMEFV2_MSG_CORRELATION_ALERT_NAME);
        if ( ret < 0 )
                return ret;

        {
                libidmefv2_string_t *alertident = NULL;


                while ( (alertident = idmefv2_correlation_alert_get_next_alertident(correlation_alert, alertident)) ) {
                        ret = libidmefv2_string_write(alertident, fd, IDMEFV2_MSG_CORRELATION_ALERT_ALERTIDENT );
                        if ( ret < 0 )
                                return ret;
            }
        }

        {
                uint32_t *tmp;

                tmp = idmefv2_correlation_alert_get_duration(correlation_alert);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_CORRELATION_ALERT_DURATION);
                        if ( ret < 0 )
                                return ret;
                }
        }


        {
                uint32_t *tmp;

                tmp = idmefv2_correlation_alert_get_counter(correlation_alert);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_CORRELATION_ALERT_COUNTER);
                        if ( ret < 0 )
                                return ret;
                }
        }

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_analysis_data_write:
 * @analysis_data: Pointer to a #idmefv2_analysis_data_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @analysis_data within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analysis_data_write(idmefv2_analysis_data_t *analysis_data, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! analysis_data )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ANALYSIS_DATA_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;
        {
                idmefv2_observable_t *observable = NULL;


                while ( (observable = idmefv2_analysis_data_get_next_observable(analysis_data, observable)) ) {
                        ret = idmefv2_observable_write(observable, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        {
                idmefv2_original_data_t *original_data = NULL;


                while ( (original_data = idmefv2_analysis_data_get_next_original_data(analysis_data, original_data)) ) {
                        ret = idmefv2_original_data_write(original_data, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_confidence_write:
 * @confidence: Pointer to a #idmefv2_confidence_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @confidence within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_confidence_write(idmefv2_confidence_t *confidence, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! confidence )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_CONFIDENCE_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_confidence_get_rating(confidence), fd, IDMEFV2_MSG_CONFIDENCE_RATING);
        if ( ret < 0 )
                return ret;

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}






/**
 * idmefv2_impact_write:
 * @impact: Pointer to a #idmefv2_impact_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @impact within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_write(idmefv2_impact_t *impact, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! impact )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_IMPACT_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_impact_get_severity(impact), fd, IDMEFV2_MSG_IMPACT_SEVERITY);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_impact_get_completion(impact), fd, IDMEFV2_MSG_IMPACT_COMPLETION);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_impact_get_availability(impact), fd, IDMEFV2_MSG_IMPACT_AVAILABILITY);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_impact_get_integrity(impact), fd, IDMEFV2_MSG_IMPACT_INTEGRITY);
        if ( ret < 0 )
                return ret;


        ret = uint32_write(idmefv2_impact_get_confidentiality(impact), fd, IDMEFV2_MSG_IMPACT_CONFIDENTIALITY);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_impact_get_description(impact), fd, IDMEFV2_MSG_IMPACT_DESCRIPTION);
        if ( ret < 0 )
                return ret;

        {
                idmefv2_impact_type_t *impact_type = NULL;


                while ( (impact_type = idmefv2_impact_get_next_impact_type(impact, impact_type)) ) {
                        ret = idmefv2_impact_type_write(impact_type, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_recommanded_action_write:
 * @recommanded_action: Pointer to a #idmefv2_recommanded_action_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @recommanded_action within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_recommanded_action_write(idmefv2_recommanded_action_t *recommanded_action, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! recommanded_action )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_RECOMMANDED_ACTION_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = uint32_write(idmefv2_recommanded_action_get_action(recommanded_action), fd, IDMEFV2_MSG_RECOMMANDED_ACTION_ACTION);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_recommanded_action_get_step(recommanded_action);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_RECOMMANDED_ACTION_STEP);
                        if ( ret < 0 )
                                return ret;
                }
        }

        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_assessment_write:
 * @assessment: Pointer to a #idmefv2_assessment_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @assessment within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_assessment_write(idmefv2_assessment_t *assessment, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! assessment )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ASSESSMENT_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;
         ret = idmefv2_impact_write(idmefv2_assessment_get_impact(assessment), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_taken_action_t *taken_action = NULL;


                while ( (taken_action = idmefv2_assessment_get_next_taken_action(assessment, taken_action)) ) {
                        ret = idmefv2_taken_action_write(taken_action, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
         ret = idmefv2_confidence_write(idmefv2_assessment_get_confidence(assessment), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_recommanded_action_t *recommanded_action = NULL;


                while ( (recommanded_action = idmefv2_assessment_get_next_recommanded_action(assessment, recommanded_action)) ) {
                        ret = idmefv2_recommanded_action_write(recommanded_action, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_classification_write:
 * @classification: Pointer to a #idmefv2_classification_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @classification within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_classification_write(idmefv2_classification_t *classification, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! classification )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_CLASSIFICATION_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_classification_get_ident(classification), fd, IDMEFV2_MSG_CLASSIFICATION_IDENT);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_classification_get_text(classification), fd, IDMEFV2_MSG_CLASSIFICATION_TEXT);
        if ( ret < 0 )
                return ret;

        {
                idmefv2_reference_t *reference = NULL;


                while ( (reference = idmefv2_classification_get_next_reference(classification, reference)) ) {
                        ret = idmefv2_reference_write(reference, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

/**
 * idmefv2_heartbeat_write:
 * @heartbeat: Pointer to a #idmefv2_heartbeat_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @heartbeat within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_heartbeat_write(idmefv2_heartbeat_t *heartbeat, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! heartbeat )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_HEARTBEAT_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_heartbeat_get_messageid(heartbeat), fd, IDMEFV2_MSG_HEARTBEAT_MESSAGEID);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_analyzer_write(idmefv2_heartbeat_get_analyzer(heartbeat), fd);
         if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_heartbeat_get_create_time(heartbeat), fd, IDMEFV2_MSG_HEARTBEAT_CREATE_TIME);
        if ( ret < 0 )
                return ret;


        {
                uint32_t *tmp;

                tmp = idmefv2_heartbeat_get_heartbeat_interval(heartbeat);
                if ( tmp ) {
                        ret = uint32_write(*tmp, fd, IDMEFV2_MSG_HEARTBEAT_HEARTBEAT_INTERVAL);
                        if ( ret < 0 )
                                return ret;
                }
        }

        {
                idmefv2_additional_data_t *additional_data = NULL;


                while ( (additional_data = idmefv2_heartbeat_get_next_additional_data(heartbeat, additional_data)) ) {
                        ret = idmefv2_additional_data_write(additional_data, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_alert_write:
 * @alert: Pointer to a #idmefv2_alert_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @alert within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_alert_write(idmefv2_alert_t *alert, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! alert )
            return 0;

        ret = binary_write(fd,  IDMEFV2_MSG_ALERT_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;

        ret = libidmefv2_string_write(idmefv2_alert_get_messageid(alert), fd, IDMEFV2_MSG_ALERT_MESSAGEID);
        if ( ret < 0 )
                return ret;


        ret = libidmefv2_string_write(idmefv2_alert_get_analyzerhash(alert), fd, IDMEFV2_MSG_ALERT_ANALYZERHASH);
        if ( ret < 0 )
                return ret;

        {
                idmefv2_analyzer_t *analyzer = NULL;


                while ( (analyzer = idmefv2_alert_get_next_analyzer(alert, analyzer)) ) {
                        ret = idmefv2_analyzer_write(analyzer, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }

        ret = idmefv2_time_write(idmefv2_alert_get_create_time(alert), fd, IDMEFV2_MSG_ALERT_CREATE_TIME);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_classification_write(idmefv2_alert_get_classification(alert), fd);
         if ( ret < 0 )
                return ret;


        ret = idmefv2_time_write(idmefv2_alert_get_detect_time(alert), fd, IDMEFV2_MSG_ALERT_DETECT_TIME);
        if ( ret < 0 )
                return ret;

         ret = idmefv2_analysis_data_write(idmefv2_alert_get_analysis_data(alert), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_source_t *source = NULL;


                while ( (source = idmefv2_alert_get_next_source(alert, source)) ) {
                        ret = idmefv2_source_write(source, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        {
                idmefv2_target_t *target = NULL;


                while ( (target = idmefv2_alert_get_next_target(alert, target)) ) {
                        ret = idmefv2_target_write(target, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
         ret = idmefv2_assessment_write(idmefv2_alert_get_assessment(alert), fd);
         if ( ret < 0 )
                return ret;

        {
                idmefv2_additional_data_t *additional_data = NULL;


                while ( (additional_data = idmefv2_alert_get_next_additional_data(alert, additional_data)) ) {
                        ret = idmefv2_additional_data_write(additional_data, fd);
                        if ( ret < 0 )
                                return ret;
            }
        }
        switch ( idmefv2_alert_get_type(alert) ) {
                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        ret = idmefv2_correlation_alert_write(idmefv2_alert_get_correlation_alert(alert), fd);
                        break;
                default:
                        /* nop */;
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}


/**
 * idmefv2_message_write:
 * @message: Pointer to a #idmefv2_message_t object.
 * @msg: Pointer to a #libidmefv2_msgbuf_t object, where the message should be written.
 *
 * Write @message within @msg message buffer. The buffer is
 * associated with a #libidmefv2_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_message_write(idmefv2_message_t *message, libidmefv2_io_t *fd)
{
        int ret;
        if ( ! message )
            return 0;


        ret = libidmefv2_string_write(idmefv2_message_get_version(message), fd, IDMEFV2_MSG_MESSAGE_VERSION);
        if ( ret < 0 )
                return ret;

        switch ( idmefv2_message_get_type(message) ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        ret = idmefv2_alert_write(idmefv2_message_get_alert(message), fd);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        ret = idmefv2_heartbeat_write(idmefv2_message_get_heartbeat(message), fd);
                        break;
                default:
                        /* nop */;
        }
        return binary_write(fd, IDMEFV2_MSG_END_OF_TAG, 0, NULL);
}

