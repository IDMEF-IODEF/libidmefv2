
























/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IDMEFV2 version : Not released yet
 * Template file: generate-tree-wrap.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include "libidmefv2-inttypes.h"
#include "libidmefv2-list.h"
#include "libidmefv2-string.h"

#define LIBIDMEFV2_ERROR_SOURCE_DEFAULT LIBIDMEFV2_ERROR_SOURCE_IDMEFV2_TREE_WRAP
#include "libidmefv2-error.h"

#include "idmefv2-time.h"
#include "idmefv2-data.h"
#include "idmefv2-class.h"
#include "idmefv2-value.h"
#include "idmefv2-object-prv.h"

#include "idmefv2-tree-wrap.h"
#include "libmissing.h"
#include "common.h"

#ifdef WIN32
# undef interface
#endif


#define LISTED_OBJECT(name, type) libidmefv2_list_t name
#define KEYLISTED_OBJECT(name, type) libidmefv2_list_t name

#define IS_KEY_LISTED(keyfield) IDMEFV2_LINKED_OBJECT; libidmefv2_string_t *keyfield

#define UNION(type, var) type var; union

#define UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount
#define REQUIRED(type, name) type name
#define IGNORED(type, name) type name

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; unsigned int name ## _is_set:1

#define IDENT(name) uint64_t name


#define idmefv2_data_copy idmefv2_data_copy_dup

#ifndef ABS
# define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


/*
 * If we subtract the integer representations of two floats then that
 * will tell us how close they are. If the difference is zero, they are
 * identical. If the difference is one, they are adjacent floats.
 * In general, if the difference is n then there are n-1 floats between
 * them.
 *
 * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
 */
static int float_compare(float a, float b)
{
        union {
                float fval;
                int32_t ival;
        } au, bu;

        au.fval = a;
        bu.fval = b;

        /* Make aInt lexicographically ordered as a twos-complement int */
        if ( au.ival < 0 )
                au.ival = 0x80000000 - au.ival;

        /* Make bInt lexicographically ordered as a twos-complement int */
        if ( bu.ival < 0 )
                bu.ival = 0x80000000 - bu.ival;

        return (ABS(au.ival - bu.ival) <= 0) ? 0 : -1;
}



static int libidmefv2_string_copy(const libidmefv2_string_t *src, libidmefv2_string_t *dst)
{
        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! libidmefv2_string_is_empty(src) )
               return libidmefv2_string_copy_dup(src, dst);

        return 0;
}



static int get_value_from_string(idmefv2_value_t **value, libidmefv2_string_t *str, libidmefv2_bool_t is_ptr)
{
        int ret;

        if ( ! str ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = libidmefv2_string_clone(str, &str);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmefv2_value_new_string(value, str);
        if ( ret < 0 ) {
                libidmefv2_string_destroy(str);
                return ret;
        }

        if ( is_ptr )
                libidmefv2_string_ref(str);

        return 0;
}



static int get_value_from_data(idmefv2_value_t **value, idmefv2_data_t *data, libidmefv2_bool_t is_ptr)
{
        int ret;

        if ( ! data ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = idmefv2_data_clone(data, &data);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmefv2_value_new_data(value, data);
        if ( ret < 0 ) {
                idmefv2_data_destroy(data);
                return ret;
        }

        if ( is_ptr )
                idmefv2_data_ref(data);

        return 0;
}


static int get_value_from_time(idmefv2_value_t **value, idmefv2_time_t *time, libidmefv2_bool_t is_ptr)
{
        int ret;

        if ( ! time ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = idmefv2_time_clone(time, &time);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmefv2_value_new_time(value, time);
        if ( ret < 0 ) {
                idmefv2_time_destroy(time);
                return ret;
        }

        if ( is_ptr )
                idmefv2_time_ref(time);
        return 0;
}


static void list_insert(libidmefv2_list_t *head, libidmefv2_list_t *item, int pos)
{
        int i = 0;
        libidmefv2_list_t *tmp;

        if ( pos == IDMEFV2_LIST_APPEND )
                libidmefv2_list_add_tail(head, item);

        else if ( pos == IDMEFV2_LIST_PREPEND )
                libidmefv2_list_add(head, item);

        else if ( pos >= 0 ) {
                libidmefv2_list_for_each(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libidmefv2_list_add_tail(tmp, item);
        }

        else if ( pos < 0 ) {
                pos = -pos;
                pos--;

                libidmefv2_list_for_each_reversed(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libidmefv2_list_add(tmp, item);
        }
}

        
/**
 * idmefv2_address_translation_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_address_translation_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_address_translation_t idmefv2_address_translation_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_address_translation_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDRESS_TRANSLATION_PRE, "pre" },


            { IDMEFV2_ADDRESS_TRANSLATION_POST, "post" },


            { IDMEFV2_ADDRESS_TRANSLATION_FALSE, "false" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for address_translation", name);

}
/**
 * idmefv2_address_translation_to_string:
 * @val: an enumeration value for #idmefv2_address_translation_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_address_translation_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_address_translation_to_string(idmefv2_address_translation_t val)
{

        const struct {
              idmefv2_address_translation_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDRESS_TRANSLATION_PRE, "pre" },

            { IDMEFV2_ADDRESS_TRANSLATION_POST, "post" },

            { IDMEFV2_ADDRESS_TRANSLATION_FALSE, "false" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_address_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_address_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_address_category_t idmefv2_address_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_address_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDRESS_CATEGORY_UNKNOWN, "unknown" },


            { IDMEFV2_ADDRESS_CATEGORY_ATM, "atm" },


            { IDMEFV2_ADDRESS_CATEGORY_E_MAIL, "e-mail" },


            { IDMEFV2_ADDRESS_CATEGORY_LOTUS_NOTES, "lotus-notes" },


            { IDMEFV2_ADDRESS_CATEGORY_MAC, "mac" },


            { IDMEFV2_ADDRESS_CATEGORY_SNA, "sna" },


            { IDMEFV2_ADDRESS_CATEGORY_VM, "vm" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV4_ADDR_HEX, "ipv4-addr-hex" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV6_ADDR_HEX, "ipv6-addr-hex" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },


            { IDMEFV2_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for address_category", name);

}
/**
 * idmefv2_address_category_to_string:
 * @val: an enumeration value for #idmefv2_address_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_address_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_address_category_to_string(idmefv2_address_category_t val)
{

        const struct {
              idmefv2_address_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDRESS_CATEGORY_UNKNOWN, "unknown" },

            { IDMEFV2_ADDRESS_CATEGORY_ATM, "atm" },

            { IDMEFV2_ADDRESS_CATEGORY_E_MAIL, "e-mail" },

            { IDMEFV2_ADDRESS_CATEGORY_LOTUS_NOTES, "lotus-notes" },

            { IDMEFV2_ADDRESS_CATEGORY_MAC, "mac" },

            { IDMEFV2_ADDRESS_CATEGORY_SNA, "sna" },

            { IDMEFV2_ADDRESS_CATEGORY_VM, "vm" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV4_ADDR_HEX, "ipv4-addr-hex" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV6_ADDR_HEX, "ipv6-addr-hex" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },

            { IDMEFV2_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_address {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_address_translation_t translation;
         idmefv2_address_category_t category;
         libidmefv2_string_t *vlan_name;
         OPTIONAL_INT(uint32_t, vlan_num);
        REQUIRED(libidmefv2_string_t, *address);
         libidmefv2_string_t *netmask;
};



        
/**
 * idmefv2_user_id_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_user_id_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_user_id_category_t idmefv2_user_id_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_user_id_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_USER_ID_CATEGORY_CURRENT_USER, "current-user" },


            { IDMEFV2_USER_ID_CATEGORY_ORIGINAL_USER, "original-user" },


            { IDMEFV2_USER_ID_CATEGORY_TARGET_USER, "target-user" },


            { IDMEFV2_USER_ID_CATEGORY_CURRENT_GROUP, "current-group" },


            { IDMEFV2_USER_ID_CATEGORY_ORIGINAL_GROUP, "original-group" },


            { IDMEFV2_USER_ID_CATEGORY_TARGET_GROUP, "target-group" },


            { IDMEFV2_USER_ID_CATEGORY_USER_PRIVS, "user-privs" },


            { IDMEFV2_USER_ID_CATEGORY_GROUP_PRIVS, "group-privs" },


            { IDMEFV2_USER_ID_CATEGORY_OTHER_PRIVS, "other-privs" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for user_id_category", name);

}
/**
 * idmefv2_user_id_category_to_string:
 * @val: an enumeration value for #idmefv2_user_id_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_user_id_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_user_id_category_to_string(idmefv2_user_id_category_t val)
{

        const struct {
              idmefv2_user_id_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_USER_ID_CATEGORY_CURRENT_USER, "current-user" },

            { IDMEFV2_USER_ID_CATEGORY_ORIGINAL_USER, "original-user" },

            { IDMEFV2_USER_ID_CATEGORY_TARGET_USER, "target-user" },

            { IDMEFV2_USER_ID_CATEGORY_CURRENT_GROUP, "current-group" },

            { IDMEFV2_USER_ID_CATEGORY_ORIGINAL_GROUP, "original-group" },

            { IDMEFV2_USER_ID_CATEGORY_TARGET_GROUP, "target-group" },

            { IDMEFV2_USER_ID_CATEGORY_USER_PRIVS, "user-privs" },

            { IDMEFV2_USER_ID_CATEGORY_GROUP_PRIVS, "group-privs" },

            { IDMEFV2_USER_ID_CATEGORY_OTHER_PRIVS, "other-privs" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_user_id {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_user_id_category_t category;
         libidmefv2_string_t *tty;
         libidmefv2_string_t *name;
         OPTIONAL_INT(uint32_t, number);
};



        
/**
 * idmefv2_node_name_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_node_name_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_node_name_category_t idmefv2_node_name_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_node_name_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_NODE_NAME_CATEGORY_UNKNOWN, "unknown" },


            { IDMEFV2_NODE_NAME_CATEGORY_AD, "ad" },


            { IDMEFV2_NODE_NAME_CATEGORY_AFS, "afs" },


            { IDMEFV2_NODE_NAME_CATEGORY_CODA, "coda" },


            { IDMEFV2_NODE_NAME_CATEGORY_DFS, "dfs" },


            { IDMEFV2_NODE_NAME_CATEGORY_DNS, "dns" },


            { IDMEFV2_NODE_NAME_CATEGORY_HOSTS, "hosts" },


            { IDMEFV2_NODE_NAME_CATEGORY_KERBEROS, "kerberos" },


            { IDMEFV2_NODE_NAME_CATEGORY_NDS, "nds" },


            { IDMEFV2_NODE_NAME_CATEGORY_NIS, "nis" },


            { IDMEFV2_NODE_NAME_CATEGORY_NISPLUS, "nisplus" },


            { IDMEFV2_NODE_NAME_CATEGORY_NT, "nt" },


            { IDMEFV2_NODE_NAME_CATEGORY_WFW, "wfw" },


            { IDMEFV2_NODE_NAME_CATEGORY_LLMNR, "llmnr" },


            { IDMEFV2_NODE_NAME_CATEGORY_MDNS, "mdns" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for node_name_category", name);

}
/**
 * idmefv2_node_name_category_to_string:
 * @val: an enumeration value for #idmefv2_node_name_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_node_name_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_node_name_category_to_string(idmefv2_node_name_category_t val)
{

        const struct {
              idmefv2_node_name_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_NODE_NAME_CATEGORY_UNKNOWN, "unknown" },

            { IDMEFV2_NODE_NAME_CATEGORY_AD, "ad" },

            { IDMEFV2_NODE_NAME_CATEGORY_AFS, "afs" },

            { IDMEFV2_NODE_NAME_CATEGORY_CODA, "coda" },

            { IDMEFV2_NODE_NAME_CATEGORY_DFS, "dfs" },

            { IDMEFV2_NODE_NAME_CATEGORY_DNS, "dns" },

            { IDMEFV2_NODE_NAME_CATEGORY_HOSTS, "hosts" },

            { IDMEFV2_NODE_NAME_CATEGORY_KERBEROS, "kerberos" },

            { IDMEFV2_NODE_NAME_CATEGORY_NDS, "nds" },

            { IDMEFV2_NODE_NAME_CATEGORY_NIS, "nis" },

            { IDMEFV2_NODE_NAME_CATEGORY_NISPLUS, "nisplus" },

            { IDMEFV2_NODE_NAME_CATEGORY_NT, "nt" },

            { IDMEFV2_NODE_NAME_CATEGORY_WFW, "wfw" },

            { IDMEFV2_NODE_NAME_CATEGORY_LLMNR, "llmnr" },

            { IDMEFV2_NODE_NAME_CATEGORY_MDNS, "mdns" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_node_name {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_node_name_category_t category;
        REQUIRED(libidmefv2_string_t, *name);
};



        


struct idmefv2_location {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *name;
         OPTIONAL_INT(float, latitude);
         OPTIONAL_INT(float, longitude);
         OPTIONAL_INT(float, altitude);
         libidmefv2_string_t *country;
         libidmefv2_string_t *city;
         libidmefv2_string_t *postcode;
};



        
/**
 * idmefv2_interface_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_interface_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_interface_category_t idmefv2_interface_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_interface_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_INTERFACE_CATEGORY_USER_SPECIFIC, "user-specific" },


            { IDMEFV2_INTERFACE_CATEGORY_VENDOR_SPECIFIC, "vendor-specific" },


            { IDMEFV2_INTERFACE_CATEGORY_MANAGEMENT, "management" },


            { IDMEFV2_INTERFACE_CATEGORY_NETWORK, "network" },


            { IDMEFV2_INTERFACE_CATEGORY_CAPTURE, "capture" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for interface_category", name);

}
/**
 * idmefv2_interface_category_to_string:
 * @val: an enumeration value for #idmefv2_interface_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_interface_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_interface_category_to_string(idmefv2_interface_category_t val)
{

        const struct {
              idmefv2_interface_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_INTERFACE_CATEGORY_USER_SPECIFIC, "user-specific" },

            { IDMEFV2_INTERFACE_CATEGORY_VENDOR_SPECIFIC, "vendor-specific" },

            { IDMEFV2_INTERFACE_CATEGORY_MANAGEMENT, "management" },

            { IDMEFV2_INTERFACE_CATEGORY_NETWORK, "network" },

            { IDMEFV2_INTERFACE_CATEGORY_CAPTURE, "capture" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_interface {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *name;
         idmefv2_interface_category_t category;
         libidmefv2_string_t *meaning;
        LISTED_OBJECT(address_list, idmefv2_address_t);
};



        
/**
 * idmefv2_file_access_permission_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_file_access_permission_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_file_access_permission_t idmefv2_file_access_permission_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_file_access_permission_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_FILE_ACCESS_PERMISSION_NO_ACCESS, "noaccess" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_READ, "read" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_WRITE, "write" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_EXECUTE, "execute" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_SEARCH, "search" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_DELETE, "delete" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_EXECUTE_AS, "executeas" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_CHANGE_PERMISSIONS, "changepermissions" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_CHANGE_OWNERSHIP, "changeownership" },


            { IDMEFV2_FILE_ACCESS_PERMISSION_READ_PERMISSIONS, "readpermissions" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for file_access_permission", name);

}
/**
 * idmefv2_file_access_permission_to_string:
 * @val: an enumeration value for #idmefv2_file_access_permission_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_file_access_permission_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_file_access_permission_to_string(idmefv2_file_access_permission_t val)
{

        const struct {
              idmefv2_file_access_permission_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_FILE_ACCESS_PERMISSION_NO_ACCESS, "noaccess" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_READ, "read" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_WRITE, "write" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_EXECUTE, "execute" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_SEARCH, "search" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_DELETE, "delete" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_EXECUTE_AS, "executeas" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_CHANGE_PERMISSIONS, "changepermissions" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_CHANGE_OWNERSHIP, "changeownership" },

            { IDMEFV2_FILE_ACCESS_PERMISSION_READ_PERMISSIONS, "readpermissions" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_file_access {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
        REQUIRED(idmefv2_user_id_t, *user_id);
         idmefv2_file_access_permission_t permission;
};



        


struct idmefv2_inode {

         IDMEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(uint32_t, number);
         OPTIONAL_INT(uint32_t, major_device);
         OPTIONAL_INT(uint32_t, minor_device);
         OPTIONAL_INT(uint32_t, c_major_device);
         OPTIONAL_INT(uint32_t, c_minor_device);
         idmefv2_time_t *change_time;
};



        
/**
 * idmefv2_checksum_algorithm_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_checksum_algorithm_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_checksum_algorithm_t idmefv2_checksum_algorithm_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_checksum_algorithm_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_CHECKSUM_ALGORITHM_MD4, "MD4" },


            { IDMEFV2_CHECKSUM_ALGORITHM_MD5, "MD5" },


            { IDMEFV2_CHECKSUM_ALGORITHM_SHA1, "SHA1" },


            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_256, "SHA2-256" },


            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_384, "SHA2-384" },


            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_512, "SHA2-512" },


            { IDMEFV2_CHECKSUM_ALGORITHM_CRC_32, "CRC-32" },


            { IDMEFV2_CHECKSUM_ALGORITHM_HAVAL, "Haval" },


            { IDMEFV2_CHECKSUM_ALGORITHM_TIGER, "Tiger" },


            { IDMEFV2_CHECKSUM_ALGORITHM_GOST, "Gost" },


            { IDMEFV2_CHECKSUM_ALGORITHM_SHA3, "SHA3" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for checksum_algorithm", name);

}
/**
 * idmefv2_checksum_algorithm_to_string:
 * @val: an enumeration value for #idmefv2_checksum_algorithm_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_checksum_algorithm_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_checksum_algorithm_to_string(idmefv2_checksum_algorithm_t val)
{

        const struct {
              idmefv2_checksum_algorithm_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_CHECKSUM_ALGORITHM_MD4, "MD4" },

            { IDMEFV2_CHECKSUM_ALGORITHM_MD5, "MD5" },

            { IDMEFV2_CHECKSUM_ALGORITHM_SHA1, "SHA1" },

            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_256, "SHA2-256" },

            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_384, "SHA2-384" },

            { IDMEFV2_CHECKSUM_ALGORITHM_SHA2_512, "SHA2-512" },

            { IDMEFV2_CHECKSUM_ALGORITHM_CRC_32, "CRC-32" },

            { IDMEFV2_CHECKSUM_ALGORITHM_HAVAL, "Haval" },

            { IDMEFV2_CHECKSUM_ALGORITHM_TIGER, "Tiger" },

            { IDMEFV2_CHECKSUM_ALGORITHM_GOST, "Gost" },

            { IDMEFV2_CHECKSUM_ALGORITHM_SHA3, "SHA3" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_checksum {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *value);
         libidmefv2_string_t *key;
         idmefv2_checksum_algorithm_t algorithm;
};



        
/**
 * idmefv2_stream_offsetunit_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_stream_offsetunit_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_stream_offsetunit_t idmefv2_stream_offsetunit_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_stream_offsetunit_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_STREAM_OFFSETUNIT_LINE, "line" },


            { IDMEFV2_STREAM_OFFSETUNIT_BINARY, "binary" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for stream_offsetunit", name);

}
/**
 * idmefv2_stream_offsetunit_to_string:
 * @val: an enumeration value for #idmefv2_stream_offsetunit_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_stream_offsetunit_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_stream_offsetunit_to_string(idmefv2_stream_offsetunit_t val)
{

        const struct {
              idmefv2_stream_offsetunit_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_STREAM_OFFSETUNIT_LINE, "line" },

            { IDMEFV2_STREAM_OFFSETUNIT_BINARY, "binary" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_stream {

         IDMEFV2_OBJECT;
         REFCOUNT;
         idmefv2_stream_offsetunit_t offsetunit;
         OPTIONAL_INT(uint32_t, offset);
};



        
/**
 * idmefv2_file_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_file_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_file_category_t idmefv2_file_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_file_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_FILE_CATEGORY_CURRENT, "current" },


            { IDMEFV2_FILE_CATEGORY_ORIGINAL, "original" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for file_category", name);

}
/**
 * idmefv2_file_category_to_string:
 * @val: an enumeration value for #idmefv2_file_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_file_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_file_category_to_string(idmefv2_file_category_t val)
{

        const struct {
              idmefv2_file_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_FILE_CATEGORY_CURRENT, "current" },

            { IDMEFV2_FILE_CATEGORY_ORIGINAL, "original" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_file {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(libidmefv2_string_t, *path);
         idmefv2_time_t *create_time;
         idmefv2_time_t *modify_time;
         idmefv2_time_t *access_time;
         OPTIONAL_INT(uint64_t, data_size);
         OPTIONAL_INT(uint64_t, disk_size);
        LISTED_OBJECT(file_access_list, idmefv2_file_access_t);
        LISTED_OBJECT(linkage_list, idmefv2_linkage_t);
         idmefv2_inode_t *inode;
        LISTED_OBJECT(checksum_list, idmefv2_checksum_t);
         idmefv2_file_category_t category;
         libidmefv2_string_t *file_type;
         idmefv2_container_t *container;
         idmefv2_stream_t *stream;
};



        
/**
 * idmefv2_linkage_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_linkage_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_linkage_category_t idmefv2_linkage_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_linkage_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_LINKAGE_CATEGORY_HARD_LINK, "hard-link" },


            { IDMEFV2_LINKAGE_CATEGORY_MOUNT_POINT, "mount-point" },


            { IDMEFV2_LINKAGE_CATEGORY_REPARSE_POINT, "reparse-point" },


            { IDMEFV2_LINKAGE_CATEGORY_SHORTCUT, "shortcut" },


            { IDMEFV2_LINKAGE_CATEGORY_STREAM, "stream" },


            { IDMEFV2_LINKAGE_CATEGORY_SYMBOLIC_LINK, "symbolic-link" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for linkage_category", name);

}
/**
 * idmefv2_linkage_category_to_string:
 * @val: an enumeration value for #idmefv2_linkage_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_linkage_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_linkage_category_to_string(idmefv2_linkage_category_t val)
{

        const struct {
              idmefv2_linkage_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_LINKAGE_CATEGORY_HARD_LINK, "hard-link" },

            { IDMEFV2_LINKAGE_CATEGORY_MOUNT_POINT, "mount-point" },

            { IDMEFV2_LINKAGE_CATEGORY_REPARSE_POINT, "reparse-point" },

            { IDMEFV2_LINKAGE_CATEGORY_SHORTCUT, "shortcut" },

            { IDMEFV2_LINKAGE_CATEGORY_STREAM, "stream" },

            { IDMEFV2_LINKAGE_CATEGORY_SYMBOLIC_LINK, "symbolic-link" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_linkage {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_linkage_category_t category;
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(libidmefv2_string_t, *path);
        REQUIRED(idmefv2_file_t, *file);
};



        


struct idmefv2_container {

         IDMEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(libidmefv2_string_t, *path);
        REQUIRED(idmefv2_file_t, *file);
};



        


struct idmefv2_process {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
        REQUIRED(libidmefv2_string_t, *name);
         OPTIONAL_INT(uint32_t, pid);
         libidmefv2_string_t *path;
        LISTED_OBJECT(arg_list, libidmefv2_string_t);
        LISTED_OBJECT(env_list, libidmefv2_string_t);
         OPTIONAL_INT(uint32_t, tid);
};



        


struct idmefv2_service {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         OPTIONAL_INT(uint32_t, iana_protocol_number);
         libidmefv2_string_t *iana_protocol_name;
         libidmefv2_string_t *name;
         OPTIONAL_INT(uint32_t, port);
         libidmefv2_string_t *portlist;
         libidmefv2_string_t *protocol;
};



        


struct idmefv2_node {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_location_t *location;
        LISTED_OBJECT(node_name_list, idmefv2_node_name_t);
        LISTED_OBJECT(interface_list, idmefv2_interface_t);
};



        
/**
 * idmefv2_user_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_user_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_user_category_t idmefv2_user_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_user_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_USER_CATEGORY_UNKNOWN, "unknown" },


            { IDMEFV2_USER_CATEGORY_APPLICATION, "application" },


            { IDMEFV2_USER_CATEGORY_OS_DEVICE, "os-device" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for user_category", name);

}
/**
 * idmefv2_user_category_to_string:
 * @val: an enumeration value for #idmefv2_user_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_user_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_user_category_to_string(idmefv2_user_category_t val)
{

        const struct {
              idmefv2_user_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_USER_CATEGORY_UNKNOWN, "unknown" },

            { IDMEFV2_USER_CATEGORY_APPLICATION, "application" },

            { IDMEFV2_USER_CATEGORY_OS_DEVICE, "os-device" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_user {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_user_category_t category;
        LISTED_OBJECT(user_id_list, idmefv2_user_id_t);
};



        
/**
 * idmefv2_impact_type_origin_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_type_origin_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_type_origin_t idmefv2_impact_type_origin_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_type_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_TYPE_ORIGIN_UNKNOWN, "unknown" },


            { IDMEFV2_IMPACT_TYPE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },


            { IDMEFV2_IMPACT_TYPE_ORIGIN_USER_SPECIFIC, "user-specific" },


            { IDMEFV2_IMPACT_TYPE_ORIGIN_ETSI, "etsi" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_type_origin", name);

}
/**
 * idmefv2_impact_type_origin_to_string:
 * @val: an enumeration value for #idmefv2_impact_type_origin_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_type_origin_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_type_origin_to_string(idmefv2_impact_type_origin_t val)
{

        const struct {
              idmefv2_impact_type_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_TYPE_ORIGIN_UNKNOWN, "unknown" },

            { IDMEFV2_IMPACT_TYPE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },

            { IDMEFV2_IMPACT_TYPE_ORIGIN_USER_SPECIFIC, "user-specific" },

            { IDMEFV2_IMPACT_TYPE_ORIGIN_ETSI, "etsi" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_impact_type {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_impact_type_origin_t origin;
         libidmefv2_string_t *meaning;
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(libidmefv2_string_t, *url);
};



        
/**
 * idmefv2_source_spoofed_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_source_spoofed_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_source_spoofed_t idmefv2_source_spoofed_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_source_spoofed_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_SOURCE_SPOOFED_UNKNOWN, "unknown" },


            { IDMEFV2_SOURCE_SPOOFED_YES, "yes" },


            { IDMEFV2_SOURCE_SPOOFED_NO, "no" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for source_spoofed", name);

}
/**
 * idmefv2_source_spoofed_to_string:
 * @val: an enumeration value for #idmefv2_source_spoofed_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_source_spoofed_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_source_spoofed_to_string(idmefv2_source_spoofed_t val)
{

        const struct {
              idmefv2_source_spoofed_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_SOURCE_SPOOFED_UNKNOWN, "unknown" },

            { IDMEFV2_SOURCE_SPOOFED_YES, "yes" },

            { IDMEFV2_SOURCE_SPOOFED_NO, "no" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_source {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_source_spoofed_t spoofed;
         idmefv2_node_t *node;
         idmefv2_user_t *user;
         idmefv2_process_t *process;
         idmefv2_service_t *service;
};



        
/**
 * idmefv2_target_decoy_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_target_decoy_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_target_decoy_t idmefv2_target_decoy_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_target_decoy_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_TARGET_DECOY_UNKNOWN, "unknown" },


            { IDMEFV2_TARGET_DECOY_YES, "yes" },


            { IDMEFV2_TARGET_DECOY_NO, "no" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for target_decoy", name);

}
/**
 * idmefv2_target_decoy_to_string:
 * @val: an enumeration value for #idmefv2_target_decoy_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_target_decoy_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_target_decoy_to_string(idmefv2_target_decoy_t val)
{

        const struct {
              idmefv2_target_decoy_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_TARGET_DECOY_UNKNOWN, "unknown" },

            { IDMEFV2_TARGET_DECOY_YES, "yes" },

            { IDMEFV2_TARGET_DECOY_NO, "no" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_target {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
         idmefv2_target_decoy_t decoy;
         idmefv2_node_t *node;
         idmefv2_user_t *user;
         idmefv2_process_t *process;
         idmefv2_service_t *service;
         idmefv2_file_t *file;
};



        


struct idmefv2_original_data {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
        REQUIRED(idmefv2_time_t, *timestamp);
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(idmefv2_data_t, *data);
         idmefv2_node_t *node;
         idmefv2_file_t *file;
};



        
/**
 * idmefv2_observable_origin_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_observable_origin_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_observable_origin_t idmefv2_observable_origin_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_observable_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_OBSERVABLE_ORIGIN_UNKNOWN, "unknown" },


            { IDMEFV2_OBSERVABLE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },


            { IDMEFV2_OBSERVABLE_ORIGIN_USER_SPECIFIC, "user-specific" },


            { IDMEFV2_OBSERVABLE_ORIGIN_ETSI, "etsi" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for observable_origin", name);

}
/**
 * idmefv2_observable_origin_to_string:
 * @val: an enumeration value for #idmefv2_observable_origin_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_observable_origin_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_observable_origin_to_string(idmefv2_observable_origin_t val)
{

        const struct {
              idmefv2_observable_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_OBSERVABLE_ORIGIN_UNKNOWN, "unknown" },

            { IDMEFV2_OBSERVABLE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },

            { IDMEFV2_OBSERVABLE_ORIGIN_USER_SPECIFIC, "user-specific" },

            { IDMEFV2_OBSERVABLE_ORIGIN_ETSI, "etsi" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_observable {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_observable_origin_t origin;
         libidmefv2_string_t *meaning;
        REQUIRED(libidmefv2_string_t, *url);
        REQUIRED(libidmefv2_string_t, *name);
};



        
/**
 * idmefv2_taken_action_category_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_taken_action_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_taken_action_category_t idmefv2_taken_action_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_taken_action_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_TAKEN_ACTION_CATEGORY_BLOCK_INSTALLED, "block-installed" },


            { IDMEFV2_TAKEN_ACTION_CATEGORY_NOTIFICATION_SENT, "notification-sent" },


            { IDMEFV2_TAKEN_ACTION_CATEGORY_TAKEN_OFFLINE, "taken-offline" },


            { IDMEFV2_TAKEN_ACTION_CATEGORY_OTHER, "other" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for taken_action_category", name);

}
/**
 * idmefv2_taken_action_category_to_string:
 * @val: an enumeration value for #idmefv2_taken_action_category_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_taken_action_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_taken_action_category_to_string(idmefv2_taken_action_category_t val)
{

        const struct {
              idmefv2_taken_action_category_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_TAKEN_ACTION_CATEGORY_BLOCK_INSTALLED, "block-installed" },

            { IDMEFV2_TAKEN_ACTION_CATEGORY_NOTIFICATION_SENT, "notification-sent" },

            { IDMEFV2_TAKEN_ACTION_CATEGORY_TAKEN_OFFLINE, "taken-offline" },

            { IDMEFV2_TAKEN_ACTION_CATEGORY_OTHER, "other" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_taken_action {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_taken_action_category_t category;
};



        
/**
 * idmefv2_reference_origin_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_reference_origin_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_reference_origin_t idmefv2_reference_origin_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_reference_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_REFERENCE_ORIGIN_UNKNOWN, "unknown" },


            { IDMEFV2_REFERENCE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },


            { IDMEFV2_REFERENCE_ORIGIN_USER_SPECIFIC, "user-specific" },


            { IDMEFV2_REFERENCE_ORIGIN_BUGTRAQID, "bugtraqid" },


            { IDMEFV2_REFERENCE_ORIGIN_CVE, "cve" },


            { IDMEFV2_REFERENCE_ORIGIN_OSVDB, "osvdb" },


            { IDMEFV2_REFERENCE_ORIGIN_CERT_SPECIFIC, "cert-specific" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for reference_origin", name);

}
/**
 * idmefv2_reference_origin_to_string:
 * @val: an enumeration value for #idmefv2_reference_origin_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_reference_origin_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_reference_origin_to_string(idmefv2_reference_origin_t val)
{

        const struct {
              idmefv2_reference_origin_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_REFERENCE_ORIGIN_UNKNOWN, "unknown" },

            { IDMEFV2_REFERENCE_ORIGIN_VENDOR_SPECIFIC, "vendor-specific" },

            { IDMEFV2_REFERENCE_ORIGIN_USER_SPECIFIC, "user-specific" },

            { IDMEFV2_REFERENCE_ORIGIN_BUGTRAQID, "bugtraqid" },

            { IDMEFV2_REFERENCE_ORIGIN_CVE, "cve" },

            { IDMEFV2_REFERENCE_ORIGIN_OSVDB, "osvdb" },

            { IDMEFV2_REFERENCE_ORIGIN_CERT_SPECIFIC, "cert-specific" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_reference {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_reference_origin_t origin;
         libidmefv2_string_t *meaning;
         libidmefv2_string_t *author;
         idmefv2_time_t *publication_time;
         libidmefv2_string_t *version;
        REQUIRED(libidmefv2_string_t, *name);
        REQUIRED(libidmefv2_string_t, *url);
};



        
/**
 * idmefv2_analyzer_class_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_analyzer_class_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_analyzer_class_t idmefv2_analyzer_class_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_analyzer_class_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ANALYZER_CLASS_UNKNOWN, "unknown" },


            { IDMEFV2_ANALYZER_CLASS_EXT_CLASS, "ext-class" },


            { IDMEFV2_ANALYZER_CLASS_NIDS, "nids" },


            { IDMEFV2_ANALYZER_CLASS_SNIDS, "snids" },


            { IDMEFV2_ANALYZER_CLASS_HIDS, "hids" },


            { IDMEFV2_ANALYZER_CLASS_IPS, "ips" },


            { IDMEFV2_ANALYZER_CLASS_FILE_INTEGRITY_CHECKER, "file integrity checker" },


            { IDMEFV2_ANALYZER_CLASS_INTEGRITY_CHECKER, "integrity checker" },


            { IDMEFV2_ANALYZER_CLASS_LOG_ANALYZER, "log analyzer" },


            { IDMEFV2_ANALYZER_CLASS_NETWORK_ANTI_VIRUS, "network anti-virus" },


            { IDMEFV2_ANALYZER_CLASS_HOST_ANTI_VIRUS, "host anti-virus" },


            { IDMEFV2_ANALYZER_CLASS_CORRELATOR, "correlator" },


            { IDMEFV2_ANALYZER_CLASS_FIREWALL, "firewall" },


            { IDMEFV2_ANALYZER_CLASS_HONEYPOT, "honeypot" },


            { IDMEFV2_ANALYZER_CLASS_SOFTWARE_MONITORING, "software monitoring" },


            { IDMEFV2_ANALYZER_CLASS_HARDWARE_MONITORING, "hardware monitoring" },


            { IDMEFV2_ANALYZER_CLASS_ACTIVE_VULNERABILITY_SCANNER, "active vulnerability scanner" },


            { IDMEFV2_ANALYZER_CLASS_PASSIVE_VULNERABILITY_SCANNER, "passive vulnerability scanner" },


            { IDMEFV2_ANALYZER_CLASS_ALARM_HARDWARE, "alarm hardware" },


            { IDMEFV2_ANALYZER_CLASS_PRIVATE_BRANCH_EXCHANGE, "private branch exchange" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for analyzer_class", name);

}
/**
 * idmefv2_analyzer_class_to_string:
 * @val: an enumeration value for #idmefv2_analyzer_class_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_analyzer_class_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_analyzer_class_to_string(idmefv2_analyzer_class_t val)
{

        const struct {
              idmefv2_analyzer_class_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ANALYZER_CLASS_UNKNOWN, "unknown" },

            { IDMEFV2_ANALYZER_CLASS_EXT_CLASS, "ext-class" },

            { IDMEFV2_ANALYZER_CLASS_NIDS, "nids" },

            { IDMEFV2_ANALYZER_CLASS_SNIDS, "snids" },

            { IDMEFV2_ANALYZER_CLASS_HIDS, "hids" },

            { IDMEFV2_ANALYZER_CLASS_IPS, "ips" },

            { IDMEFV2_ANALYZER_CLASS_FILE_INTEGRITY_CHECKER, "file integrity checker" },

            { IDMEFV2_ANALYZER_CLASS_INTEGRITY_CHECKER, "integrity checker" },

            { IDMEFV2_ANALYZER_CLASS_LOG_ANALYZER, "log analyzer" },

            { IDMEFV2_ANALYZER_CLASS_NETWORK_ANTI_VIRUS, "network anti-virus" },

            { IDMEFV2_ANALYZER_CLASS_HOST_ANTI_VIRUS, "host anti-virus" },

            { IDMEFV2_ANALYZER_CLASS_CORRELATOR, "correlator" },

            { IDMEFV2_ANALYZER_CLASS_FIREWALL, "firewall" },

            { IDMEFV2_ANALYZER_CLASS_HONEYPOT, "honeypot" },

            { IDMEFV2_ANALYZER_CLASS_SOFTWARE_MONITORING, "software monitoring" },

            { IDMEFV2_ANALYZER_CLASS_HARDWARE_MONITORING, "hardware monitoring" },

            { IDMEFV2_ANALYZER_CLASS_ACTIVE_VULNERABILITY_SCANNER, "active vulnerability scanner" },

            { IDMEFV2_ANALYZER_CLASS_PASSIVE_VULNERABILITY_SCANNER, "passive vulnerability scanner" },

            { IDMEFV2_ANALYZER_CLASS_ALARM_HARDWARE, "alarm hardware" },

            { IDMEFV2_ANALYZER_CLASS_PRIVATE_BRANCH_EXCHANGE, "private branch exchange" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_analyzer_analyzeraction_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_analyzer_analyzeraction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_analyzer_analyzeraction_t idmefv2_analyzer_analyzeraction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_analyzer_analyzeraction_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ANALYZER_ANALYZERACTION_CREATE, "create" },


            { IDMEFV2_ANALYZER_ANALYZERACTION_FORWARD, "forward" },


            { IDMEFV2_ANALYZER_ANALYZERACTION_EDIT, "edit" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for analyzer_analyzeraction", name);

}
/**
 * idmefv2_analyzer_analyzeraction_to_string:
 * @val: an enumeration value for #idmefv2_analyzer_analyzeraction_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_analyzer_analyzeraction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_analyzer_analyzeraction_to_string(idmefv2_analyzer_analyzeraction_t val)
{

        const struct {
              idmefv2_analyzer_analyzeraction_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ANALYZER_ANALYZERACTION_CREATE, "create" },

            { IDMEFV2_ANALYZER_ANALYZERACTION_FORWARD, "forward" },

            { IDMEFV2_ANALYZER_ANALYZERACTION_EDIT, "edit" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_analyzer {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *analyzerid);
         libidmefv2_string_t *name;
         libidmefv2_string_t *manufacturer;
         libidmefv2_string_t *model;
         libidmefv2_string_t *version;
         idmefv2_analyzer_class_t class;
         libidmefv2_string_t *ostype;
         libidmefv2_string_t *osversion;
         libidmefv2_string_t *ext_class;
         idmefv2_analyzer_analyzeraction_t analyzeraction;
         libidmefv2_string_t *actionhistory;
         idmefv2_node_t *node;
         idmefv2_process_t *process;
         idmefv2_time_t *analyzer_time;
};



        
/**
 * idmefv2_additional_data_type_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_additional_data_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_additional_data_type_t idmefv2_additional_data_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_additional_data_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDITIONAL_DATA_TYPE_STRING, "string" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_BYTE, "byte" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_REAL, "real" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_BYTE_STRING, "byte-string" },


            { IDMEFV2_ADDITIONAL_DATA_TYPE_XML, "xml" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for additional_data_type", name);

}
/**
 * idmefv2_additional_data_type_to_string:
 * @val: an enumeration value for #idmefv2_additional_data_type_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_additional_data_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_additional_data_type_to_string(idmefv2_additional_data_type_t val)
{

        const struct {
              idmefv2_additional_data_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ADDITIONAL_DATA_TYPE_STRING, "string" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_BYTE, "byte" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_REAL, "real" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_BYTE_STRING, "byte-string" },

            { IDMEFV2_ADDITIONAL_DATA_TYPE_XML, "xml" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_additional_data {

        IS_KEY_LISTED(meaning);
         REFCOUNT;
         IGNORED(libidmefv2_bool_t, _type_is_set);
         idmefv2_additional_data_type_t type;
        REQUIRED(idmefv2_data_t, *data);
};



        


struct idmefv2_correlation_alert {

         IDMEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *name);
        LISTED_OBJECT(alertident_list, libidmefv2_string_t);
         OPTIONAL_INT(uint32_t, duration);
         OPTIONAL_INT(uint32_t, counter);
};



        


struct idmefv2_analysis_data {

         IDMEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(observable_list, idmefv2_observable_t);
        LISTED_OBJECT(original_data_list, idmefv2_original_data_t);
};



        
/**
 * idmefv2_confidence_rating_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_confidence_rating_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_confidence_rating_t idmefv2_confidence_rating_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_confidence_rating_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_CONFIDENCE_RATING_LOW, "low" },


            { IDMEFV2_CONFIDENCE_RATING_MEDIUM, "medium" },


            { IDMEFV2_CONFIDENCE_RATING_HIGH, "high" },


            { IDMEFV2_CONFIDENCE_RATING_NUMERIC, "numeric" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for confidence_rating", name);

}
/**
 * idmefv2_confidence_rating_to_string:
 * @val: an enumeration value for #idmefv2_confidence_rating_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_confidence_rating_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_confidence_rating_to_string(idmefv2_confidence_rating_t val)
{

        const struct {
              idmefv2_confidence_rating_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_CONFIDENCE_RATING_LOW, "low" },

            { IDMEFV2_CONFIDENCE_RATING_MEDIUM, "medium" },

            { IDMEFV2_CONFIDENCE_RATING_HIGH, "high" },

            { IDMEFV2_CONFIDENCE_RATING_NUMERIC, "numeric" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_confidence {

         IDMEFV2_OBJECT;
         REFCOUNT;
         idmefv2_confidence_rating_t rating;
};



        
/**
 * idmefv2_impact_severity_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_severity_t idmefv2_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_SEVERITY_INFO, "info" },


            { IDMEFV2_IMPACT_SEVERITY_LOW, "low" },


            { IDMEFV2_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IDMEFV2_IMPACT_SEVERITY_HIGH, "high" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_severity", name);

}
/**
 * idmefv2_impact_severity_to_string:
 * @val: an enumeration value for #idmefv2_impact_severity_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_severity_to_string(idmefv2_impact_severity_t val)
{

        const struct {
              idmefv2_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_SEVERITY_INFO, "info" },

            { IDMEFV2_IMPACT_SEVERITY_LOW, "low" },

            { IDMEFV2_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IDMEFV2_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_impact_completion_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_completion_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_completion_t idmefv2_impact_completion_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_completion_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_COMPLETION_FAILED, "failed" },


            { IDMEFV2_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_completion", name);

}
/**
 * idmefv2_impact_completion_to_string:
 * @val: an enumeration value for #idmefv2_impact_completion_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_completion_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_completion_to_string(idmefv2_impact_completion_t val)
{

        const struct {
              idmefv2_impact_completion_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_COMPLETION_FAILED, "failed" },

            { IDMEFV2_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_impact_availability_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_availability_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_availability_t idmefv2_impact_availability_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_availability_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_AVAILABILITY_TRUE, "true" },


            { IDMEFV2_IMPACT_AVAILABILITY_FALSE, "false" },


            { IDMEFV2_IMPACT_AVAILABILITY_UNKNOWN, "unknown" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_availability", name);

}
/**
 * idmefv2_impact_availability_to_string:
 * @val: an enumeration value for #idmefv2_impact_availability_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_availability_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_availability_to_string(idmefv2_impact_availability_t val)
{

        const struct {
              idmefv2_impact_availability_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_AVAILABILITY_TRUE, "true" },

            { IDMEFV2_IMPACT_AVAILABILITY_FALSE, "false" },

            { IDMEFV2_IMPACT_AVAILABILITY_UNKNOWN, "unknown" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_impact_integrity_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_integrity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_integrity_t idmefv2_impact_integrity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_integrity_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_INTEGRITY_TRUE, "true" },


            { IDMEFV2_IMPACT_INTEGRITY_FALSE, "false" },


            { IDMEFV2_IMPACT_INTEGRITY_UNKNOWN, "unknown" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_integrity", name);

}
/**
 * idmefv2_impact_integrity_to_string:
 * @val: an enumeration value for #idmefv2_impact_integrity_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_integrity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_integrity_to_string(idmefv2_impact_integrity_t val)
{

        const struct {
              idmefv2_impact_integrity_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_INTEGRITY_TRUE, "true" },

            { IDMEFV2_IMPACT_INTEGRITY_FALSE, "false" },

            { IDMEFV2_IMPACT_INTEGRITY_UNKNOWN, "unknown" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * idmefv2_impact_confidentiality_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_impact_confidentiality_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_impact_confidentiality_t idmefv2_impact_confidentiality_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_impact_confidentiality_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_CONFIDENTIALITY_TRUE, "true" },


            { IDMEFV2_IMPACT_CONFIDENTIALITY_FALSE, "false" },


            { IDMEFV2_IMPACT_CONFIDENTIALITY_UNKNOWN, "unknown" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_confidentiality", name);

}
/**
 * idmefv2_impact_confidentiality_to_string:
 * @val: an enumeration value for #idmefv2_impact_confidentiality_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_impact_confidentiality_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_impact_confidentiality_to_string(idmefv2_impact_confidentiality_t val)
{

        const struct {
              idmefv2_impact_confidentiality_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_IMPACT_CONFIDENTIALITY_TRUE, "true" },

            { IDMEFV2_IMPACT_CONFIDENTIALITY_FALSE, "false" },

            { IDMEFV2_IMPACT_CONFIDENTIALITY_UNKNOWN, "unknown" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_impact {

         IDMEFV2_OBJECT;
         REFCOUNT;
         idmefv2_impact_severity_t severity;
         idmefv2_impact_completion_t completion;
         idmefv2_impact_availability_t availability;
         idmefv2_impact_integrity_t integrity;
         idmefv2_impact_confidentiality_t confidentiality;
         libidmefv2_string_t *description;
        LISTED_OBJECT(impact_type_list, idmefv2_impact_type_t);
};



        
/**
 * idmefv2_recommanded_action_action_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_recommanded_action_action_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_recommanded_action_action_t idmefv2_recommanded_action_action_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_recommanded_action_action_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_NOTHING, "nothing" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_SENDER, "contact-sender" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_INVESTIGATE, "investigate" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_HOST, "block-host" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_NETWORK, "block-network" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_PORT, "block-port" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REDIRECT_TRAFFIC, "redirect-traffic" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_HONEYPOT, "honeypot" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_UPGRADE_SOFTWARE, "upgrade-software" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REBUILD_ASSET, "rebuild-asset" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_HARDEN_ASSET, "harden-asset" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REMEDIATE_OTHER, "remediate-other" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_STATUS_TRIAGE, "status-triage" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_STATUS_NEW_INFO, "status-new-info" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_WATCH_AND_REPORT, "watch-and-report" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_TRAINING, "training" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_OTHER, "other" },


            { IDMEFV2_RECOMMANDED_ACTION_ACTION_EXT_VALUE, "ext-value" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for recommanded_action_action", name);

}
/**
 * idmefv2_recommanded_action_action_to_string:
 * @val: an enumeration value for #idmefv2_recommanded_action_action_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_recommanded_action_action_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_recommanded_action_action_to_string(idmefv2_recommanded_action_action_t val)
{

        const struct {
              idmefv2_recommanded_action_action_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_NOTHING, "nothing" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_CONTACT_SENDER, "contact-sender" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_INVESTIGATE, "investigate" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_HOST, "block-host" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_NETWORK, "block-network" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_BLOCK_PORT, "block-port" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REDIRECT_TRAFFIC, "redirect-traffic" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_HONEYPOT, "honeypot" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_UPGRADE_SOFTWARE, "upgrade-software" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REBUILD_ASSET, "rebuild-asset" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_HARDEN_ASSET, "harden-asset" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_REMEDIATE_OTHER, "remediate-other" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_STATUS_TRIAGE, "status-triage" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_STATUS_NEW_INFO, "status-new-info" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_WATCH_AND_REPORT, "watch-and-report" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_TRAINING, "training" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_OTHER, "other" },

            { IDMEFV2_RECOMMANDED_ACTION_ACTION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_recommanded_action {

         IDMEFV2_LINKED_OBJECT;
         REFCOUNT;
         idmefv2_recommanded_action_action_t action;
         OPTIONAL_INT(uint32_t, step);
};



        


struct idmefv2_assessment {

         IDMEFV2_OBJECT;
         REFCOUNT;
         idmefv2_impact_t *impact;
        LISTED_OBJECT(taken_action_list, idmefv2_taken_action_t);
         idmefv2_confidence_t *confidence;
        LISTED_OBJECT(recommanded_action_list, idmefv2_recommanded_action_t);
};



        


struct idmefv2_classification {

         IDMEFV2_OBJECT;
         REFCOUNT;
         libidmefv2_string_t *ident;
        REQUIRED(libidmefv2_string_t, *text);
        LISTED_OBJECT(reference_list, idmefv2_reference_t);
};



        


struct idmefv2_heartbeat {

         IDMEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *messageid);
         idmefv2_analyzer_t *analyzer;
        REQUIRED(idmefv2_time_t, *create_time);
         OPTIONAL_INT(uint32_t, heartbeat_interval);
        KEYLISTED_OBJECT(additional_data_list, idmefv2_additional_data_t);
};



        
/**
 * idmefv2_alert_type_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_alert_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_alert_type_t idmefv2_alert_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_alert_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ALERT_TYPE_DEFAULT, "default" },


            { IDMEFV2_ALERT_TYPE_CORRELATION, "correlation" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for alert_type", name);

}
/**
 * idmefv2_alert_type_to_string:
 * @val: an enumeration value for #idmefv2_alert_type_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_alert_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_alert_type_to_string(idmefv2_alert_type_t val)
{

        const struct {
              idmefv2_alert_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_ALERT_TYPE_DEFAULT, "default" },

            { IDMEFV2_ALERT_TYPE_CORRELATION, "correlation" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_alert {

         IDMEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *messageid);
        REQUIRED(libidmefv2_string_t, *analyzerhash);
        LISTED_OBJECT(analyzer_list, idmefv2_analyzer_t);
        REQUIRED(idmefv2_time_t, *create_time);
        REQUIRED(idmefv2_classification_t, *classification);
         idmefv2_time_t *detect_time;
         idmefv2_analysis_data_t *analysis_data;
        LISTED_OBJECT(source_list, idmefv2_source_t);
        LISTED_OBJECT(target_list, idmefv2_target_t);
         idmefv2_assessment_t *assessment;
        KEYLISTED_OBJECT(additional_data_list, idmefv2_additional_data_t);
         UNION(idmefv2_alert_type_t, type) {
                    UNION_MEMBER(IDMEFV2_ALERT_TYPE_CORRELATION, idmefv2_correlation_alert_t, *correlation_alert);
        } detail;
};



        
/**
 * idmefv2_message_type_to_numeric:
 * @name: pointer to an IDMEFV2 string representation of a #idmefv2_message_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmefv2_message_type_t idmefv2_message_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              idmefv2_message_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_MESSAGE_TYPE_DEFAULT, "default" },


            { IDMEFV2_MESSAGE_TYPE_ALERT, "alert" },


            { IDMEFV2_MESSAGE_TYPE_HEARTBEAT, "heartbeat" },

        };

        libidmefv2_return_val_if_fail(name, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libidmefv2_error_verbose(LIBIDMEFV2_ERROR_IDMEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for message_type", name);

}
/**
 * idmefv2_message_type_to_string:
 * @val: an enumeration value for #idmefv2_message_type_t.
 *
 * Return the IDMEFV2 string equivalent of @val provided #idmefv2_message_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmefv2_message_type_to_string(idmefv2_message_type_t val)
{

        const struct {
              idmefv2_message_type_t val;
              const char *name;
        } tbl[] = {

            { IDMEFV2_MESSAGE_TYPE_DEFAULT, "default" },

            { IDMEFV2_MESSAGE_TYPE_ALERT, "alert" },

            { IDMEFV2_MESSAGE_TYPE_HEARTBEAT, "heartbeat" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct idmefv2_message {

         IDMEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libidmefv2_string_t, *version);
         UNION(idmefv2_message_type_t, type) {
                    UNION_MEMBER(IDMEFV2_MESSAGE_TYPE_ALERT, idmefv2_alert_t, *alert);
                    UNION_MEMBER(IDMEFV2_MESSAGE_TYPE_HEARTBEAT, idmefv2_heartbeat_t, *heartbeat);
        } message;
};



        



/**
 * idmefv2_address_new:
 * @ret: Pointer where to store the created #idmefv2_address_t object.
 *
 * Create a new #idmefv2_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_address_new(idmefv2_address_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ADDRESS;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








        {
            int retval = libidmefv2_string_new(&(*ret)->address);

            if ( retval < 0 ) {
                    idmefv2_address_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * idmefv2_address_ref:
 * @address: pointer to a #idmefv2_address_t object.
 *
 * Increase @address reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @address.
 */
idmefv2_address_t *idmefv2_address_ref(idmefv2_address_t *address)
{
        libidmefv2_return_val_if_fail(address, NULL);
        address->refcount++;

        return address;
}



int _idmefv2_address_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_address_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_ADDRESS_TRANSLATION , ptr->translation);

            case 2:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_ADDRESS_CATEGORY , ptr->category);


            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->vlan_name, TRUE);


            case 4:
                         return (ptr->vlan_num_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->vlan_num) : 0;


            case 5:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->address, TRUE);



            case 6:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->netmask, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_address_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_address_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_address_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_address_new_translation(ptr, (idmefv2_address_translation_t **) ret);

                case 2:
                    return idmefv2_address_new_category(ptr, (idmefv2_address_category_t **) ret);

                case 3:
                    return idmefv2_address_new_vlan_name(ptr, (libidmefv2_string_t **) ret);

                case 4:
                    return idmefv2_address_new_vlan_num(ptr, (uint32_t **) ret);

                case 5:
                    return idmefv2_address_new_address(ptr, (libidmefv2_string_t **) ret);

                case 6:
                    return idmefv2_address_new_netmask(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_address_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_address_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                    ptr->translation = 0;
                    return 0;




                case 2:
                    ptr->category = 0;
                    return 0;




                case 3:
                        if ( ptr->vlan_name ) {
                                libidmefv2_string_destroy(ptr->vlan_name);
                                ptr->vlan_name = NULL;
                        }

                        return 0;

                case 4:
                        ptr->vlan_num_is_set = 0;
                        return 0;




                case 5:
                        if ( ptr->address ) {
                                libidmefv2_string_destroy(ptr->address);
                                ptr->address = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->netmask ) {
                                libidmefv2_string_destroy(ptr->netmask);
                                ptr->netmask = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_address_destroy_internal(idmefv2_address_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }







        if ( ptr->vlan_name ) {
                libidmefv2_string_destroy(ptr->vlan_name);
                ptr->vlan_name = NULL;
        }





        if ( ptr->address ) {
                libidmefv2_string_destroy(ptr->address);
                ptr->address = NULL;
        }



        if ( ptr->netmask ) {
                libidmefv2_string_destroy(ptr->netmask);
                ptr->netmask = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_address_destroy:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_address_destroy(idmefv2_address_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_address_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_address_get_ident:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get ident children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_address_get_ident(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_address_set_ident:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_address_set_ident(idmefv2_address_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_address_new_ident:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_address_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_ident(idmefv2_address_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}



/**
 * idmefv2_address_get_translation:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get translation children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a idmefv2_address_translation_t object, or NULL if the children object is not set.
 */
idmefv2_address_translation_t idmefv2_address_get_translation(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->translation;

}


/**
 * idmefv2_address_set_translation:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @translation: pointer to a #idmefv2_address_translation_t object.
 *
 * Set @translation object as a children of @ptr.
 * if @ptr already contain an @translation object, then it is destroyed,
 * and updated to point to the provided @translation object.
 */
void idmefv2_address_set_translation(idmefv2_address_t *ptr, idmefv2_address_translation_t translation)
{
        libidmefv2_return_if_fail(ptr);
        ptr->translation = translation;
}
/**
 * idmefv2_address_new_translation:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #idmefv2_address_translation_t object.
 *
 * Create a new translation object, children of #idmefv2_address_t.
 * If @ptr already contain a #idmefv2_address_translation_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_translation(idmefv2_address_t *ptr, idmefv2_address_translation_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->translation;
        return 0;
}



/**
 * idmefv2_address_get_category:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get category children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a idmefv2_address_category_t object, or NULL if the children object is not set.
 */
idmefv2_address_category_t idmefv2_address_get_category(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_address_set_category:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @category: pointer to a #idmefv2_address_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_address_set_category(idmefv2_address_t *ptr, idmefv2_address_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_address_new_category:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #idmefv2_address_category_t object.
 *
 * Create a new category object, children of #idmefv2_address_t.
 * If @ptr already contain a #idmefv2_address_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_category(idmefv2_address_t *ptr, idmefv2_address_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_address_get_vlan_name:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get vlan_name children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_address_get_vlan_name(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_name;

}


/**
 * idmefv2_address_set_vlan_name:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @vlan_name: pointer to a #libidmefv2_string_t object.
 *
 * Set @vlan_name object as a children of @ptr.
 * if @ptr already contain an @vlan_name object, then it is destroyed,
 * and updated to point to the provided @vlan_name object.
 */

void idmefv2_address_set_vlan_name(idmefv2_address_t *ptr, libidmefv2_string_t *vlan_name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->vlan_name )
                libidmefv2_string_destroy(ptr->vlan_name);

        ptr->vlan_name = vlan_name;
}
/**
 * idmefv2_address_new_vlan_name:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new vlan_name object, children of #idmefv2_address_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_vlan_name(idmefv2_address_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->vlan_name ) {
                retval = libidmefv2_string_new(&ptr->vlan_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->vlan_name;
        return 0;
}




/**
 * idmefv2_address_get_vlan_num:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get vlan_num children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_address_get_vlan_num(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_num_is_set ? &ptr->vlan_num : NULL;


}


/**
 * idmefv2_address_set_vlan_num:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @vlan_num: pointer to a #uint32_t object.
 *
 * Set @vlan_num object as a children of @ptr.
 * if @ptr already contain an @vlan_num object, then it is destroyed,
 * and updated to point to the provided @vlan_num object.
 */
void idmefv2_address_set_vlan_num(idmefv2_address_t *ptr, uint32_t vlan_num)
{
        libidmefv2_return_if_fail(ptr);
        ptr->vlan_num = vlan_num;
        ptr->vlan_num_is_set = 1;
}

void idmefv2_address_unset_vlan_num(idmefv2_address_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->vlan_num_is_set = 0;
}
/**
 * idmefv2_address_new_vlan_num:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new vlan_num object, children of #idmefv2_address_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_vlan_num(idmefv2_address_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->vlan_num_is_set = 1;



        *ret = &ptr->vlan_num;
        return 0;
}




/**
 * idmefv2_address_get_address:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get address children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_address_get_address(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->address;

}


/**
 * idmefv2_address_set_address:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @address: pointer to a #libidmefv2_string_t object.
 *
 * Set @address object as a children of @ptr.
 * if @ptr already contain an @address object, then it is destroyed,
 * and updated to point to the provided @address object.
 */

void idmefv2_address_set_address(idmefv2_address_t *ptr, libidmefv2_string_t *address)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->address )
                libidmefv2_string_destroy(ptr->address);

        ptr->address = address;
}
/**
 * idmefv2_address_new_address:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new address object, children of #idmefv2_address_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_address(idmefv2_address_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->address ) {
                retval = libidmefv2_string_new(&ptr->address);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->address;
        return 0;
}




/**
 * idmefv2_address_get_netmask:
 * @ptr: pointer to a #idmefv2_address_t object.
 *
 * Get netmask children of the #idmefv2_address_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_address_get_netmask(idmefv2_address_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->netmask;

}


/**
 * idmefv2_address_set_netmask:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @netmask: pointer to a #libidmefv2_string_t object.
 *
 * Set @netmask object as a children of @ptr.
 * if @ptr already contain an @netmask object, then it is destroyed,
 * and updated to point to the provided @netmask object.
 */

void idmefv2_address_set_netmask(idmefv2_address_t *ptr, libidmefv2_string_t *netmask)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->netmask )
                libidmefv2_string_destroy(ptr->netmask);

        ptr->netmask = netmask;
}
/**
 * idmefv2_address_new_netmask:
 * @ptr: pointer to a #idmefv2_address_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new netmask object, children of #idmefv2_address_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_address_new_netmask(idmefv2_address_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->netmask ) {
                retval = libidmefv2_string_new(&ptr->netmask);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->netmask;
        return 0;
}



/**
 * idmefv2_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_address_copy(const idmefv2_address_t *src, idmefv2_address_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }




        dst->translation = src->translation;



        dst->category = src->category;



        if ( dst->vlan_name ) {
                libidmefv2_string_destroy(dst->vlan_name);
                dst->vlan_name = NULL;
        }

        if ( src->vlan_name ) {
                ret = libidmefv2_string_clone(src->vlan_name, &dst->vlan_name);
                if ( ret < 0 )
                        return ret;
        }



        dst->vlan_num_is_set = src->vlan_num_is_set;
        dst->vlan_num = src->vlan_num;


        if ( src->address ) {
                ret = libidmefv2_string_copy(src->address, dst->address);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->netmask ) {
                libidmefv2_string_destroy(dst->netmask);
                dst->netmask = NULL;
        }

        if ( src->netmask ) {
                ret = libidmefv2_string_clone(src->netmask, &dst->netmask);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_address_clone(idmefv2_address_t *src, idmefv2_address_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_address_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_address_copy(src, *dst);
}


/**
 * idmefv2_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_address_compare(const idmefv2_address_t *obj1, const idmefv2_address_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        if ( obj1->translation != obj2->translation )
                return -1;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->vlan_name, obj2->vlan_name);
        if ( ret != 0 )
                return ret;

        if ( obj1->vlan_num_is_set != obj2->vlan_num_is_set )
                return -1;

        if ( obj1->vlan_num_is_set && obj1->vlan_num != obj2->vlan_num )
                return -1;


        ret = libidmefv2_string_compare(obj1->address, obj2->address);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->netmask, obj2->netmask);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_user_id_new:
 * @ret: Pointer where to store the created #idmefv2_user_id_t object.
 *
 * Create a new #idmefv2_user_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_id_new(idmefv2_user_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_USER_ID;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;






            return 0;
}


/**
 * idmefv2_user_id_ref:
 * @user_id: pointer to a #idmefv2_user_id_t object.
 *
 * Increase @user_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @user_id.
 */
idmefv2_user_id_t *idmefv2_user_id_ref(idmefv2_user_id_t *user_id)
{
        libidmefv2_return_val_if_fail(user_id, NULL);
        user_id->refcount++;

        return user_id;
}



int _idmefv2_user_id_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_user_id_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_USER_ID_CATEGORY , ptr->category);


            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->tty, TRUE);



            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 4:
                         return (ptr->number_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->number) : 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_user_id_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_user_id_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_user_id_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_user_id_new_category(ptr, (idmefv2_user_id_category_t **) ret);

                case 2:
                    return idmefv2_user_id_new_tty(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_user_id_new_name(ptr, (libidmefv2_string_t **) ret);

                case 4:
                    return idmefv2_user_id_new_number(ptr, (uint32_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_user_id_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_user_id_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                    ptr->category = 0;
                    return 0;




                case 2:
                        if ( ptr->tty ) {
                                libidmefv2_string_destroy(ptr->tty);
                                ptr->tty = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 4:
                        ptr->number_is_set = 0;
                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_user_id_destroy_internal(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }





        if ( ptr->tty ) {
                libidmefv2_string_destroy(ptr->tty);
                ptr->tty = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * idmefv2_user_id_destroy:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_user_id_destroy(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_user_id_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_user_id_get_ident:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Get ident children of the #idmefv2_user_id_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_user_id_get_ident(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_user_id_set_ident:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_user_id_set_ident(idmefv2_user_id_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_user_id_new_ident:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_user_id_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_id_new_ident(idmefv2_user_id_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}



/**
 * idmefv2_user_id_get_category:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Get category children of the #idmefv2_user_id_t object.
 *
 * Returns: a pointer to a idmefv2_user_id_category_t object, or NULL if the children object is not set.
 */
idmefv2_user_id_category_t idmefv2_user_id_get_category(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_user_id_set_category:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @category: pointer to a #idmefv2_user_id_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_user_id_set_category(idmefv2_user_id_t *ptr, idmefv2_user_id_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_user_id_new_category:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ret: pointer to an address where to store the created #idmefv2_user_id_category_t object.
 *
 * Create a new category object, children of #idmefv2_user_id_t.
 * If @ptr already contain a #idmefv2_user_id_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_id_new_category(idmefv2_user_id_t *ptr, idmefv2_user_id_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_user_id_get_tty:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Get tty children of the #idmefv2_user_id_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_user_id_get_tty(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->tty;

}


/**
 * idmefv2_user_id_set_tty:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @tty: pointer to a #libidmefv2_string_t object.
 *
 * Set @tty object as a children of @ptr.
 * if @ptr already contain an @tty object, then it is destroyed,
 * and updated to point to the provided @tty object.
 */

void idmefv2_user_id_set_tty(idmefv2_user_id_t *ptr, libidmefv2_string_t *tty)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->tty )
                libidmefv2_string_destroy(ptr->tty);

        ptr->tty = tty;
}
/**
 * idmefv2_user_id_new_tty:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new tty object, children of #idmefv2_user_id_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_id_new_tty(idmefv2_user_id_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->tty ) {
                retval = libidmefv2_string_new(&ptr->tty);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->tty;
        return 0;
}




/**
 * idmefv2_user_id_get_name:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Get name children of the #idmefv2_user_id_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_user_id_get_name(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_user_id_set_name:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_user_id_set_name(idmefv2_user_id_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_user_id_new_name:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_user_id_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_id_new_name(idmefv2_user_id_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_user_id_get_number:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 *
 * Get number children of the #idmefv2_user_id_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_user_id_get_number(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->number_is_set ? &ptr->number : NULL;


}


/**
 * idmefv2_user_id_set_number:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @number: pointer to a #uint32_t object.
 *
 * Set @number object as a children of @ptr.
 * if @ptr already contain an @number object, then it is destroyed,
 * and updated to point to the provided @number object.
 */
void idmefv2_user_id_set_number(idmefv2_user_id_t *ptr, uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}

void idmefv2_user_id_unset_number(idmefv2_user_id_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number_is_set = 0;
}
/**
 * idmefv2_user_id_new_number:
 * @ptr: pointer to a #idmefv2_user_id_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new number object, children of #idmefv2_user_id_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_id_new_number(idmefv2_user_id_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->number_is_set = 1;



        *ret = &ptr->number;
        return 0;
}



/**
 * idmefv2_user_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_id_copy(const idmefv2_user_id_t *src, idmefv2_user_id_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }




        dst->category = src->category;



        if ( dst->tty ) {
                libidmefv2_string_destroy(dst->tty);
                dst->tty = NULL;
        }

        if ( src->tty ) {
                ret = libidmefv2_string_clone(src->tty, &dst->tty);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->name ) {
                libidmefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libidmefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }



        dst->number_is_set = src->number_is_set;
        dst->number = src->number;
    return 0 ;
}


/**
 * idmefv2_user_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_id_clone(idmefv2_user_id_t *src, idmefv2_user_id_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_user_id_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_user_id_copy(src, *dst);
}


/**
 * idmefv2_user_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_user_id_compare(const idmefv2_user_id_t *obj1, const idmefv2_user_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->tty, obj2->tty);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        if ( obj1->number_is_set != obj2->number_is_set )
                return -1;

        if ( obj1->number_is_set && obj1->number != obj2->number )
                return -1;

        return ret;
}


        



/**
 * idmefv2_node_name_new:
 * @ret: Pointer where to store the created #idmefv2_node_name_t object.
 *
 * Create a new #idmefv2_node_name_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_name_new(idmefv2_node_name_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_NODE_NAME;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_node_name_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_node_name_ref:
 * @node_name: pointer to a #idmefv2_node_name_t object.
 *
 * Increase @node_name reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node_name.
 */
idmefv2_node_name_t *idmefv2_node_name_ref(idmefv2_node_name_t *node_name)
{
        libidmefv2_return_val_if_fail(node_name, NULL);
        node_name->refcount++;

        return node_name;
}



int _idmefv2_node_name_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_node_name_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_NODE_NAME_CATEGORY , ptr->category);


            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_node_name_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_node_name_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_node_name_new_category(ptr, (idmefv2_node_name_category_t **) ret);

                case 1:
                    return idmefv2_node_name_new_name(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_node_name_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_node_name_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_node_name_destroy_internal(idmefv2_node_name_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_node_name_destroy:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_node_name_destroy(idmefv2_node_name_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_node_name_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_node_name_get_category:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 *
 * Get category children of the #idmefv2_node_name_t object.
 *
 * Returns: a pointer to a idmefv2_node_name_category_t object, or NULL if the children object is not set.
 */
idmefv2_node_name_category_t idmefv2_node_name_get_category(idmefv2_node_name_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_node_name_set_category:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 * @category: pointer to a #idmefv2_node_name_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_node_name_set_category(idmefv2_node_name_t *ptr, idmefv2_node_name_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_node_name_new_category:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 * @ret: pointer to an address where to store the created #idmefv2_node_name_category_t object.
 *
 * Create a new category object, children of #idmefv2_node_name_t.
 * If @ptr already contain a #idmefv2_node_name_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_name_new_category(idmefv2_node_name_t *ptr, idmefv2_node_name_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_node_name_get_name:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 *
 * Get name children of the #idmefv2_node_name_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_node_name_get_name(idmefv2_node_name_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_node_name_set_name:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_node_name_set_name(idmefv2_node_name_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_node_name_new_name:
 * @ptr: pointer to a #idmefv2_node_name_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_node_name_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_name_new_name(idmefv2_node_name_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}



/**
 * idmefv2_node_name_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_node_name_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_name_copy(const idmefv2_node_name_t *src, idmefv2_node_name_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_node_name_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_name_clone(idmefv2_node_name_t *src, idmefv2_node_name_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_node_name_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_node_name_copy(src, *dst);
}


/**
 * idmefv2_node_name_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_node_name_compare(const idmefv2_node_name_t *obj1, const idmefv2_node_name_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_location_new:
 * @ret: Pointer where to store the created #idmefv2_location_t object.
 *
 * Create a new #idmefv2_location_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_location_new(idmefv2_location_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_LOCATION;


        (*ret)->refcount = 1;







            return 0;
}


/**
 * idmefv2_location_ref:
 * @location: pointer to a #idmefv2_location_t object.
 *
 * Increase @location reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @location.
 */
idmefv2_location_t *idmefv2_location_ref(idmefv2_location_t *location)
{
        libidmefv2_return_val_if_fail(location, NULL);
        location->refcount++;

        return location;
}



int _idmefv2_location_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_location_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 1:
                         return (ptr->latitude_is_set) ? idmefv2_value_new_float((idmefv2_value_t **) childptr, ptr->latitude) : 0;

            case 2:
                         return (ptr->longitude_is_set) ? idmefv2_value_new_float((idmefv2_value_t **) childptr, ptr->longitude) : 0;

            case 3:
                         return (ptr->altitude_is_set) ? idmefv2_value_new_float((idmefv2_value_t **) childptr, ptr->altitude) : 0;


            case 4:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->country, TRUE);



            case 5:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->city, TRUE);



            case 6:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->postcode, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_location_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_location_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_location_new_name(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_location_new_latitude(ptr, (float **) ret);

                case 2:
                    return idmefv2_location_new_longitude(ptr, (float **) ret);

                case 3:
                    return idmefv2_location_new_altitude(ptr, (float **) ret);

                case 4:
                    return idmefv2_location_new_country(ptr, (libidmefv2_string_t **) ret);

                case 5:
                    return idmefv2_location_new_city(ptr, (libidmefv2_string_t **) ret);

                case 6:
                    return idmefv2_location_new_postcode(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_location_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_location_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 1:
                        ptr->latitude_is_set = 0;
                        return 0;

                case 2:
                        ptr->longitude_is_set = 0;
                        return 0;

                case 3:
                        ptr->altitude_is_set = 0;
                        return 0;




                case 4:
                        if ( ptr->country ) {
                                libidmefv2_string_destroy(ptr->country);
                                ptr->country = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->city ) {
                                libidmefv2_string_destroy(ptr->city);
                                ptr->city = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->postcode ) {
                                libidmefv2_string_destroy(ptr->postcode);
                                ptr->postcode = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_location_destroy_internal(idmefv2_location_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }









        if ( ptr->country ) {
                libidmefv2_string_destroy(ptr->country);
                ptr->country = NULL;
        }



        if ( ptr->city ) {
                libidmefv2_string_destroy(ptr->city);
                ptr->city = NULL;
        }



        if ( ptr->postcode ) {
                libidmefv2_string_destroy(ptr->postcode);
                ptr->postcode = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_location_destroy:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_location_destroy(idmefv2_location_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_location_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_location_get_name:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get name children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_location_get_name(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_location_set_name:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_location_set_name(idmefv2_location_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_location_new_name:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_location_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_name(idmefv2_location_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_location_get_latitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get latitude children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a float object, or NULL if the children object is not set.
 */
float *idmefv2_location_get_latitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->latitude_is_set ? &ptr->latitude : NULL;


}


/**
 * idmefv2_location_set_latitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @latitude: pointer to a #float object.
 *
 * Set @latitude object as a children of @ptr.
 * if @ptr already contain an @latitude object, then it is destroyed,
 * and updated to point to the provided @latitude object.
 */
void idmefv2_location_set_latitude(idmefv2_location_t *ptr, float latitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->latitude = latitude;
        ptr->latitude_is_set = 1;
}

void idmefv2_location_unset_latitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->latitude_is_set = 0;
}
/**
 * idmefv2_location_new_latitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #float object.
 *
 * Create a new latitude object, children of #idmefv2_location_t.
 * If @ptr already contain a #float object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_latitude(idmefv2_location_t *ptr, float **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->latitude_is_set = 1;



        *ret = &ptr->latitude;
        return 0;
}




/**
 * idmefv2_location_get_longitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get longitude children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a float object, or NULL if the children object is not set.
 */
float *idmefv2_location_get_longitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->longitude_is_set ? &ptr->longitude : NULL;


}


/**
 * idmefv2_location_set_longitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @longitude: pointer to a #float object.
 *
 * Set @longitude object as a children of @ptr.
 * if @ptr already contain an @longitude object, then it is destroyed,
 * and updated to point to the provided @longitude object.
 */
void idmefv2_location_set_longitude(idmefv2_location_t *ptr, float longitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->longitude = longitude;
        ptr->longitude_is_set = 1;
}

void idmefv2_location_unset_longitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->longitude_is_set = 0;
}
/**
 * idmefv2_location_new_longitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #float object.
 *
 * Create a new longitude object, children of #idmefv2_location_t.
 * If @ptr already contain a #float object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_longitude(idmefv2_location_t *ptr, float **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->longitude_is_set = 1;



        *ret = &ptr->longitude;
        return 0;
}




/**
 * idmefv2_location_get_altitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get altitude children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a float object, or NULL if the children object is not set.
 */
float *idmefv2_location_get_altitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->altitude_is_set ? &ptr->altitude : NULL;


}


/**
 * idmefv2_location_set_altitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @altitude: pointer to a #float object.
 *
 * Set @altitude object as a children of @ptr.
 * if @ptr already contain an @altitude object, then it is destroyed,
 * and updated to point to the provided @altitude object.
 */
void idmefv2_location_set_altitude(idmefv2_location_t *ptr, float altitude)
{
        libidmefv2_return_if_fail(ptr);
        ptr->altitude = altitude;
        ptr->altitude_is_set = 1;
}

void idmefv2_location_unset_altitude(idmefv2_location_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->altitude_is_set = 0;
}
/**
 * idmefv2_location_new_altitude:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #float object.
 *
 * Create a new altitude object, children of #idmefv2_location_t.
 * If @ptr already contain a #float object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_altitude(idmefv2_location_t *ptr, float **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->altitude_is_set = 1;



        *ret = &ptr->altitude;
        return 0;
}




/**
 * idmefv2_location_get_country:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get country children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_location_get_country(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->country;

}


/**
 * idmefv2_location_set_country:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @country: pointer to a #libidmefv2_string_t object.
 *
 * Set @country object as a children of @ptr.
 * if @ptr already contain an @country object, then it is destroyed,
 * and updated to point to the provided @country object.
 */

void idmefv2_location_set_country(idmefv2_location_t *ptr, libidmefv2_string_t *country)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->country )
                libidmefv2_string_destroy(ptr->country);

        ptr->country = country;
}
/**
 * idmefv2_location_new_country:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new country object, children of #idmefv2_location_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_country(idmefv2_location_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->country ) {
                retval = libidmefv2_string_new(&ptr->country);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->country;
        return 0;
}




/**
 * idmefv2_location_get_city:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get city children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_location_get_city(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->city;

}


/**
 * idmefv2_location_set_city:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @city: pointer to a #libidmefv2_string_t object.
 *
 * Set @city object as a children of @ptr.
 * if @ptr already contain an @city object, then it is destroyed,
 * and updated to point to the provided @city object.
 */

void idmefv2_location_set_city(idmefv2_location_t *ptr, libidmefv2_string_t *city)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->city )
                libidmefv2_string_destroy(ptr->city);

        ptr->city = city;
}
/**
 * idmefv2_location_new_city:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new city object, children of #idmefv2_location_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_city(idmefv2_location_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->city ) {
                retval = libidmefv2_string_new(&ptr->city);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->city;
        return 0;
}




/**
 * idmefv2_location_get_postcode:
 * @ptr: pointer to a #idmefv2_location_t object.
 *
 * Get postcode children of the #idmefv2_location_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_location_get_postcode(idmefv2_location_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->postcode;

}


/**
 * idmefv2_location_set_postcode:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @postcode: pointer to a #libidmefv2_string_t object.
 *
 * Set @postcode object as a children of @ptr.
 * if @ptr already contain an @postcode object, then it is destroyed,
 * and updated to point to the provided @postcode object.
 */

void idmefv2_location_set_postcode(idmefv2_location_t *ptr, libidmefv2_string_t *postcode)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->postcode )
                libidmefv2_string_destroy(ptr->postcode);

        ptr->postcode = postcode;
}
/**
 * idmefv2_location_new_postcode:
 * @ptr: pointer to a #idmefv2_location_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new postcode object, children of #idmefv2_location_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_location_new_postcode(idmefv2_location_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->postcode ) {
                retval = libidmefv2_string_new(&ptr->postcode);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->postcode;
        return 0;
}



/**
 * idmefv2_location_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_location_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_location_copy(const idmefv2_location_t *src, idmefv2_location_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->name ) {
                libidmefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libidmefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }



        dst->latitude_is_set = src->latitude_is_set;
        dst->latitude = src->latitude;


        dst->longitude_is_set = src->longitude_is_set;
        dst->longitude = src->longitude;


        dst->altitude_is_set = src->altitude_is_set;
        dst->altitude = src->altitude;



        if ( dst->country ) {
                libidmefv2_string_destroy(dst->country);
                dst->country = NULL;
        }

        if ( src->country ) {
                ret = libidmefv2_string_clone(src->country, &dst->country);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->city ) {
                libidmefv2_string_destroy(dst->city);
                dst->city = NULL;
        }

        if ( src->city ) {
                ret = libidmefv2_string_clone(src->city, &dst->city);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->postcode ) {
                libidmefv2_string_destroy(dst->postcode);
                dst->postcode = NULL;
        }

        if ( src->postcode ) {
                ret = libidmefv2_string_clone(src->postcode, &dst->postcode);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_location_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_location_clone(idmefv2_location_t *src, idmefv2_location_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_location_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_location_copy(src, *dst);
}


/**
 * idmefv2_location_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_location_compare(const idmefv2_location_t *obj1, const idmefv2_location_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        if ( obj1->latitude_is_set != obj2->latitude_is_set )
                return -1;

        if ( obj1->latitude_is_set && obj1->latitude != obj2->latitude )
                return -1;


        if ( obj1->longitude_is_set != obj2->longitude_is_set )
                return -1;

        if ( obj1->longitude_is_set && obj1->longitude != obj2->longitude )
                return -1;


        if ( obj1->altitude_is_set != obj2->altitude_is_set )
                return -1;

        if ( obj1->altitude_is_set && obj1->altitude != obj2->altitude )
                return -1;


        ret = libidmefv2_string_compare(obj1->country, obj2->country);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->city, obj2->city);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->postcode, obj2->postcode);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_interface_new:
 * @ret: Pointer where to store the created #idmefv2_interface_t object.
 *
 * Create a new #idmefv2_interface_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_interface_new(idmefv2_interface_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_INTERFACE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->address_list);







            return 0;
}


/**
 * idmefv2_interface_ref:
 * @interface: pointer to a #idmefv2_interface_t object.
 *
 * Increase @interface reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @interface.
 */
idmefv2_interface_t *idmefv2_interface_ref(idmefv2_interface_t *interface)
{
        libidmefv2_return_val_if_fail(interface, NULL);
        interface->refcount++;

        return interface;
}



int _idmefv2_interface_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_interface_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_INTERFACE_CATEGORY , ptr->category);


            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->meaning, TRUE);


            case 3:
                *childptr = &ptr->address_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_interface_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_interface_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_interface_new_name(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_interface_new_category(ptr, (idmefv2_interface_category_t **) ret);

                case 2:
                    return idmefv2_interface_new_meaning(ptr, (libidmefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_interface_new_address(ptr, (idmefv2_address_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->address_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_interface_new_address(ptr, (idmefv2_address_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_interface_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_interface_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 1:
                    ptr->category = 0;
                    return 0;




                case 2:
                        if ( ptr->meaning ) {
                                libidmefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->address_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_address_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_address_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_interface_destroy_internal(idmefv2_interface_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }





        if ( ptr->meaning ) {
                libidmefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_address_t *entry;

                libidmefv2_list_for_each_safe(&ptr->address_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_address_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_interface_destroy:
 * @ptr: pointer to a #idmefv2_interface_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_interface_destroy(idmefv2_interface_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_interface_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_interface_get_name:
 * @ptr: pointer to a #idmefv2_interface_t object.
 *
 * Get name children of the #idmefv2_interface_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_interface_get_name(idmefv2_interface_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_interface_set_name:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_interface_set_name(idmefv2_interface_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_interface_new_name:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_interface_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_interface_new_name(idmefv2_interface_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}



/**
 * idmefv2_interface_get_category:
 * @ptr: pointer to a #idmefv2_interface_t object.
 *
 * Get category children of the #idmefv2_interface_t object.
 *
 * Returns: a pointer to a idmefv2_interface_category_t object, or NULL if the children object is not set.
 */
idmefv2_interface_category_t idmefv2_interface_get_category(idmefv2_interface_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_interface_set_category:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @category: pointer to a #idmefv2_interface_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_interface_set_category(idmefv2_interface_t *ptr, idmefv2_interface_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_interface_new_category:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @ret: pointer to an address where to store the created #idmefv2_interface_category_t object.
 *
 * Create a new category object, children of #idmefv2_interface_t.
 * If @ptr already contain a #idmefv2_interface_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_interface_new_category(idmefv2_interface_t *ptr, idmefv2_interface_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_interface_get_meaning:
 * @ptr: pointer to a #idmefv2_interface_t object.
 *
 * Get meaning children of the #idmefv2_interface_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_interface_get_meaning(idmefv2_interface_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * idmefv2_interface_set_meaning:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @meaning: pointer to a #libidmefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmefv2_interface_set_meaning(idmefv2_interface_t *ptr, libidmefv2_string_t *meaning)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libidmefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * idmefv2_interface_new_meaning:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new meaning object, children of #idmefv2_interface_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_interface_new_meaning(idmefv2_interface_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libidmefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}





/**
 * idmefv2_interface_get_next_address:
 * @interface: pointer to a #idmefv2_interface_t object.
 * @address_cur: pointer to a #idmefv2_address_t object.
 *
 * Get the next #idmefv2_address_t object listed in @ptr.
 * When iterating over the idmefv2_address_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_address_t object.
 *
 * Returns: the next #idmefv2_address_t in the list.
 */
idmefv2_address_t *idmefv2_interface_get_next_address(idmefv2_interface_t *interface, idmefv2_address_t *address_cur)
{
        libidmefv2_list_t *tmp = (address_cur) ? &((libidmefv2_linked_object_t *) address_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(interface, NULL);

        libidmefv2_list_for_each_continue(&interface->address_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_interface_set_address:
 * @ptr: pointer to a #idmefv2_interface_t object.
 * @object: pointer to a #idmefv2_address_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_address_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_interface_set_address(idmefv2_interface_t *ptr, idmefv2_address_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->address_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_interface_new_address:
 *  @ptr: pointer to a #idmefv2_interface_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_address_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_address_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_address_t object. The created #idmefv2_address_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_interface_new_address(idmefv2_interface_t *ptr, idmefv2_address_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_address_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->address_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_interface_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_interface_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_interface_copy(const idmefv2_interface_t *src, idmefv2_interface_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->name ) {
                libidmefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libidmefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }




        dst->category = src->category;



        if ( dst->meaning ) {
                libidmefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libidmefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_address_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->address_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_address_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->address_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_address_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->address_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_interface_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_interface_clone(idmefv2_interface_t *src, idmefv2_interface_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_interface_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_interface_copy(src, *dst);
}


/**
 * idmefv2_interface_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_interface_compare(const idmefv2_interface_t *obj1, const idmefv2_interface_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_address_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->address_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->address_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_address_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_file_access_new:
 * @ret: Pointer where to store the created #idmefv2_file_access_t object.
 *
 * Create a new #idmefv2_file_access_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_access_new(idmefv2_file_access_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_FILE_ACCESS;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;


        {
            int retval = idmefv2_user_id_new(&(*ret)->user_id);

            if ( retval < 0 ) {
                    idmefv2_file_access_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


            return 0;
}


/**
 * idmefv2_file_access_ref:
 * @file_access: pointer to a #idmefv2_file_access_t object.
 *
 * Increase @file_access reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @file_access.
 */
idmefv2_file_access_t *idmefv2_file_access_ref(idmefv2_file_access_t *file_access)
{
        libidmefv2_return_val_if_fail(file_access, NULL);
        file_access->refcount++;

        return file_access;
}



int _idmefv2_file_access_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_file_access_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:
                *childptr = ptr->user_id;
                return 0;

            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_FILE_ACCESS_PERMISSION , ptr->permission);

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_file_access_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_file_access_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_file_access_new_user_id(ptr, (idmefv2_user_id_t **) ret);

                case 1:
                    return idmefv2_file_access_new_permission(ptr, (idmefv2_file_access_permission_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_file_access_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_file_access_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->user_id ) {
                                idmefv2_user_id_destroy(ptr->user_id);
                                ptr->user_id = NULL;
                        }

                        return 0;




                case 1:
                    ptr->permission = 0;
                    return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_file_access_destroy_internal(idmefv2_file_access_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);


        if ( ptr->user_id ) {
                idmefv2_user_id_destroy(ptr->user_id);
                ptr->user_id = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * idmefv2_file_access_destroy:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_file_access_destroy(idmefv2_file_access_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_file_access_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_file_access_get_user_id:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 *
 * Get user_id children of the #idmefv2_file_access_t object.
 *
 * Returns: a pointer to a idmefv2_user_id_t object, or NULL if the children object is not set.
 */
idmefv2_user_id_t *idmefv2_file_access_get_user_id(idmefv2_file_access_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->user_id;

}


/**
 * idmefv2_file_access_set_user_id:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 * @user_id: pointer to a #idmefv2_user_id_t object.
 *
 * Set @user_id object as a children of @ptr.
 * if @ptr already contain an @user_id object, then it is destroyed,
 * and updated to point to the provided @user_id object.
 */

void idmefv2_file_access_set_user_id(idmefv2_file_access_t *ptr, idmefv2_user_id_t *user_id)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->user_id )
                idmefv2_user_id_destroy(ptr->user_id);

        ptr->user_id = user_id;
}
/**
 * idmefv2_file_access_new_user_id:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 * @ret: pointer to an address where to store the created #idmefv2_user_id_t object.
 *
 * Create a new user_id object, children of #idmefv2_file_access_t.
 * If @ptr already contain a #idmefv2_user_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_access_new_user_id(idmefv2_file_access_t *ptr, idmefv2_user_id_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->user_id ) {
                retval = idmefv2_user_id_new(&ptr->user_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->user_id;
        return 0;
}



/**
 * idmefv2_file_access_get_permission:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 *
 * Get permission children of the #idmefv2_file_access_t object.
 *
 * Returns: a pointer to a idmefv2_file_access_permission_t object, or NULL if the children object is not set.
 */
idmefv2_file_access_permission_t idmefv2_file_access_get_permission(idmefv2_file_access_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->permission;

}


/**
 * idmefv2_file_access_set_permission:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 * @permission: pointer to a #idmefv2_file_access_permission_t object.
 *
 * Set @permission object as a children of @ptr.
 * if @ptr already contain an @permission object, then it is destroyed,
 * and updated to point to the provided @permission object.
 */
void idmefv2_file_access_set_permission(idmefv2_file_access_t *ptr, idmefv2_file_access_permission_t permission)
{
        libidmefv2_return_if_fail(ptr);
        ptr->permission = permission;
}
/**
 * idmefv2_file_access_new_permission:
 * @ptr: pointer to a #idmefv2_file_access_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_access_permission_t object.
 *
 * Create a new permission object, children of #idmefv2_file_access_t.
 * If @ptr already contain a #idmefv2_file_access_permission_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_access_new_permission(idmefv2_file_access_t *ptr, idmefv2_file_access_permission_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->permission;
        return 0;
}



/**
 * idmefv2_file_access_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_access_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_access_copy(const idmefv2_file_access_t *src, idmefv2_file_access_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( src->user_id ) {
                ret = idmefv2_user_id_copy(src->user_id, dst->user_id);
                if ( ret < 0 )
                        return ret;
        }



        dst->permission = src->permission;
    return 0 ;
}


/**
 * idmefv2_file_access_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_access_clone(idmefv2_file_access_t *src, idmefv2_file_access_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_file_access_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_file_access_copy(src, *dst);
}


/**
 * idmefv2_file_access_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_file_access_compare(const idmefv2_file_access_t *obj1, const idmefv2_file_access_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        ret = idmefv2_user_id_compare(obj1->user_id, obj2->user_id);
        if ( ret != 0 )
                return ret;


        if ( obj1->permission != obj2->permission )
                return -1;
        return ret;
}


        



/**
 * idmefv2_inode_new:
 * @ret: Pointer where to store the created #idmefv2_inode_t object.
 *
 * Create a new #idmefv2_inode_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_inode_new(idmefv2_inode_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_INODE;


        (*ret)->refcount = 1;






            return 0;
}


/**
 * idmefv2_inode_ref:
 * @inode: pointer to a #idmefv2_inode_t object.
 *
 * Increase @inode reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @inode.
 */
idmefv2_inode_t *idmefv2_inode_ref(idmefv2_inode_t *inode)
{
        libidmefv2_return_val_if_fail(inode, NULL);
        inode->refcount++;

        return inode;
}



int _idmefv2_inode_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_inode_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                         return (ptr->number_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->number) : 0;

            case 1:
                         return (ptr->major_device_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->major_device) : 0;

            case 2:
                         return (ptr->minor_device_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->minor_device) : 0;

            case 3:
                         return (ptr->c_major_device_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->c_major_device) : 0;

            case 4:
                         return (ptr->c_minor_device_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->c_minor_device) : 0;


            case 5:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->change_time, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_inode_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_inode_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_inode_new_number(ptr, (uint32_t **) ret);

                case 1:
                    return idmefv2_inode_new_major_device(ptr, (uint32_t **) ret);

                case 2:
                    return idmefv2_inode_new_minor_device(ptr, (uint32_t **) ret);

                case 3:
                    return idmefv2_inode_new_c_major_device(ptr, (uint32_t **) ret);

                case 4:
                    return idmefv2_inode_new_c_minor_device(ptr, (uint32_t **) ret);

                case 5:
                    return idmefv2_inode_new_change_time(ptr, (idmefv2_time_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_inode_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_inode_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->number_is_set = 0;
                        return 0;

                case 1:
                        ptr->major_device_is_set = 0;
                        return 0;

                case 2:
                        ptr->minor_device_is_set = 0;
                        return 0;

                case 3:
                        ptr->c_major_device_is_set = 0;
                        return 0;

                case 4:
                        ptr->c_minor_device_is_set = 0;
                        return 0;




                case 5:
                        if ( ptr->change_time ) {
                                idmefv2_time_destroy(ptr->change_time);
                                ptr->change_time = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_inode_destroy_internal(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);











        if ( ptr->change_time ) {
                idmefv2_time_destroy(ptr->change_time);
                ptr->change_time = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_inode_destroy:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_inode_destroy(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_inode_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_inode_get_number:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get number children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_inode_get_number(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->number_is_set ? &ptr->number : NULL;


}


/**
 * idmefv2_inode_set_number:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @number: pointer to a #uint32_t object.
 *
 * Set @number object as a children of @ptr.
 * if @ptr already contain an @number object, then it is destroyed,
 * and updated to point to the provided @number object.
 */
void idmefv2_inode_set_number(idmefv2_inode_t *ptr, uint32_t number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number = number;
        ptr->number_is_set = 1;
}

void idmefv2_inode_unset_number(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->number_is_set = 0;
}
/**
 * idmefv2_inode_new_number:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new number object, children of #idmefv2_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_number(idmefv2_inode_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->number_is_set = 1;



        *ret = &ptr->number;
        return 0;
}




/**
 * idmefv2_inode_get_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get major_device children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_inode_get_major_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->major_device_is_set ? &ptr->major_device : NULL;


}


/**
 * idmefv2_inode_set_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @major_device: pointer to a #uint32_t object.
 *
 * Set @major_device object as a children of @ptr.
 * if @ptr already contain an @major_device object, then it is destroyed,
 * and updated to point to the provided @major_device object.
 */
void idmefv2_inode_set_major_device(idmefv2_inode_t *ptr, uint32_t major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->major_device = major_device;
        ptr->major_device_is_set = 1;
}

void idmefv2_inode_unset_major_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->major_device_is_set = 0;
}
/**
 * idmefv2_inode_new_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new major_device object, children of #idmefv2_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_major_device(idmefv2_inode_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->major_device_is_set = 1;



        *ret = &ptr->major_device;
        return 0;
}




/**
 * idmefv2_inode_get_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get minor_device children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_inode_get_minor_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->minor_device_is_set ? &ptr->minor_device : NULL;


}


/**
 * idmefv2_inode_set_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @minor_device: pointer to a #uint32_t object.
 *
 * Set @minor_device object as a children of @ptr.
 * if @ptr already contain an @minor_device object, then it is destroyed,
 * and updated to point to the provided @minor_device object.
 */
void idmefv2_inode_set_minor_device(idmefv2_inode_t *ptr, uint32_t minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->minor_device = minor_device;
        ptr->minor_device_is_set = 1;
}

void idmefv2_inode_unset_minor_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->minor_device_is_set = 0;
}
/**
 * idmefv2_inode_new_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new minor_device object, children of #idmefv2_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_minor_device(idmefv2_inode_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->minor_device_is_set = 1;



        *ret = &ptr->minor_device;
        return 0;
}




/**
 * idmefv2_inode_get_c_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get c_major_device children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_inode_get_c_major_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->c_major_device_is_set ? &ptr->c_major_device : NULL;


}


/**
 * idmefv2_inode_set_c_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @c_major_device: pointer to a #uint32_t object.
 *
 * Set @c_major_device object as a children of @ptr.
 * if @ptr already contain an @c_major_device object, then it is destroyed,
 * and updated to point to the provided @c_major_device object.
 */
void idmefv2_inode_set_c_major_device(idmefv2_inode_t *ptr, uint32_t c_major_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_major_device = c_major_device;
        ptr->c_major_device_is_set = 1;
}

void idmefv2_inode_unset_c_major_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_major_device_is_set = 0;
}
/**
 * idmefv2_inode_new_c_major_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new c_major_device object, children of #idmefv2_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_c_major_device(idmefv2_inode_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->c_major_device_is_set = 1;



        *ret = &ptr->c_major_device;
        return 0;
}




/**
 * idmefv2_inode_get_c_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get c_minor_device children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_inode_get_c_minor_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->c_minor_device_is_set ? &ptr->c_minor_device : NULL;


}


/**
 * idmefv2_inode_set_c_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @c_minor_device: pointer to a #uint32_t object.
 *
 * Set @c_minor_device object as a children of @ptr.
 * if @ptr already contain an @c_minor_device object, then it is destroyed,
 * and updated to point to the provided @c_minor_device object.
 */
void idmefv2_inode_set_c_minor_device(idmefv2_inode_t *ptr, uint32_t c_minor_device)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_minor_device = c_minor_device;
        ptr->c_minor_device_is_set = 1;
}

void idmefv2_inode_unset_c_minor_device(idmefv2_inode_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->c_minor_device_is_set = 0;
}
/**
 * idmefv2_inode_new_c_minor_device:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new c_minor_device object, children of #idmefv2_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_c_minor_device(idmefv2_inode_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->c_minor_device_is_set = 1;



        *ret = &ptr->c_minor_device;
        return 0;
}




/**
 * idmefv2_inode_get_change_time:
 * @ptr: pointer to a #idmefv2_inode_t object.
 *
 * Get change_time children of the #idmefv2_inode_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_inode_get_change_time(idmefv2_inode_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->change_time;

}


/**
 * idmefv2_inode_set_change_time:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @change_time: pointer to a #idmefv2_time_t object.
 *
 * Set @change_time object as a children of @ptr.
 * if @ptr already contain an @change_time object, then it is destroyed,
 * and updated to point to the provided @change_time object.
 */

void idmefv2_inode_set_change_time(idmefv2_inode_t *ptr, idmefv2_time_t *change_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->change_time )
                idmefv2_time_destroy(ptr->change_time);

        ptr->change_time = change_time;
}
/**
 * idmefv2_inode_new_change_time:
 * @ptr: pointer to a #idmefv2_inode_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new change_time object, children of #idmefv2_inode_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_inode_new_change_time(idmefv2_inode_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->change_time ) {
                retval = idmefv2_time_new(&ptr->change_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->change_time;
        return 0;
}



/**
 * idmefv2_inode_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_inode_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_inode_copy(const idmefv2_inode_t *src, idmefv2_inode_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        dst->number_is_set = src->number_is_set;
        dst->number = src->number;


        dst->major_device_is_set = src->major_device_is_set;
        dst->major_device = src->major_device;


        dst->minor_device_is_set = src->minor_device_is_set;
        dst->minor_device = src->minor_device;


        dst->c_major_device_is_set = src->c_major_device_is_set;
        dst->c_major_device = src->c_major_device;


        dst->c_minor_device_is_set = src->c_minor_device_is_set;
        dst->c_minor_device = src->c_minor_device;



        if ( dst->change_time ) {
                idmefv2_time_destroy(dst->change_time);
                dst->change_time = NULL;
        }

        if ( src->change_time ) {
                ret = idmefv2_time_clone(src->change_time, &dst->change_time);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_inode_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_inode_clone(idmefv2_inode_t *src, idmefv2_inode_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_inode_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_inode_copy(src, *dst);
}


/**
 * idmefv2_inode_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_inode_compare(const idmefv2_inode_t *obj1, const idmefv2_inode_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        if ( obj1->number_is_set != obj2->number_is_set )
                return -1;

        if ( obj1->number_is_set && obj1->number != obj2->number )
                return -1;


        if ( obj1->major_device_is_set != obj2->major_device_is_set )
                return -1;

        if ( obj1->major_device_is_set && obj1->major_device != obj2->major_device )
                return -1;


        if ( obj1->minor_device_is_set != obj2->minor_device_is_set )
                return -1;

        if ( obj1->minor_device_is_set && obj1->minor_device != obj2->minor_device )
                return -1;


        if ( obj1->c_major_device_is_set != obj2->c_major_device_is_set )
                return -1;

        if ( obj1->c_major_device_is_set && obj1->c_major_device != obj2->c_major_device )
                return -1;


        if ( obj1->c_minor_device_is_set != obj2->c_minor_device_is_set )
                return -1;

        if ( obj1->c_minor_device_is_set && obj1->c_minor_device != obj2->c_minor_device )
                return -1;


        ret = idmefv2_time_compare(obj1->change_time, obj2->change_time);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_checksum_new:
 * @ret: Pointer where to store the created #idmefv2_checksum_t object.
 *
 * Create a new #idmefv2_checksum_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_checksum_new(idmefv2_checksum_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_CHECKSUM;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
            int retval = libidmefv2_string_new(&(*ret)->value);

            if ( retval < 0 ) {
                    idmefv2_checksum_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }



            return 0;
}


/**
 * idmefv2_checksum_ref:
 * @checksum: pointer to a #idmefv2_checksum_t object.
 *
 * Increase @checksum reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @checksum.
 */
idmefv2_checksum_t *idmefv2_checksum_ref(idmefv2_checksum_t *checksum)
{
        libidmefv2_return_val_if_fail(checksum, NULL);
        checksum->refcount++;

        return checksum;
}



int _idmefv2_checksum_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_checksum_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->value, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->key, TRUE);


            case 2:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_CHECKSUM_ALGORITHM , ptr->algorithm);

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_checksum_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_checksum_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_checksum_new_value(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_checksum_new_key(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_checksum_new_algorithm(ptr, (idmefv2_checksum_algorithm_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_checksum_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_checksum_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->value ) {
                                libidmefv2_string_destroy(ptr->value);
                                ptr->value = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->key ) {
                                libidmefv2_string_destroy(ptr->key);
                                ptr->key = NULL;
                        }

                        return 0;




                case 2:
                    ptr->algorithm = 0;
                    return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_checksum_destroy_internal(idmefv2_checksum_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->value ) {
                libidmefv2_string_destroy(ptr->value);
                ptr->value = NULL;
        }



        if ( ptr->key ) {
                libidmefv2_string_destroy(ptr->key);
                ptr->key = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * idmefv2_checksum_destroy:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_checksum_destroy(idmefv2_checksum_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_checksum_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_checksum_get_value:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 *
 * Get value children of the #idmefv2_checksum_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_checksum_get_value(idmefv2_checksum_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->value;

}


/**
 * idmefv2_checksum_set_value:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @value: pointer to a #libidmefv2_string_t object.
 *
 * Set @value object as a children of @ptr.
 * if @ptr already contain an @value object, then it is destroyed,
 * and updated to point to the provided @value object.
 */

void idmefv2_checksum_set_value(idmefv2_checksum_t *ptr, libidmefv2_string_t *value)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->value )
                libidmefv2_string_destroy(ptr->value);

        ptr->value = value;
}
/**
 * idmefv2_checksum_new_value:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new value object, children of #idmefv2_checksum_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_checksum_new_value(idmefv2_checksum_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->value ) {
                retval = libidmefv2_string_new(&ptr->value);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->value;
        return 0;
}




/**
 * idmefv2_checksum_get_key:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 *
 * Get key children of the #idmefv2_checksum_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_checksum_get_key(idmefv2_checksum_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->key;

}


/**
 * idmefv2_checksum_set_key:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @key: pointer to a #libidmefv2_string_t object.
 *
 * Set @key object as a children of @ptr.
 * if @ptr already contain an @key object, then it is destroyed,
 * and updated to point to the provided @key object.
 */

void idmefv2_checksum_set_key(idmefv2_checksum_t *ptr, libidmefv2_string_t *key)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->key )
                libidmefv2_string_destroy(ptr->key);

        ptr->key = key;
}
/**
 * idmefv2_checksum_new_key:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new key object, children of #idmefv2_checksum_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_checksum_new_key(idmefv2_checksum_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->key ) {
                retval = libidmefv2_string_new(&ptr->key);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->key;
        return 0;
}



/**
 * idmefv2_checksum_get_algorithm:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 *
 * Get algorithm children of the #idmefv2_checksum_t object.
 *
 * Returns: a pointer to a idmefv2_checksum_algorithm_t object, or NULL if the children object is not set.
 */
idmefv2_checksum_algorithm_t idmefv2_checksum_get_algorithm(idmefv2_checksum_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->algorithm;

}


/**
 * idmefv2_checksum_set_algorithm:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @algorithm: pointer to a #idmefv2_checksum_algorithm_t object.
 *
 * Set @algorithm object as a children of @ptr.
 * if @ptr already contain an @algorithm object, then it is destroyed,
 * and updated to point to the provided @algorithm object.
 */
void idmefv2_checksum_set_algorithm(idmefv2_checksum_t *ptr, idmefv2_checksum_algorithm_t algorithm)
{
        libidmefv2_return_if_fail(ptr);
        ptr->algorithm = algorithm;
}
/**
 * idmefv2_checksum_new_algorithm:
 * @ptr: pointer to a #idmefv2_checksum_t object.
 * @ret: pointer to an address where to store the created #idmefv2_checksum_algorithm_t object.
 *
 * Create a new algorithm object, children of #idmefv2_checksum_t.
 * If @ptr already contain a #idmefv2_checksum_algorithm_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_checksum_new_algorithm(idmefv2_checksum_t *ptr, idmefv2_checksum_algorithm_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->algorithm;
        return 0;
}



/**
 * idmefv2_checksum_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_checksum_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_checksum_copy(const idmefv2_checksum_t *src, idmefv2_checksum_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->value ) {
                ret = libidmefv2_string_copy(src->value, dst->value);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->key ) {
                libidmefv2_string_destroy(dst->key);
                dst->key = NULL;
        }

        if ( src->key ) {
                ret = libidmefv2_string_clone(src->key, &dst->key);
                if ( ret < 0 )
                        return ret;
        }




        dst->algorithm = src->algorithm;
    return 0 ;
}


/**
 * idmefv2_checksum_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_checksum_clone(idmefv2_checksum_t *src, idmefv2_checksum_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_checksum_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_checksum_copy(src, *dst);
}


/**
 * idmefv2_checksum_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_checksum_compare(const idmefv2_checksum_t *obj1, const idmefv2_checksum_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->value, obj2->value);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->key, obj2->key);
        if ( ret != 0 )
                return ret;


        if ( obj1->algorithm != obj2->algorithm )
                return -1;
        return ret;
}


        



/**
 * idmefv2_stream_new:
 * @ret: Pointer where to store the created #idmefv2_stream_t object.
 *
 * Create a new #idmefv2_stream_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_stream_new(idmefv2_stream_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_STREAM;


        (*ret)->refcount = 1;



            return 0;
}


/**
 * idmefv2_stream_ref:
 * @stream: pointer to a #idmefv2_stream_t object.
 *
 * Increase @stream reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @stream.
 */
idmefv2_stream_t *idmefv2_stream_ref(idmefv2_stream_t *stream)
{
        libidmefv2_return_val_if_fail(stream, NULL);
        stream->refcount++;

        return stream;
}



int _idmefv2_stream_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_stream_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_STREAM_OFFSETUNIT , ptr->offsetunit);

            case 1:
                         return (ptr->offset_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->offset) : 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_stream_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_stream_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_stream_new_offsetunit(ptr, (idmefv2_stream_offsetunit_t **) ret);

                case 1:
                    return idmefv2_stream_new_offset(ptr, (uint32_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_stream_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_stream_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->offsetunit = 0;
                    return 0;

                case 1:
                        ptr->offset_is_set = 0;
                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_stream_destroy_internal(idmefv2_stream_t *ptr)
{
        libidmefv2_return_if_fail(ptr);




        /* free() should be done by the caller */
}


/**
 * idmefv2_stream_destroy:
 * @ptr: pointer to a #idmefv2_stream_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_stream_destroy(idmefv2_stream_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_stream_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_stream_get_offsetunit:
 * @ptr: pointer to a #idmefv2_stream_t object.
 *
 * Get offsetunit children of the #idmefv2_stream_t object.
 *
 * Returns: a pointer to a idmefv2_stream_offsetunit_t object, or NULL if the children object is not set.
 */
idmefv2_stream_offsetunit_t idmefv2_stream_get_offsetunit(idmefv2_stream_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offsetunit;

}


/**
 * idmefv2_stream_set_offsetunit:
 * @ptr: pointer to a #idmefv2_stream_t object.
 * @offsetunit: pointer to a #idmefv2_stream_offsetunit_t object.
 *
 * Set @offsetunit object as a children of @ptr.
 * if @ptr already contain an @offsetunit object, then it is destroyed,
 * and updated to point to the provided @offsetunit object.
 */
void idmefv2_stream_set_offsetunit(idmefv2_stream_t *ptr, idmefv2_stream_offsetunit_t offsetunit)
{
        libidmefv2_return_if_fail(ptr);
        ptr->offsetunit = offsetunit;
}
/**
 * idmefv2_stream_new_offsetunit:
 * @ptr: pointer to a #idmefv2_stream_t object.
 * @ret: pointer to an address where to store the created #idmefv2_stream_offsetunit_t object.
 *
 * Create a new offsetunit object, children of #idmefv2_stream_t.
 * If @ptr already contain a #idmefv2_stream_offsetunit_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_stream_new_offsetunit(idmefv2_stream_t *ptr, idmefv2_stream_offsetunit_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->offsetunit;
        return 0;
}




/**
 * idmefv2_stream_get_offset:
 * @ptr: pointer to a #idmefv2_stream_t object.
 *
 * Get offset children of the #idmefv2_stream_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_stream_get_offset(idmefv2_stream_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offset_is_set ? &ptr->offset : NULL;


}


/**
 * idmefv2_stream_set_offset:
 * @ptr: pointer to a #idmefv2_stream_t object.
 * @offset: pointer to a #uint32_t object.
 *
 * Set @offset object as a children of @ptr.
 * if @ptr already contain an @offset object, then it is destroyed,
 * and updated to point to the provided @offset object.
 */
void idmefv2_stream_set_offset(idmefv2_stream_t *ptr, uint32_t offset)
{
        libidmefv2_return_if_fail(ptr);
        ptr->offset = offset;
        ptr->offset_is_set = 1;
}

void idmefv2_stream_unset_offset(idmefv2_stream_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->offset_is_set = 0;
}
/**
 * idmefv2_stream_new_offset:
 * @ptr: pointer to a #idmefv2_stream_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new offset object, children of #idmefv2_stream_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_stream_new_offset(idmefv2_stream_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->offset_is_set = 1;



        *ret = &ptr->offset;
        return 0;
}



/**
 * idmefv2_stream_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_stream_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_stream_copy(const idmefv2_stream_t *src, idmefv2_stream_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->offsetunit = src->offsetunit;


        dst->offset_is_set = src->offset_is_set;
        dst->offset = src->offset;
    return 0 ;
}


/**
 * idmefv2_stream_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_stream_clone(idmefv2_stream_t *src, idmefv2_stream_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_stream_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_stream_copy(src, *dst);
}


/**
 * idmefv2_stream_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_stream_compare(const idmefv2_stream_t *obj1, const idmefv2_stream_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->offsetunit != obj2->offsetunit )
                return -1;

        if ( obj1->offset_is_set != obj2->offset_is_set )
                return -1;

        if ( obj1->offset_is_set && obj1->offset != obj2->offset )
                return -1;

        return ret;
}


        



/**
 * idmefv2_file_new:
 * @ret: Pointer where to store the created #idmefv2_file_t object.
 *
 * Create a new #idmefv2_file_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_new(idmefv2_file_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_FILE;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->file_access_list);


        libidmefv2_list_init(&(*ret)->linkage_list);


        libidmefv2_list_init(&(*ret)->checksum_list);



        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_file_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->path);

            if ( retval < 0 ) {
                    idmefv2_file_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }




















            return 0;
}


/**
 * idmefv2_file_ref:
 * @file: pointer to a #idmefv2_file_t object.
 *
 * Increase @file reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @file.
 */
idmefv2_file_t *idmefv2_file_ref(idmefv2_file_t *file)
{
        libidmefv2_return_val_if_fail(file, NULL);
        file->refcount++;

        return file;
}



int _idmefv2_file_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_file_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->path, TRUE);



            case 3:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->create_time, TRUE);



            case 4:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->modify_time, TRUE);



            case 5:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->access_time, TRUE);


            case 6:
                         return (ptr->data_size_is_set) ? idmefv2_value_new_uint64((idmefv2_value_t **) childptr, ptr->data_size) : 0;

            case 7:
                         return (ptr->disk_size_is_set) ? idmefv2_value_new_uint64((idmefv2_value_t **) childptr, ptr->disk_size) : 0;

            case 8:
                *childptr = &ptr->file_access_list;
                return 0;

            case 9:
                *childptr = &ptr->linkage_list;
                return 0;


            case 10:
                *childptr = ptr->inode;
                return 0;

            case 11:
                *childptr = &ptr->checksum_list;
                return 0;

            case 12:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_FILE_CATEGORY , ptr->category);


            case 13:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->file_type, TRUE);



            case 14:
                *childptr = ptr->container;
                return 0;


            case 15:
                *childptr = ptr->stream;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_file_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_file_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_file_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_file_new_name(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_file_new_path(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_file_new_create_time(ptr, (idmefv2_time_t **) ret);

                case 4:
                    return idmefv2_file_new_modify_time(ptr, (idmefv2_time_t **) ret);

                case 5:
                    return idmefv2_file_new_access_time(ptr, (idmefv2_time_t **) ret);

                case 6:
                    return idmefv2_file_new_data_size(ptr, (uint64_t **) ret);

                case 7:
                    return idmefv2_file_new_disk_size(ptr, (uint64_t **) ret);

                case 8: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_file_new_file_access(ptr, (idmefv2_file_access_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->file_access_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->file_access_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_file_new_file_access(ptr, (idmefv2_file_access_t **) ret, n);
                }

                case 9: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_file_new_linkage(ptr, (idmefv2_linkage_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->linkage_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->linkage_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_file_new_linkage(ptr, (idmefv2_linkage_t **) ret, n);
                }

                case 10:
                    return idmefv2_file_new_inode(ptr, (idmefv2_inode_t **) ret);

                case 11: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_file_new_checksum(ptr, (idmefv2_checksum_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->checksum_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->checksum_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_file_new_checksum(ptr, (idmefv2_checksum_t **) ret, n);
                }

                case 12:
                    return idmefv2_file_new_category(ptr, (idmefv2_file_category_t **) ret);

                case 13:
                    return idmefv2_file_new_file_type(ptr, (libidmefv2_string_t **) ret);

                case 14:
                    return idmefv2_file_new_container(ptr, (idmefv2_container_t **) ret);

                case 15:
                    return idmefv2_file_new_stream(ptr, (idmefv2_stream_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_file_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_file_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->path ) {
                                libidmefv2_string_destroy(ptr->path);
                                ptr->path = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->create_time ) {
                                idmefv2_time_destroy(ptr->create_time);
                                ptr->create_time = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->modify_time ) {
                                idmefv2_time_destroy(ptr->modify_time);
                                ptr->modify_time = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->access_time ) {
                                idmefv2_time_destroy(ptr->access_time);
                                ptr->access_time = NULL;
                        }

                        return 0;

                case 6:
                        ptr->data_size_is_set = 0;
                        return 0;

                case 7:
                        ptr->disk_size_is_set = 0;
                        return 0;

    
                case 8: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->file_access_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_file_access_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->file_access_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_file_access_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 9: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->linkage_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_linkage_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->linkage_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_linkage_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 10:
                        if ( ptr->inode ) {
                                idmefv2_inode_destroy(ptr->inode);
                                ptr->inode = NULL;
                        }

                        return 0;

    
                case 11: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->checksum_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_checksum_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->checksum_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_checksum_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 12:
                    ptr->category = 0;
                    return 0;




                case 13:
                        if ( ptr->file_type ) {
                                libidmefv2_string_destroy(ptr->file_type);
                                ptr->file_type = NULL;
                        }

                        return 0;




                case 14:
                        if ( ptr->container ) {
                                idmefv2_container_destroy(ptr->container);
                                ptr->container = NULL;
                        }

                        return 0;




                case 15:
                        if ( ptr->stream ) {
                                idmefv2_stream_destroy(ptr->stream);
                                ptr->stream = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_file_destroy_internal(idmefv2_file_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->path ) {
                libidmefv2_string_destroy(ptr->path);
                ptr->path = NULL;
        }



        if ( ptr->create_time ) {
                idmefv2_time_destroy(ptr->create_time);
                ptr->create_time = NULL;
        }



        if ( ptr->modify_time ) {
                idmefv2_time_destroy(ptr->modify_time);
                ptr->modify_time = NULL;
        }



        if ( ptr->access_time ) {
                idmefv2_time_destroy(ptr->access_time);
                ptr->access_time = NULL;
        }








        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_file_access_t *entry;

                libidmefv2_list_for_each_safe(&ptr->file_access_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_file_access_destroy(entry);
                }
        }


        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_linkage_t *entry;

                libidmefv2_list_for_each_safe(&ptr->linkage_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_linkage_destroy(entry);
                }
        }


        if ( ptr->inode ) {
                idmefv2_inode_destroy(ptr->inode);
                ptr->inode = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_checksum_t *entry;

                libidmefv2_list_for_each_safe(&ptr->checksum_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_checksum_destroy(entry);
                }
        }



        if ( ptr->file_type ) {
                libidmefv2_string_destroy(ptr->file_type);
                ptr->file_type = NULL;
        }




        if ( ptr->container ) {
                idmefv2_container_destroy(ptr->container);
                ptr->container = NULL;
        }




        if ( ptr->stream ) {
                idmefv2_stream_destroy(ptr->stream);
                ptr->stream = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_file_destroy:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_file_destroy(idmefv2_file_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_file_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_file_get_ident:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get ident children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_file_get_ident(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_file_set_ident:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_file_set_ident(idmefv2_file_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_file_new_ident:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_file_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_ident(idmefv2_file_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}




/**
 * idmefv2_file_get_name:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get name children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_file_get_name(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_file_set_name:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_file_set_name(idmefv2_file_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_file_new_name:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_file_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_name(idmefv2_file_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_file_get_path:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get path children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_file_get_path(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->path;

}


/**
 * idmefv2_file_set_path:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @path: pointer to a #libidmefv2_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmefv2_file_set_path(idmefv2_file_t *ptr, libidmefv2_string_t *path)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->path )
                libidmefv2_string_destroy(ptr->path);

        ptr->path = path;
}
/**
 * idmefv2_file_new_path:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new path object, children of #idmefv2_file_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_path(idmefv2_file_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->path ) {
                retval = libidmefv2_string_new(&ptr->path);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->path;
        return 0;
}




/**
 * idmefv2_file_get_create_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get create_time children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_file_get_create_time(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->create_time;

}


/**
 * idmefv2_file_set_create_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @create_time: pointer to a #idmefv2_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmefv2_file_set_create_time(idmefv2_file_t *ptr, idmefv2_time_t *create_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->create_time )
                idmefv2_time_destroy(ptr->create_time);

        ptr->create_time = create_time;
}
/**
 * idmefv2_file_new_create_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new create_time object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_create_time(idmefv2_file_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->create_time ) {
                retval = idmefv2_time_new(&ptr->create_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->create_time;
        return 0;
}




/**
 * idmefv2_file_get_modify_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get modify_time children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_file_get_modify_time(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->modify_time;

}


/**
 * idmefv2_file_set_modify_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @modify_time: pointer to a #idmefv2_time_t object.
 *
 * Set @modify_time object as a children of @ptr.
 * if @ptr already contain an @modify_time object, then it is destroyed,
 * and updated to point to the provided @modify_time object.
 */

void idmefv2_file_set_modify_time(idmefv2_file_t *ptr, idmefv2_time_t *modify_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->modify_time )
                idmefv2_time_destroy(ptr->modify_time);

        ptr->modify_time = modify_time;
}
/**
 * idmefv2_file_new_modify_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new modify_time object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_modify_time(idmefv2_file_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->modify_time ) {
                retval = idmefv2_time_new(&ptr->modify_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->modify_time;
        return 0;
}




/**
 * idmefv2_file_get_access_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get access_time children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_file_get_access_time(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->access_time;

}


/**
 * idmefv2_file_set_access_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @access_time: pointer to a #idmefv2_time_t object.
 *
 * Set @access_time object as a children of @ptr.
 * if @ptr already contain an @access_time object, then it is destroyed,
 * and updated to point to the provided @access_time object.
 */

void idmefv2_file_set_access_time(idmefv2_file_t *ptr, idmefv2_time_t *access_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->access_time )
                idmefv2_time_destroy(ptr->access_time);

        ptr->access_time = access_time;
}
/**
 * idmefv2_file_new_access_time:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new access_time object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_access_time(idmefv2_file_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->access_time ) {
                retval = idmefv2_time_new(&ptr->access_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->access_time;
        return 0;
}




/**
 * idmefv2_file_get_data_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get data_size children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t *idmefv2_file_get_data_size(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data_size_is_set ? &ptr->data_size : NULL;


}


/**
 * idmefv2_file_set_data_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @data_size: pointer to a #uint64_t object.
 *
 * Set @data_size object as a children of @ptr.
 * if @ptr already contain an @data_size object, then it is destroyed,
 * and updated to point to the provided @data_size object.
 */
void idmefv2_file_set_data_size(idmefv2_file_t *ptr, uint64_t data_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->data_size = data_size;
        ptr->data_size_is_set = 1;
}

void idmefv2_file_unset_data_size(idmefv2_file_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->data_size_is_set = 0;
}
/**
 * idmefv2_file_new_data_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #uint64_t object.
 *
 * Create a new data_size object, children of #idmefv2_file_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_data_size(idmefv2_file_t *ptr, uint64_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->data_size_is_set = 1;



        *ret = &ptr->data_size;
        return 0;
}




/**
 * idmefv2_file_get_disk_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get disk_size children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t *idmefv2_file_get_disk_size(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->disk_size_is_set ? &ptr->disk_size : NULL;


}


/**
 * idmefv2_file_set_disk_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @disk_size: pointer to a #uint64_t object.
 *
 * Set @disk_size object as a children of @ptr.
 * if @ptr already contain an @disk_size object, then it is destroyed,
 * and updated to point to the provided @disk_size object.
 */
void idmefv2_file_set_disk_size(idmefv2_file_t *ptr, uint64_t disk_size)
{
        libidmefv2_return_if_fail(ptr);
        ptr->disk_size = disk_size;
        ptr->disk_size_is_set = 1;
}

void idmefv2_file_unset_disk_size(idmefv2_file_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->disk_size_is_set = 0;
}
/**
 * idmefv2_file_new_disk_size:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #uint64_t object.
 *
 * Create a new disk_size object, children of #idmefv2_file_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_disk_size(idmefv2_file_t *ptr, uint64_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->disk_size_is_set = 1;



        *ret = &ptr->disk_size;
        return 0;
}





/**
 * idmefv2_file_get_next_file_access:
 * @file: pointer to a #idmefv2_file_t object.
 * @file_access_cur: pointer to a #idmefv2_file_access_t object.
 *
 * Get the next #idmefv2_file_access_t object listed in @ptr.
 * When iterating over the idmefv2_file_access_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_file_access_t object.
 *
 * Returns: the next #idmefv2_file_access_t in the list.
 */
idmefv2_file_access_t *idmefv2_file_get_next_file_access(idmefv2_file_t *file, idmefv2_file_access_t *file_access_cur)
{
        libidmefv2_list_t *tmp = (file_access_cur) ? &((libidmefv2_linked_object_t *) file_access_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(file, NULL);

        libidmefv2_list_for_each_continue(&file->file_access_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_file_set_file_access:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @object: pointer to a #idmefv2_file_access_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_file_access_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_file_set_file_access(idmefv2_file_t *ptr, idmefv2_file_access_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->file_access_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_file_new_file_access:
 *  @ptr: pointer to a #idmefv2_file_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_file_access_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_file_access_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_file_access_t object. The created #idmefv2_file_access_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_file_access(idmefv2_file_t *ptr, idmefv2_file_access_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_file_access_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->file_access_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * idmefv2_file_get_next_linkage:
 * @file: pointer to a #idmefv2_file_t object.
 * @linkage_cur: pointer to a #idmefv2_linkage_t object.
 *
 * Get the next #idmefv2_linkage_t object listed in @ptr.
 * When iterating over the idmefv2_linkage_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_linkage_t object.
 *
 * Returns: the next #idmefv2_linkage_t in the list.
 */
idmefv2_linkage_t *idmefv2_file_get_next_linkage(idmefv2_file_t *file, idmefv2_linkage_t *linkage_cur)
{
        libidmefv2_list_t *tmp = (linkage_cur) ? &((libidmefv2_linked_object_t *) linkage_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(file, NULL);

        libidmefv2_list_for_each_continue(&file->linkage_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_file_set_linkage:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @object: pointer to a #idmefv2_linkage_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_linkage_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_file_set_linkage(idmefv2_file_t *ptr, idmefv2_linkage_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->linkage_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_file_new_linkage:
 *  @ptr: pointer to a #idmefv2_file_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_linkage_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_linkage_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_linkage_t object. The created #idmefv2_linkage_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_linkage(idmefv2_file_t *ptr, idmefv2_linkage_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_linkage_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->linkage_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_file_get_inode:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get inode children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_inode_t object, or NULL if the children object is not set.
 */
idmefv2_inode_t *idmefv2_file_get_inode(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->inode;

}


/**
 * idmefv2_file_set_inode:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @inode: pointer to a #idmefv2_inode_t object.
 *
 * Set @inode object as a children of @ptr.
 * if @ptr already contain an @inode object, then it is destroyed,
 * and updated to point to the provided @inode object.
 */

void idmefv2_file_set_inode(idmefv2_file_t *ptr, idmefv2_inode_t *inode)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->inode )
                idmefv2_inode_destroy(ptr->inode);

        ptr->inode = inode;
}
/**
 * idmefv2_file_new_inode:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_inode_t object.
 *
 * Create a new inode object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_inode_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_inode(idmefv2_file_t *ptr, idmefv2_inode_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->inode ) {
                retval = idmefv2_inode_new(&ptr->inode);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->inode;
        return 0;
}





/**
 * idmefv2_file_get_next_checksum:
 * @file: pointer to a #idmefv2_file_t object.
 * @checksum_cur: pointer to a #idmefv2_checksum_t object.
 *
 * Get the next #idmefv2_checksum_t object listed in @ptr.
 * When iterating over the idmefv2_checksum_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_checksum_t object.
 *
 * Returns: the next #idmefv2_checksum_t in the list.
 */
idmefv2_checksum_t *idmefv2_file_get_next_checksum(idmefv2_file_t *file, idmefv2_checksum_t *checksum_cur)
{
        libidmefv2_list_t *tmp = (checksum_cur) ? &((libidmefv2_linked_object_t *) checksum_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(file, NULL);

        libidmefv2_list_for_each_continue(&file->checksum_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_file_set_checksum:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @object: pointer to a #idmefv2_checksum_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_checksum_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_file_set_checksum(idmefv2_file_t *ptr, idmefv2_checksum_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->checksum_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_file_new_checksum:
 *  @ptr: pointer to a #idmefv2_file_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_checksum_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_checksum_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_checksum_t object. The created #idmefv2_checksum_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_checksum(idmefv2_file_t *ptr, idmefv2_checksum_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_checksum_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->checksum_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_file_get_category:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get category children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_file_category_t object, or NULL if the children object is not set.
 */
idmefv2_file_category_t idmefv2_file_get_category(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_file_set_category:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @category: pointer to a #idmefv2_file_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_file_set_category(idmefv2_file_t *ptr, idmefv2_file_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_file_new_category:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_category_t object.
 *
 * Create a new category object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_file_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_category(idmefv2_file_t *ptr, idmefv2_file_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_file_get_file_type:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get file_type children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_file_get_file_type(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file_type;

}


/**
 * idmefv2_file_set_file_type:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @file_type: pointer to a #libidmefv2_string_t object.
 *
 * Set @file_type object as a children of @ptr.
 * if @ptr already contain an @file_type object, then it is destroyed,
 * and updated to point to the provided @file_type object.
 */

void idmefv2_file_set_file_type(idmefv2_file_t *ptr, libidmefv2_string_t *file_type)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->file_type )
                libidmefv2_string_destroy(ptr->file_type);

        ptr->file_type = file_type;
}
/**
 * idmefv2_file_new_file_type:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new file_type object, children of #idmefv2_file_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_file_type(idmefv2_file_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->file_type ) {
                retval = libidmefv2_string_new(&ptr->file_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file_type;
        return 0;
}




/**
 * idmefv2_file_get_container:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get container children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_container_t object, or NULL if the children object is not set.
 */
idmefv2_container_t *idmefv2_file_get_container(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->container;

}


/**
 * idmefv2_file_set_container:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @container: pointer to a #idmefv2_container_t object.
 *
 * Set @container object as a children of @ptr.
 * if @ptr already contain an @container object, then it is destroyed,
 * and updated to point to the provided @container object.
 */

void idmefv2_file_set_container(idmefv2_file_t *ptr, idmefv2_container_t *container)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->container )
                idmefv2_container_destroy(ptr->container);

        ptr->container = container;
}
/**
 * idmefv2_file_new_container:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_container_t object.
 *
 * Create a new container object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_container_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_container(idmefv2_file_t *ptr, idmefv2_container_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->container ) {
                retval = idmefv2_container_new(&ptr->container);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->container;
        return 0;
}




/**
 * idmefv2_file_get_stream:
 * @ptr: pointer to a #idmefv2_file_t object.
 *
 * Get stream children of the #idmefv2_file_t object.
 *
 * Returns: a pointer to a idmefv2_stream_t object, or NULL if the children object is not set.
 */
idmefv2_stream_t *idmefv2_file_get_stream(idmefv2_file_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->stream;

}


/**
 * idmefv2_file_set_stream:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @stream: pointer to a #idmefv2_stream_t object.
 *
 * Set @stream object as a children of @ptr.
 * if @ptr already contain an @stream object, then it is destroyed,
 * and updated to point to the provided @stream object.
 */

void idmefv2_file_set_stream(idmefv2_file_t *ptr, idmefv2_stream_t *stream)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->stream )
                idmefv2_stream_destroy(ptr->stream);

        ptr->stream = stream;
}
/**
 * idmefv2_file_new_stream:
 * @ptr: pointer to a #idmefv2_file_t object.
 * @ret: pointer to an address where to store the created #idmefv2_stream_t object.
 *
 * Create a new stream object, children of #idmefv2_file_t.
 * If @ptr already contain a #idmefv2_stream_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_file_new_stream(idmefv2_file_t *ptr, idmefv2_stream_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->stream ) {
                retval = idmefv2_stream_new(&ptr->stream);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->stream;
        return 0;
}



/**
 * idmefv2_file_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_file_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_copy(const idmefv2_file_t *src, idmefv2_file_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->path ) {
                ret = libidmefv2_string_copy(src->path, dst->path);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->create_time ) {
                idmefv2_time_destroy(dst->create_time);
                dst->create_time = NULL;
        }

        if ( src->create_time ) {
                ret = idmefv2_time_clone(src->create_time, &dst->create_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->modify_time ) {
                idmefv2_time_destroy(dst->modify_time);
                dst->modify_time = NULL;
        }

        if ( src->modify_time ) {
                ret = idmefv2_time_clone(src->modify_time, &dst->modify_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->access_time ) {
                idmefv2_time_destroy(dst->access_time);
                dst->access_time = NULL;
        }

        if ( src->access_time ) {
                ret = idmefv2_time_clone(src->access_time, &dst->access_time);
                if ( ret < 0 )
                        return ret;
        }



        dst->data_size_is_set = src->data_size_is_set;
        dst->data_size = src->data_size;


        dst->disk_size_is_set = src->disk_size_is_set;
        dst->disk_size = src->disk_size;



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_file_access_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->file_access_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_file_access_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->file_access_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_file_access_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->file_access_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_linkage_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->linkage_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_linkage_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->linkage_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_linkage_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->linkage_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->inode ) {
                idmefv2_inode_destroy(dst->inode);
                dst->inode = NULL;
        }

        if ( src->inode ) {
                ret = idmefv2_inode_clone(src->inode, &dst->inode);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_checksum_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->checksum_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_checksum_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->checksum_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_checksum_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->checksum_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }



        dst->category = src->category;



        if ( dst->file_type ) {
                libidmefv2_string_destroy(dst->file_type);
                dst->file_type = NULL;
        }

        if ( src->file_type ) {
                ret = libidmefv2_string_clone(src->file_type, &dst->file_type);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->container ) {
                idmefv2_container_destroy(dst->container);
                dst->container = NULL;
        }

        if ( src->container ) {
                ret = idmefv2_container_clone(src->container, &dst->container);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->stream ) {
                idmefv2_stream_destroy(dst->stream);
                dst->stream = NULL;
        }

        if ( src->stream ) {
                ret = idmefv2_stream_clone(src->stream, &dst->stream);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_file_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_file_clone(idmefv2_file_t *src, idmefv2_file_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_file_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_file_copy(src, *dst);
}


/**
 * idmefv2_file_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_file_compare(const idmefv2_file_t *obj1, const idmefv2_file_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->path, obj2->path);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->create_time, obj2->create_time);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->modify_time, obj2->modify_time);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->access_time, obj2->access_time);
        if ( ret != 0 )
                return ret;

        if ( obj1->data_size_is_set != obj2->data_size_is_set )
                return -1;

        if ( obj1->data_size_is_set && obj1->data_size != obj2->data_size )
                return -1;


        if ( obj1->disk_size_is_set != obj2->disk_size_is_set )
                return -1;

        if ( obj1->disk_size_is_set && obj1->disk_size != obj2->disk_size )
                return -1;



        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_file_access_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->file_access_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->file_access_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_file_access_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_linkage_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->linkage_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->linkage_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_linkage_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = idmefv2_inode_compare(obj1->inode, obj2->inode);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_checksum_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->checksum_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->checksum_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_checksum_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->file_type, obj2->file_type);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_container_compare(obj1->container, obj2->container);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_stream_compare(obj1->stream, obj2->stream);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_linkage_new:
 * @ret: Pointer where to store the created #idmefv2_linkage_t object.
 *
 * Create a new #idmefv2_linkage_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_linkage_new(idmefv2_linkage_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_LINKAGE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_linkage_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->path);

            if ( retval < 0 ) {
                    idmefv2_linkage_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


        {
            int retval = idmefv2_file_new(&(*ret)->file);

            if ( retval < 0 ) {
                    idmefv2_linkage_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_linkage_ref:
 * @linkage: pointer to a #idmefv2_linkage_t object.
 *
 * Increase @linkage reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @linkage.
 */
idmefv2_linkage_t *idmefv2_linkage_ref(idmefv2_linkage_t *linkage)
{
        libidmefv2_return_val_if_fail(linkage, NULL);
        linkage->refcount++;

        return linkage;
}



int _idmefv2_linkage_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_linkage_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_LINKAGE_CATEGORY , ptr->category);


            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->path, TRUE);



            case 3:
                *childptr = ptr->file;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_linkage_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_linkage_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_linkage_new_category(ptr, (idmefv2_linkage_category_t **) ret);

                case 1:
                    return idmefv2_linkage_new_name(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_linkage_new_path(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_linkage_new_file(ptr, (idmefv2_file_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_linkage_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_linkage_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->path ) {
                                libidmefv2_string_destroy(ptr->path);
                                ptr->path = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->file ) {
                                idmefv2_file_destroy(ptr->file);
                                ptr->file = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_linkage_destroy_internal(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->path ) {
                libidmefv2_string_destroy(ptr->path);
                ptr->path = NULL;
        }




        if ( ptr->file ) {
                idmefv2_file_destroy(ptr->file);
                ptr->file = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_linkage_destroy:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_linkage_destroy(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_linkage_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_linkage_get_category:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Get category children of the #idmefv2_linkage_t object.
 *
 * Returns: a pointer to a idmefv2_linkage_category_t object, or NULL if the children object is not set.
 */
idmefv2_linkage_category_t idmefv2_linkage_get_category(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_linkage_set_category:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @category: pointer to a #idmefv2_linkage_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_linkage_set_category(idmefv2_linkage_t *ptr, idmefv2_linkage_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_linkage_new_category:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @ret: pointer to an address where to store the created #idmefv2_linkage_category_t object.
 *
 * Create a new category object, children of #idmefv2_linkage_t.
 * If @ptr already contain a #idmefv2_linkage_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_linkage_new_category(idmefv2_linkage_t *ptr, idmefv2_linkage_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * idmefv2_linkage_get_name:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Get name children of the #idmefv2_linkage_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_linkage_get_name(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_linkage_set_name:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_linkage_set_name(idmefv2_linkage_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_linkage_new_name:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_linkage_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_linkage_new_name(idmefv2_linkage_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_linkage_get_path:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Get path children of the #idmefv2_linkage_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_linkage_get_path(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->path;

}


/**
 * idmefv2_linkage_set_path:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @path: pointer to a #libidmefv2_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmefv2_linkage_set_path(idmefv2_linkage_t *ptr, libidmefv2_string_t *path)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->path )
                libidmefv2_string_destroy(ptr->path);

        ptr->path = path;
}
/**
 * idmefv2_linkage_new_path:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new path object, children of #idmefv2_linkage_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_linkage_new_path(idmefv2_linkage_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->path ) {
                retval = libidmefv2_string_new(&ptr->path);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->path;
        return 0;
}




/**
 * idmefv2_linkage_get_file:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 *
 * Get file children of the #idmefv2_linkage_t object.
 *
 * Returns: a pointer to a idmefv2_file_t object, or NULL if the children object is not set.
 */
idmefv2_file_t *idmefv2_linkage_get_file(idmefv2_linkage_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file;

}


/**
 * idmefv2_linkage_set_file:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @file: pointer to a #idmefv2_file_t object.
 *
 * Set @file object as a children of @ptr.
 * if @ptr already contain an @file object, then it is destroyed,
 * and updated to point to the provided @file object.
 */

void idmefv2_linkage_set_file(idmefv2_linkage_t *ptr, idmefv2_file_t *file)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->file )
                idmefv2_file_destroy(ptr->file);

        ptr->file = file;
}
/**
 * idmefv2_linkage_new_file:
 * @ptr: pointer to a #idmefv2_linkage_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_t object.
 *
 * Create a new file object, children of #idmefv2_linkage_t.
 * If @ptr already contain a #idmefv2_file_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_linkage_new_file(idmefv2_linkage_t *ptr, idmefv2_file_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->file ) {
                retval = idmefv2_file_new(&ptr->file);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file;
        return 0;
}



/**
 * idmefv2_linkage_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_linkage_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_linkage_copy(const idmefv2_linkage_t *src, idmefv2_linkage_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->path ) {
                ret = libidmefv2_string_copy(src->path, dst->path);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->file ) {
                ret = idmefv2_file_copy(src->file, dst->file);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_linkage_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_linkage_clone(idmefv2_linkage_t *src, idmefv2_linkage_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_linkage_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_linkage_copy(src, *dst);
}


/**
 * idmefv2_linkage_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_linkage_compare(const idmefv2_linkage_t *obj1, const idmefv2_linkage_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->path, obj2->path);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_file_compare(obj1->file, obj2->file);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_container_new:
 * @ret: Pointer where to store the created #idmefv2_container_t object.
 *
 * Create a new #idmefv2_container_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_container_new(idmefv2_container_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_CONTAINER;


        (*ret)->refcount = 1;

        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_container_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->path);

            if ( retval < 0 ) {
                    idmefv2_container_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


        {
            int retval = idmefv2_file_new(&(*ret)->file);

            if ( retval < 0 ) {
                    idmefv2_container_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_container_ref:
 * @container: pointer to a #idmefv2_container_t object.
 *
 * Increase @container reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @container.
 */
idmefv2_container_t *idmefv2_container_ref(idmefv2_container_t *container)
{
        libidmefv2_return_val_if_fail(container, NULL);
        container->refcount++;

        return container;
}



int _idmefv2_container_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_container_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->path, TRUE);



            case 2:
                *childptr = ptr->file;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_container_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_container_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_container_new_name(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_container_new_path(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_container_new_file(ptr, (idmefv2_file_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_container_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_container_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->path ) {
                                libidmefv2_string_destroy(ptr->path);
                                ptr->path = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->file ) {
                                idmefv2_file_destroy(ptr->file);
                                ptr->file = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_container_destroy_internal(idmefv2_container_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->path ) {
                libidmefv2_string_destroy(ptr->path);
                ptr->path = NULL;
        }




        if ( ptr->file ) {
                idmefv2_file_destroy(ptr->file);
                ptr->file = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_container_destroy:
 * @ptr: pointer to a #idmefv2_container_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_container_destroy(idmefv2_container_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_container_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_container_get_name:
 * @ptr: pointer to a #idmefv2_container_t object.
 *
 * Get name children of the #idmefv2_container_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_container_get_name(idmefv2_container_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_container_set_name:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_container_set_name(idmefv2_container_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_container_new_name:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_container_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_container_new_name(idmefv2_container_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_container_get_path:
 * @ptr: pointer to a #idmefv2_container_t object.
 *
 * Get path children of the #idmefv2_container_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_container_get_path(idmefv2_container_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->path;

}


/**
 * idmefv2_container_set_path:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @path: pointer to a #libidmefv2_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmefv2_container_set_path(idmefv2_container_t *ptr, libidmefv2_string_t *path)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->path )
                libidmefv2_string_destroy(ptr->path);

        ptr->path = path;
}
/**
 * idmefv2_container_new_path:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new path object, children of #idmefv2_container_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_container_new_path(idmefv2_container_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->path ) {
                retval = libidmefv2_string_new(&ptr->path);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->path;
        return 0;
}




/**
 * idmefv2_container_get_file:
 * @ptr: pointer to a #idmefv2_container_t object.
 *
 * Get file children of the #idmefv2_container_t object.
 *
 * Returns: a pointer to a idmefv2_file_t object, or NULL if the children object is not set.
 */
idmefv2_file_t *idmefv2_container_get_file(idmefv2_container_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file;

}


/**
 * idmefv2_container_set_file:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @file: pointer to a #idmefv2_file_t object.
 *
 * Set @file object as a children of @ptr.
 * if @ptr already contain an @file object, then it is destroyed,
 * and updated to point to the provided @file object.
 */

void idmefv2_container_set_file(idmefv2_container_t *ptr, idmefv2_file_t *file)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->file )
                idmefv2_file_destroy(ptr->file);

        ptr->file = file;
}
/**
 * idmefv2_container_new_file:
 * @ptr: pointer to a #idmefv2_container_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_t object.
 *
 * Create a new file object, children of #idmefv2_container_t.
 * If @ptr already contain a #idmefv2_file_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_container_new_file(idmefv2_container_t *ptr, idmefv2_file_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->file ) {
                retval = idmefv2_file_new(&ptr->file);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file;
        return 0;
}



/**
 * idmefv2_container_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_container_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_container_copy(const idmefv2_container_t *src, idmefv2_container_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->path ) {
                ret = libidmefv2_string_copy(src->path, dst->path);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->file ) {
                ret = idmefv2_file_copy(src->file, dst->file);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_container_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_container_clone(idmefv2_container_t *src, idmefv2_container_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_container_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_container_copy(src, *dst);
}


/**
 * idmefv2_container_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_container_compare(const idmefv2_container_t *obj1, const idmefv2_container_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->path, obj2->path);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_file_compare(obj1->file, obj2->file);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_process_new:
 * @ret: Pointer where to store the created #idmefv2_process_t object.
 *
 * Create a new #idmefv2_process_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_process_new(idmefv2_process_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_PROCESS;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->arg_list);


        libidmefv2_list_init(&(*ret)->env_list);



        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_process_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }





            return 0;
}


/**
 * idmefv2_process_ref:
 * @process: pointer to a #idmefv2_process_t object.
 *
 * Increase @process reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @process.
 */
idmefv2_process_t *idmefv2_process_ref(idmefv2_process_t *process)
{
        libidmefv2_return_val_if_fail(process, NULL);
        process->refcount++;

        return process;
}



int _idmefv2_process_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_process_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 2:
                         return (ptr->pid_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->pid) : 0;


            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->path, TRUE);


            case 4:
                *childptr = &ptr->arg_list;
                return 0;

            case 5:
                *childptr = &ptr->env_list;
                return 0;

            case 6:
                         return (ptr->tid_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->tid) : 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_process_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_process_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_process_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_process_new_name(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_process_new_pid(ptr, (uint32_t **) ret);

                case 3:
                    return idmefv2_process_new_path(ptr, (libidmefv2_string_t **) ret);

                case 4: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_process_new_arg(ptr, (libidmefv2_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->arg_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->arg_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_process_new_arg(ptr, (libidmefv2_string_t **) ret, n);
                }

                case 5: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_process_new_env(ptr, (libidmefv2_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->env_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->env_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_process_new_env(ptr, (libidmefv2_string_t **) ret, n);
                }

                case 6:
                    return idmefv2_process_new_tid(ptr, (uint32_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_process_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_process_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 2:
                        ptr->pid_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->path ) {
                                libidmefv2_string_destroy(ptr->path);
                                ptr->path = NULL;
                        }

                        return 0;


                case 4: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->arg_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            libidmefv2_string_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->arg_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        libidmefv2_string_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }


                case 5: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->env_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            libidmefv2_string_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->env_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        libidmefv2_string_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                case 6:
                        ptr->tid_is_set = 0;
                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_process_destroy_internal(idmefv2_process_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }





        if ( ptr->path ) {
                libidmefv2_string_destroy(ptr->path);
                ptr->path = NULL;
        }



        {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry;

                libidmefv2_list_for_each_safe(&ptr->arg_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        libidmefv2_string_destroy(entry);
                }
        }

        {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry;

                libidmefv2_list_for_each_safe(&ptr->env_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        libidmefv2_string_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_process_destroy:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_process_destroy(idmefv2_process_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_process_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_process_get_ident:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Get ident children of the #idmefv2_process_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_process_get_ident(idmefv2_process_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_process_set_ident:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_process_set_ident(idmefv2_process_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_process_new_ident:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_process_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_ident(idmefv2_process_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}




/**
 * idmefv2_process_get_name:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Get name children of the #idmefv2_process_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_process_get_name(idmefv2_process_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_process_set_name:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_process_set_name(idmefv2_process_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_process_new_name:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_process_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_name(idmefv2_process_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_process_get_pid:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Get pid children of the #idmefv2_process_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_process_get_pid(idmefv2_process_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->pid_is_set ? &ptr->pid : NULL;


}


/**
 * idmefv2_process_set_pid:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @pid: pointer to a #uint32_t object.
 *
 * Set @pid object as a children of @ptr.
 * if @ptr already contain an @pid object, then it is destroyed,
 * and updated to point to the provided @pid object.
 */
void idmefv2_process_set_pid(idmefv2_process_t *ptr, uint32_t pid)
{
        libidmefv2_return_if_fail(ptr);
        ptr->pid = pid;
        ptr->pid_is_set = 1;
}

void idmefv2_process_unset_pid(idmefv2_process_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->pid_is_set = 0;
}
/**
 * idmefv2_process_new_pid:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new pid object, children of #idmefv2_process_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_pid(idmefv2_process_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->pid_is_set = 1;



        *ret = &ptr->pid;
        return 0;
}




/**
 * idmefv2_process_get_path:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Get path children of the #idmefv2_process_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_process_get_path(idmefv2_process_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->path;

}


/**
 * idmefv2_process_set_path:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @path: pointer to a #libidmefv2_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmefv2_process_set_path(idmefv2_process_t *ptr, libidmefv2_string_t *path)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->path )
                libidmefv2_string_destroy(ptr->path);

        ptr->path = path;
}
/**
 * idmefv2_process_new_path:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new path object, children of #idmefv2_process_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_path(idmefv2_process_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->path ) {
                retval = libidmefv2_string_new(&ptr->path);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->path;
        return 0;
}




/**
 * idmefv2_process_get_next_arg:
 * @process: pointer to a #idmefv2_process_t object.
 * @libidmefv2_string_cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *idmefv2_process_get_next_arg(idmefv2_process_t *process, libidmefv2_string_t *libidmefv2_string_cur)
{
        libidmefv2_list_t *tmp = (libidmefv2_string_cur) ? &((libidmefv2_linked_object_t *) libidmefv2_string_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(process, NULL);

        libidmefv2_list_for_each_continue(&process->arg_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_process_set_arg:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libidmefv2_string_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_process_set_arg(idmefv2_process_t *ptr, libidmefv2_string_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->arg_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_process_new_arg:
 *  @ptr: pointer to a #idmefv2_process_t object.
 *  @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *  @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_arg(idmefv2_process_t *ptr, libidmefv2_string_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = libidmefv2_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->arg_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_process_get_next_env:
 * @process: pointer to a #idmefv2_process_t object.
 * @libidmefv2_string_cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *idmefv2_process_get_next_env(idmefv2_process_t *process, libidmefv2_string_t *libidmefv2_string_cur)
{
        libidmefv2_list_t *tmp = (libidmefv2_string_cur) ? &((libidmefv2_linked_object_t *) libidmefv2_string_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(process, NULL);

        libidmefv2_list_for_each_continue(&process->env_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_process_set_env:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libidmefv2_string_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_process_set_env(idmefv2_process_t *ptr, libidmefv2_string_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->env_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_process_new_env:
 *  @ptr: pointer to a #idmefv2_process_t object.
 *  @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *  @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_env(idmefv2_process_t *ptr, libidmefv2_string_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = libidmefv2_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->env_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_process_get_tid:
 * @ptr: pointer to a #idmefv2_process_t object.
 *
 * Get tid children of the #idmefv2_process_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_process_get_tid(idmefv2_process_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->tid_is_set ? &ptr->tid : NULL;


}


/**
 * idmefv2_process_set_tid:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @tid: pointer to a #uint32_t object.
 *
 * Set @tid object as a children of @ptr.
 * if @ptr already contain an @tid object, then it is destroyed,
 * and updated to point to the provided @tid object.
 */
void idmefv2_process_set_tid(idmefv2_process_t *ptr, uint32_t tid)
{
        libidmefv2_return_if_fail(ptr);
        ptr->tid = tid;
        ptr->tid_is_set = 1;
}

void idmefv2_process_unset_tid(idmefv2_process_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->tid_is_set = 0;
}
/**
 * idmefv2_process_new_tid:
 * @ptr: pointer to a #idmefv2_process_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new tid object, children of #idmefv2_process_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_process_new_tid(idmefv2_process_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->tid_is_set = 1;



        *ret = &ptr->tid;
        return 0;
}



/**
 * idmefv2_process_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_process_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_process_copy(const idmefv2_process_t *src, idmefv2_process_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        dst->pid_is_set = src->pid_is_set;
        dst->pid = src->pid;



        if ( dst->path ) {
                libidmefv2_string_destroy(dst->path);
                dst->path = NULL;
        }

        if ( src->path ) {
                ret = libidmefv2_string_clone(src->path, &dst->path);
                if ( ret < 0 )
                        return ret;
        }



         {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->arg_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->arg_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->arg_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }


         {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->env_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->env_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->env_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }


        dst->tid_is_set = src->tid_is_set;
        dst->tid = src->tid;
    return 0 ;
}


/**
 * idmefv2_process_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_process_clone(idmefv2_process_t *src, idmefv2_process_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_process_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_process_copy(src, *dst);
}


/**
 * idmefv2_process_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_process_compare(const idmefv2_process_t *obj1, const idmefv2_process_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        if ( obj1->pid_is_set != obj2->pid_is_set )
                return -1;

        if ( obj1->pid_is_set && obj1->pid != obj2->pid )
                return -1;


        ret = libidmefv2_string_compare(obj1->path, obj2->path);
        if ( ret != 0 )
                return ret;

        {
            libidmefv2_list_t *tmp1, *tmp2;
            libidmefv2_string_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->arg_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->arg_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = libidmefv2_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        {
            libidmefv2_list_t *tmp1, *tmp2;
            libidmefv2_string_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->env_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->env_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = libidmefv2_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        if ( obj1->tid_is_set != obj2->tid_is_set )
                return -1;

        if ( obj1->tid_is_set && obj1->tid != obj2->tid )
                return -1;

        return ret;
}


        



/**
 * idmefv2_service_new:
 * @ret: Pointer where to store the created #idmefv2_service_t object.
 *
 * Create a new #idmefv2_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_service_new(idmefv2_service_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_SERVICE;


        (*ret)->refcount = 1;







            return 0;
}


/**
 * idmefv2_service_ref:
 * @service: pointer to a #idmefv2_service_t object.
 *
 * Increase @service reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @service.
 */
idmefv2_service_t *idmefv2_service_ref(idmefv2_service_t *service)
{
        libidmefv2_return_val_if_fail(service, NULL);
        service->refcount++;

        return service;
}



int _idmefv2_service_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_service_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:
                         return (ptr->iana_protocol_number_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->iana_protocol_number) : 0;


            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->iana_protocol_name, TRUE);



            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 4:
                         return (ptr->port_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->port) : 0;


            case 5:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->portlist, TRUE);



            case 6:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->protocol, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_service_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_service_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_service_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_service_new_iana_protocol_number(ptr, (uint32_t **) ret);

                case 2:
                    return idmefv2_service_new_iana_protocol_name(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_service_new_name(ptr, (libidmefv2_string_t **) ret);

                case 4:
                    return idmefv2_service_new_port(ptr, (uint32_t **) ret);

                case 5:
                    return idmefv2_service_new_portlist(ptr, (libidmefv2_string_t **) ret);

                case 6:
                    return idmefv2_service_new_protocol(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_service_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_service_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;

                case 1:
                        ptr->iana_protocol_number_is_set = 0;
                        return 0;




                case 2:
                        if ( ptr->iana_protocol_name ) {
                                libidmefv2_string_destroy(ptr->iana_protocol_name);
                                ptr->iana_protocol_name = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 4:
                        ptr->port_is_set = 0;
                        return 0;




                case 5:
                        if ( ptr->portlist ) {
                                libidmefv2_string_destroy(ptr->portlist);
                                ptr->portlist = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->protocol ) {
                                libidmefv2_string_destroy(ptr->protocol);
                                ptr->protocol = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_service_destroy_internal(idmefv2_service_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }





        if ( ptr->iana_protocol_name ) {
                libidmefv2_string_destroy(ptr->iana_protocol_name);
                ptr->iana_protocol_name = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }





        if ( ptr->portlist ) {
                libidmefv2_string_destroy(ptr->portlist);
                ptr->portlist = NULL;
        }



        if ( ptr->protocol ) {
                libidmefv2_string_destroy(ptr->protocol);
                ptr->protocol = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_service_destroy:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_service_destroy(idmefv2_service_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_service_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_service_get_ident:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get ident children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_service_get_ident(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_service_set_ident:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_service_set_ident(idmefv2_service_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_service_new_ident:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_service_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_ident(idmefv2_service_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}




/**
 * idmefv2_service_get_iana_protocol_number:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get iana_protocol_number children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_service_get_iana_protocol_number(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->iana_protocol_number_is_set ? &ptr->iana_protocol_number : NULL;


}


/**
 * idmefv2_service_set_iana_protocol_number:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @iana_protocol_number: pointer to a #uint32_t object.
 *
 * Set @iana_protocol_number object as a children of @ptr.
 * if @ptr already contain an @iana_protocol_number object, then it is destroyed,
 * and updated to point to the provided @iana_protocol_number object.
 */
void idmefv2_service_set_iana_protocol_number(idmefv2_service_t *ptr, uint32_t iana_protocol_number)
{
        libidmefv2_return_if_fail(ptr);
        ptr->iana_protocol_number = iana_protocol_number;
        ptr->iana_protocol_number_is_set = 1;
}

void idmefv2_service_unset_iana_protocol_number(idmefv2_service_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->iana_protocol_number_is_set = 0;
}
/**
 * idmefv2_service_new_iana_protocol_number:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new iana_protocol_number object, children of #idmefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_iana_protocol_number(idmefv2_service_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->iana_protocol_number_is_set = 1;



        *ret = &ptr->iana_protocol_number;
        return 0;
}




/**
 * idmefv2_service_get_iana_protocol_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get iana_protocol_name children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_service_get_iana_protocol_name(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->iana_protocol_name;

}


/**
 * idmefv2_service_set_iana_protocol_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @iana_protocol_name: pointer to a #libidmefv2_string_t object.
 *
 * Set @iana_protocol_name object as a children of @ptr.
 * if @ptr already contain an @iana_protocol_name object, then it is destroyed,
 * and updated to point to the provided @iana_protocol_name object.
 */

void idmefv2_service_set_iana_protocol_name(idmefv2_service_t *ptr, libidmefv2_string_t *iana_protocol_name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->iana_protocol_name )
                libidmefv2_string_destroy(ptr->iana_protocol_name);

        ptr->iana_protocol_name = iana_protocol_name;
}
/**
 * idmefv2_service_new_iana_protocol_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new iana_protocol_name object, children of #idmefv2_service_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_iana_protocol_name(idmefv2_service_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->iana_protocol_name ) {
                retval = libidmefv2_string_new(&ptr->iana_protocol_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->iana_protocol_name;
        return 0;
}




/**
 * idmefv2_service_get_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get name children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_service_get_name(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_service_set_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_service_set_name(idmefv2_service_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_service_new_name:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_service_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_name(idmefv2_service_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_service_get_port:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get port children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_service_get_port(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->port_is_set ? &ptr->port : NULL;


}


/**
 * idmefv2_service_set_port:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @port: pointer to a #uint32_t object.
 *
 * Set @port object as a children of @ptr.
 * if @ptr already contain an @port object, then it is destroyed,
 * and updated to point to the provided @port object.
 */
void idmefv2_service_set_port(idmefv2_service_t *ptr, uint32_t port)
{
        libidmefv2_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}

void idmefv2_service_unset_port(idmefv2_service_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->port_is_set = 0;
}
/**
 * idmefv2_service_new_port:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new port object, children of #idmefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_port(idmefv2_service_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->port_is_set = 1;



        *ret = &ptr->port;
        return 0;
}




/**
 * idmefv2_service_get_portlist:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get portlist children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_service_get_portlist(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->portlist;

}


/**
 * idmefv2_service_set_portlist:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @portlist: pointer to a #libidmefv2_string_t object.
 *
 * Set @portlist object as a children of @ptr.
 * if @ptr already contain an @portlist object, then it is destroyed,
 * and updated to point to the provided @portlist object.
 */

void idmefv2_service_set_portlist(idmefv2_service_t *ptr, libidmefv2_string_t *portlist)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->portlist )
                libidmefv2_string_destroy(ptr->portlist);

        ptr->portlist = portlist;
}
/**
 * idmefv2_service_new_portlist:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new portlist object, children of #idmefv2_service_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_portlist(idmefv2_service_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->portlist ) {
                retval = libidmefv2_string_new(&ptr->portlist);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->portlist;
        return 0;
}




/**
 * idmefv2_service_get_protocol:
 * @ptr: pointer to a #idmefv2_service_t object.
 *
 * Get protocol children of the #idmefv2_service_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_service_get_protocol(idmefv2_service_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->protocol;

}


/**
 * idmefv2_service_set_protocol:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @protocol: pointer to a #libidmefv2_string_t object.
 *
 * Set @protocol object as a children of @ptr.
 * if @ptr already contain an @protocol object, then it is destroyed,
 * and updated to point to the provided @protocol object.
 */

void idmefv2_service_set_protocol(idmefv2_service_t *ptr, libidmefv2_string_t *protocol)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->protocol )
                libidmefv2_string_destroy(ptr->protocol);

        ptr->protocol = protocol;
}
/**
 * idmefv2_service_new_protocol:
 * @ptr: pointer to a #idmefv2_service_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new protocol object, children of #idmefv2_service_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_service_new_protocol(idmefv2_service_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->protocol ) {
                retval = libidmefv2_string_new(&ptr->protocol);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->protocol;
        return 0;
}



/**
 * idmefv2_service_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_service_copy(const idmefv2_service_t *src, idmefv2_service_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }



        dst->iana_protocol_number_is_set = src->iana_protocol_number_is_set;
        dst->iana_protocol_number = src->iana_protocol_number;



        if ( dst->iana_protocol_name ) {
                libidmefv2_string_destroy(dst->iana_protocol_name);
                dst->iana_protocol_name = NULL;
        }

        if ( src->iana_protocol_name ) {
                ret = libidmefv2_string_clone(src->iana_protocol_name, &dst->iana_protocol_name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->name ) {
                libidmefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libidmefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }



        dst->port_is_set = src->port_is_set;
        dst->port = src->port;



        if ( dst->portlist ) {
                libidmefv2_string_destroy(dst->portlist);
                dst->portlist = NULL;
        }

        if ( src->portlist ) {
                ret = libidmefv2_string_clone(src->portlist, &dst->portlist);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->protocol ) {
                libidmefv2_string_destroy(dst->protocol);
                dst->protocol = NULL;
        }

        if ( src->protocol ) {
                ret = libidmefv2_string_clone(src->protocol, &dst->protocol);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_service_clone(idmefv2_service_t *src, idmefv2_service_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_service_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_service_copy(src, *dst);
}


/**
 * idmefv2_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_service_compare(const idmefv2_service_t *obj1, const idmefv2_service_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;

        if ( obj1->iana_protocol_number_is_set != obj2->iana_protocol_number_is_set )
                return -1;

        if ( obj1->iana_protocol_number_is_set && obj1->iana_protocol_number != obj2->iana_protocol_number )
                return -1;


        ret = libidmefv2_string_compare(obj1->iana_protocol_name, obj2->iana_protocol_name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        if ( obj1->port_is_set != obj2->port_is_set )
                return -1;

        if ( obj1->port_is_set && obj1->port != obj2->port )
                return -1;


        ret = libidmefv2_string_compare(obj1->portlist, obj2->portlist);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->protocol, obj2->protocol);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_node_new:
 * @ret: Pointer where to store the created #idmefv2_node_t object.
 *
 * Create a new #idmefv2_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_new(idmefv2_node_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_NODE;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->node_name_list);


        libidmefv2_list_init(&(*ret)->interface_list);








            return 0;
}


/**
 * idmefv2_node_ref:
 * @node: pointer to a #idmefv2_node_t object.
 *
 * Increase @node reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node.
 */
idmefv2_node_t *idmefv2_node_ref(idmefv2_node_t *node)
{
        libidmefv2_return_val_if_fail(node, NULL);
        node->refcount++;

        return node;
}



int _idmefv2_node_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_node_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);



            case 1:
                *childptr = ptr->location;
                return 0;

            case 2:
                *childptr = &ptr->node_name_list;
                return 0;

            case 3:
                *childptr = &ptr->interface_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_node_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_node_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_node_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_node_new_location(ptr, (idmefv2_location_t **) ret);

                case 2: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_node_new_node_name(ptr, (idmefv2_node_name_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->node_name_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->node_name_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_node_new_node_name(ptr, (idmefv2_node_name_t **) ret, n);
                }

                case 3: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_node_new_interface(ptr, (idmefv2_interface_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->interface_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->interface_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_node_new_interface(ptr, (idmefv2_interface_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_node_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_node_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->location ) {
                                idmefv2_location_destroy(ptr->location);
                                ptr->location = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->node_name_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_node_name_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->node_name_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_node_name_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 3: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->interface_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_interface_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->interface_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_interface_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_node_destroy_internal(idmefv2_node_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }




        if ( ptr->location ) {
                idmefv2_location_destroy(ptr->location);
                ptr->location = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_node_name_t *entry;

                libidmefv2_list_for_each_safe(&ptr->node_name_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_node_name_destroy(entry);
                }
        }


        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_interface_t *entry;

                libidmefv2_list_for_each_safe(&ptr->interface_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_interface_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_node_destroy:
 * @ptr: pointer to a #idmefv2_node_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_node_destroy(idmefv2_node_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_node_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_node_get_ident:
 * @ptr: pointer to a #idmefv2_node_t object.
 *
 * Get ident children of the #idmefv2_node_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_node_get_ident(idmefv2_node_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_node_set_ident:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_node_set_ident(idmefv2_node_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_node_new_ident:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_node_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_new_ident(idmefv2_node_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}




/**
 * idmefv2_node_get_location:
 * @ptr: pointer to a #idmefv2_node_t object.
 *
 * Get location children of the #idmefv2_node_t object.
 *
 * Returns: a pointer to a idmefv2_location_t object, or NULL if the children object is not set.
 */
idmefv2_location_t *idmefv2_node_get_location(idmefv2_node_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->location;

}


/**
 * idmefv2_node_set_location:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @location: pointer to a #idmefv2_location_t object.
 *
 * Set @location object as a children of @ptr.
 * if @ptr already contain an @location object, then it is destroyed,
 * and updated to point to the provided @location object.
 */

void idmefv2_node_set_location(idmefv2_node_t *ptr, idmefv2_location_t *location)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->location )
                idmefv2_location_destroy(ptr->location);

        ptr->location = location;
}
/**
 * idmefv2_node_new_location:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @ret: pointer to an address where to store the created #idmefv2_location_t object.
 *
 * Create a new location object, children of #idmefv2_node_t.
 * If @ptr already contain a #idmefv2_location_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_new_location(idmefv2_node_t *ptr, idmefv2_location_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->location ) {
                retval = idmefv2_location_new(&ptr->location);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->location;
        return 0;
}





/**
 * idmefv2_node_get_next_node_name:
 * @node: pointer to a #idmefv2_node_t object.
 * @node_name_cur: pointer to a #idmefv2_node_name_t object.
 *
 * Get the next #idmefv2_node_name_t object listed in @ptr.
 * When iterating over the idmefv2_node_name_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_node_name_t object.
 *
 * Returns: the next #idmefv2_node_name_t in the list.
 */
idmefv2_node_name_t *idmefv2_node_get_next_node_name(idmefv2_node_t *node, idmefv2_node_name_t *node_name_cur)
{
        libidmefv2_list_t *tmp = (node_name_cur) ? &((libidmefv2_linked_object_t *) node_name_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(node, NULL);

        libidmefv2_list_for_each_continue(&node->node_name_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_node_set_node_name:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @object: pointer to a #idmefv2_node_name_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_node_name_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_node_set_node_name(idmefv2_node_t *ptr, idmefv2_node_name_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->node_name_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_node_new_node_name:
 *  @ptr: pointer to a #idmefv2_node_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_node_name_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_node_name_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_node_name_t object. The created #idmefv2_node_name_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_new_node_name(idmefv2_node_t *ptr, idmefv2_node_name_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_node_name_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->node_name_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * idmefv2_node_get_next_interface:
 * @node: pointer to a #idmefv2_node_t object.
 * @interface_cur: pointer to a #idmefv2_interface_t object.
 *
 * Get the next #idmefv2_interface_t object listed in @ptr.
 * When iterating over the idmefv2_interface_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_interface_t object.
 *
 * Returns: the next #idmefv2_interface_t in the list.
 */
idmefv2_interface_t *idmefv2_node_get_next_interface(idmefv2_node_t *node, idmefv2_interface_t *interface_cur)
{
        libidmefv2_list_t *tmp = (interface_cur) ? &((libidmefv2_linked_object_t *) interface_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(node, NULL);

        libidmefv2_list_for_each_continue(&node->interface_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_node_set_interface:
 * @ptr: pointer to a #idmefv2_node_t object.
 * @object: pointer to a #idmefv2_interface_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_interface_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_node_set_interface(idmefv2_node_t *ptr, idmefv2_interface_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->interface_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_node_new_interface:
 *  @ptr: pointer to a #idmefv2_node_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_interface_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_interface_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_interface_t object. The created #idmefv2_interface_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_node_new_interface(idmefv2_node_t *ptr, idmefv2_interface_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_interface_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->interface_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_node_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_copy(const idmefv2_node_t *src, idmefv2_node_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->location ) {
                idmefv2_location_destroy(dst->location);
                dst->location = NULL;
        }

        if ( src->location ) {
                ret = idmefv2_location_clone(src->location, &dst->location);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_node_name_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->node_name_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_node_name_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->node_name_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_node_name_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->node_name_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_interface_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->interface_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_interface_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->interface_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_interface_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->interface_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_node_clone(idmefv2_node_t *src, idmefv2_node_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_node_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_node_copy(src, *dst);
}


/**
 * idmefv2_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_node_compare(const idmefv2_node_t *obj1, const idmefv2_node_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_location_compare(obj1->location, obj2->location);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_node_name_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->node_name_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->node_name_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_node_name_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_interface_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->interface_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->interface_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_interface_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_user_new:
 * @ret: Pointer where to store the created #idmefv2_user_t object.
 *
 * Create a new #idmefv2_user_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_new(idmefv2_user_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_USER;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->user_id_list);






            return 0;
}


/**
 * idmefv2_user_ref:
 * @user: pointer to a #idmefv2_user_t object.
 *
 * Increase @user reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @user.
 */
idmefv2_user_t *idmefv2_user_ref(idmefv2_user_t *user)
{
        libidmefv2_return_val_if_fail(user, NULL);
        user->refcount++;

        return user;
}



int _idmefv2_user_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_user_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_USER_CATEGORY , ptr->category);

            case 2:
                *childptr = &ptr->user_id_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_user_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_user_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_user_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_user_new_category(ptr, (idmefv2_user_category_t **) ret);

                case 2: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_user_new_user_id(ptr, (idmefv2_user_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->user_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->user_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_user_new_user_id(ptr, (idmefv2_user_id_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_user_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_user_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                    ptr->category = 0;
                    return 0;

    
                case 2: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->user_id_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_user_id_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->user_id_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_user_id_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_user_destroy_internal(idmefv2_user_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }






        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_user_id_t *entry;

                libidmefv2_list_for_each_safe(&ptr->user_id_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_user_id_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_user_destroy:
 * @ptr: pointer to a #idmefv2_user_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_user_destroy(idmefv2_user_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_user_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_user_get_ident:
 * @ptr: pointer to a #idmefv2_user_t object.
 *
 * Get ident children of the #idmefv2_user_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_user_get_ident(idmefv2_user_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_user_set_ident:
 * @ptr: pointer to a #idmefv2_user_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_user_set_ident(idmefv2_user_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_user_new_ident:
 * @ptr: pointer to a #idmefv2_user_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_user_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_new_ident(idmefv2_user_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}



/**
 * idmefv2_user_get_category:
 * @ptr: pointer to a #idmefv2_user_t object.
 *
 * Get category children of the #idmefv2_user_t object.
 *
 * Returns: a pointer to a idmefv2_user_category_t object, or NULL if the children object is not set.
 */
idmefv2_user_category_t idmefv2_user_get_category(idmefv2_user_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_user_set_category:
 * @ptr: pointer to a #idmefv2_user_t object.
 * @category: pointer to a #idmefv2_user_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_user_set_category(idmefv2_user_t *ptr, idmefv2_user_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_user_new_category:
 * @ptr: pointer to a #idmefv2_user_t object.
 * @ret: pointer to an address where to store the created #idmefv2_user_category_t object.
 *
 * Create a new category object, children of #idmefv2_user_t.
 * If @ptr already contain a #idmefv2_user_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_new_category(idmefv2_user_t *ptr, idmefv2_user_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}





/**
 * idmefv2_user_get_next_user_id:
 * @user: pointer to a #idmefv2_user_t object.
 * @user_id_cur: pointer to a #idmefv2_user_id_t object.
 *
 * Get the next #idmefv2_user_id_t object listed in @ptr.
 * When iterating over the idmefv2_user_id_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_user_id_t object.
 *
 * Returns: the next #idmefv2_user_id_t in the list.
 */
idmefv2_user_id_t *idmefv2_user_get_next_user_id(idmefv2_user_t *user, idmefv2_user_id_t *user_id_cur)
{
        libidmefv2_list_t *tmp = (user_id_cur) ? &((libidmefv2_linked_object_t *) user_id_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(user, NULL);

        libidmefv2_list_for_each_continue(&user->user_id_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_user_set_user_id:
 * @ptr: pointer to a #idmefv2_user_t object.
 * @object: pointer to a #idmefv2_user_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_user_id_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_user_set_user_id(idmefv2_user_t *ptr, idmefv2_user_id_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->user_id_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_user_new_user_id:
 *  @ptr: pointer to a #idmefv2_user_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_user_id_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_user_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_user_id_t object. The created #idmefv2_user_id_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_user_new_user_id(idmefv2_user_t *ptr, idmefv2_user_id_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_user_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->user_id_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_user_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_user_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_copy(const idmefv2_user_t *src, idmefv2_user_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }




        dst->category = src->category;



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_user_id_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->user_id_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_user_id_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->user_id_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_user_id_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->user_id_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_user_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_user_clone(idmefv2_user_t *src, idmefv2_user_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_user_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_user_copy(src, *dst);
}


/**
 * idmefv2_user_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_user_compare(const idmefv2_user_t *obj1, const idmefv2_user_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        if ( obj1->category != obj2->category )
                return -1;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_user_id_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->user_id_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->user_id_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_user_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_impact_type_new:
 * @ret: Pointer where to store the created #idmefv2_impact_type_t object.
 *
 * Create a new #idmefv2_impact_type_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_type_new(idmefv2_impact_type_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_IMPACT_TYPE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_impact_type_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->url);

            if ( retval < 0 ) {
                    idmefv2_impact_type_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_impact_type_ref:
 * @impact_type: pointer to a #idmefv2_impact_type_t object.
 *
 * Increase @impact_type reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @impact_type.
 */
idmefv2_impact_type_t *idmefv2_impact_type_ref(idmefv2_impact_type_t *impact_type)
{
        libidmefv2_return_val_if_fail(impact_type, NULL);
        impact_type->refcount++;

        return impact_type;
}



int _idmefv2_impact_type_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_impact_type_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_TYPE_ORIGIN , ptr->origin);


            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->meaning, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->url, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_impact_type_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_impact_type_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_impact_type_new_origin(ptr, (idmefv2_impact_type_origin_t **) ret);

                case 1:
                    return idmefv2_impact_type_new_meaning(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_impact_type_new_name(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_impact_type_new_url(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_impact_type_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_impact_type_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->origin = 0;
                    return 0;




                case 1:
                        if ( ptr->meaning ) {
                                libidmefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->url ) {
                                libidmefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_impact_type_destroy_internal(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);



        if ( ptr->meaning ) {
                libidmefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->url ) {
                libidmefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_impact_type_destroy:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_impact_type_destroy(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_impact_type_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_impact_type_get_origin:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Get origin children of the #idmefv2_impact_type_t object.
 *
 * Returns: a pointer to a idmefv2_impact_type_origin_t object, or NULL if the children object is not set.
 */
idmefv2_impact_type_origin_t idmefv2_impact_type_get_origin(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->origin;

}


/**
 * idmefv2_impact_type_set_origin:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @origin: pointer to a #idmefv2_impact_type_origin_t object.
 *
 * Set @origin object as a children of @ptr.
 * if @ptr already contain an @origin object, then it is destroyed,
 * and updated to point to the provided @origin object.
 */
void idmefv2_impact_type_set_origin(idmefv2_impact_type_t *ptr, idmefv2_impact_type_origin_t origin)
{
        libidmefv2_return_if_fail(ptr);
        ptr->origin = origin;
}
/**
 * idmefv2_impact_type_new_origin:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_type_origin_t object.
 *
 * Create a new origin object, children of #idmefv2_impact_type_t.
 * If @ptr already contain a #idmefv2_impact_type_origin_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_type_new_origin(idmefv2_impact_type_t *ptr, idmefv2_impact_type_origin_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->origin;
        return 0;
}




/**
 * idmefv2_impact_type_get_meaning:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Get meaning children of the #idmefv2_impact_type_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_impact_type_get_meaning(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * idmefv2_impact_type_set_meaning:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @meaning: pointer to a #libidmefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmefv2_impact_type_set_meaning(idmefv2_impact_type_t *ptr, libidmefv2_string_t *meaning)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libidmefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * idmefv2_impact_type_new_meaning:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new meaning object, children of #idmefv2_impact_type_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_type_new_meaning(idmefv2_impact_type_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libidmefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}




/**
 * idmefv2_impact_type_get_name:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Get name children of the #idmefv2_impact_type_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_impact_type_get_name(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_impact_type_set_name:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_impact_type_set_name(idmefv2_impact_type_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_impact_type_new_name:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_impact_type_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_type_new_name(idmefv2_impact_type_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_impact_type_get_url:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 *
 * Get url children of the #idmefv2_impact_type_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_impact_type_get_url(idmefv2_impact_type_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * idmefv2_impact_type_set_url:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @url: pointer to a #libidmefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void idmefv2_impact_type_set_url(idmefv2_impact_type_t *ptr, libidmefv2_string_t *url)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->url )
                libidmefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * idmefv2_impact_type_new_url:
 * @ptr: pointer to a #idmefv2_impact_type_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new url object, children of #idmefv2_impact_type_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_type_new_url(idmefv2_impact_type_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libidmefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}



/**
 * idmefv2_impact_type_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_impact_type_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_type_copy(const idmefv2_impact_type_t *src, idmefv2_impact_type_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->origin = src->origin;



        if ( dst->meaning ) {
                libidmefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libidmefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->url ) {
                ret = libidmefv2_string_copy(src->url, dst->url);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_impact_type_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_type_clone(idmefv2_impact_type_t *src, idmefv2_impact_type_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_impact_type_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_impact_type_copy(src, *dst);
}


/**
 * idmefv2_impact_type_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_impact_type_compare(const idmefv2_impact_type_t *obj1, const idmefv2_impact_type_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->origin != obj2->origin )
                return -1;

        ret = libidmefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_source_new:
 * @ret: Pointer where to store the created #idmefv2_source_t object.
 *
 * Create a new #idmefv2_source_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_source_new(idmefv2_source_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_SOURCE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;











            return 0;
}


/**
 * idmefv2_source_ref:
 * @source: pointer to a #idmefv2_source_t object.
 *
 * Increase @source reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @source.
 */
idmefv2_source_t *idmefv2_source_ref(idmefv2_source_t *source)
{
        libidmefv2_return_val_if_fail(source, NULL);
        source->refcount++;

        return source;
}



int _idmefv2_source_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_source_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_SOURCE_SPOOFED , ptr->spoofed);


            case 2:
                *childptr = ptr->node;
                return 0;


            case 3:
                *childptr = ptr->user;
                return 0;


            case 4:
                *childptr = ptr->process;
                return 0;


            case 5:
                *childptr = ptr->service;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_source_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_source_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_source_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_source_new_spoofed(ptr, (idmefv2_source_spoofed_t **) ret);

                case 2:
                    return idmefv2_source_new_node(ptr, (idmefv2_node_t **) ret);

                case 3:
                    return idmefv2_source_new_user(ptr, (idmefv2_user_t **) ret);

                case 4:
                    return idmefv2_source_new_process(ptr, (idmefv2_process_t **) ret);

                case 5:
                    return idmefv2_source_new_service(ptr, (idmefv2_service_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_source_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_source_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                    ptr->spoofed = 0;
                    return 0;




                case 2:
                        if ( ptr->node ) {
                                idmefv2_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->user ) {
                                idmefv2_user_destroy(ptr->user);
                                ptr->user = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->process ) {
                                idmefv2_process_destroy(ptr->process);
                                ptr->process = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->service ) {
                                idmefv2_service_destroy(ptr->service);
                                ptr->service = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_source_destroy_internal(idmefv2_source_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }






        if ( ptr->node ) {
                idmefv2_node_destroy(ptr->node);
                ptr->node = NULL;
        }




        if ( ptr->user ) {
                idmefv2_user_destroy(ptr->user);
                ptr->user = NULL;
        }




        if ( ptr->process ) {
                idmefv2_process_destroy(ptr->process);
                ptr->process = NULL;
        }




        if ( ptr->service ) {
                idmefv2_service_destroy(ptr->service);
                ptr->service = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_source_destroy:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_source_destroy(idmefv2_source_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_source_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_source_get_ident:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get ident children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_source_get_ident(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_source_set_ident:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_source_set_ident(idmefv2_source_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_source_new_ident:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_source_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_ident(idmefv2_source_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}



/**
 * idmefv2_source_get_spoofed:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get spoofed children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a idmefv2_source_spoofed_t object, or NULL if the children object is not set.
 */
idmefv2_source_spoofed_t idmefv2_source_get_spoofed(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->spoofed;

}


/**
 * idmefv2_source_set_spoofed:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @spoofed: pointer to a #idmefv2_source_spoofed_t object.
 *
 * Set @spoofed object as a children of @ptr.
 * if @ptr already contain an @spoofed object, then it is destroyed,
 * and updated to point to the provided @spoofed object.
 */
void idmefv2_source_set_spoofed(idmefv2_source_t *ptr, idmefv2_source_spoofed_t spoofed)
{
        libidmefv2_return_if_fail(ptr);
        ptr->spoofed = spoofed;
}
/**
 * idmefv2_source_new_spoofed:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #idmefv2_source_spoofed_t object.
 *
 * Create a new spoofed object, children of #idmefv2_source_t.
 * If @ptr already contain a #idmefv2_source_spoofed_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_spoofed(idmefv2_source_t *ptr, idmefv2_source_spoofed_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->spoofed;
        return 0;
}




/**
 * idmefv2_source_get_node:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get node children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a idmefv2_node_t object, or NULL if the children object is not set.
 */
idmefv2_node_t *idmefv2_source_get_node(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;

}


/**
 * idmefv2_source_set_node:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @node: pointer to a #idmefv2_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmefv2_source_set_node(idmefv2_source_t *ptr, idmefv2_node_t *node)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->node )
                idmefv2_node_destroy(ptr->node);

        ptr->node = node;
}
/**
 * idmefv2_source_new_node:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #idmefv2_node_t object.
 *
 * Create a new node object, children of #idmefv2_source_t.
 * If @ptr already contain a #idmefv2_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_node(idmefv2_source_t *ptr, idmefv2_node_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = idmefv2_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->node;
        return 0;
}




/**
 * idmefv2_source_get_user:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get user children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a idmefv2_user_t object, or NULL if the children object is not set.
 */
idmefv2_user_t *idmefv2_source_get_user(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->user;

}


/**
 * idmefv2_source_set_user:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @user: pointer to a #idmefv2_user_t object.
 *
 * Set @user object as a children of @ptr.
 * if @ptr already contain an @user object, then it is destroyed,
 * and updated to point to the provided @user object.
 */

void idmefv2_source_set_user(idmefv2_source_t *ptr, idmefv2_user_t *user)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->user )
                idmefv2_user_destroy(ptr->user);

        ptr->user = user;
}
/**
 * idmefv2_source_new_user:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #idmefv2_user_t object.
 *
 * Create a new user object, children of #idmefv2_source_t.
 * If @ptr already contain a #idmefv2_user_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_user(idmefv2_source_t *ptr, idmefv2_user_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->user ) {
                retval = idmefv2_user_new(&ptr->user);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->user;
        return 0;
}




/**
 * idmefv2_source_get_process:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get process children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a idmefv2_process_t object, or NULL if the children object is not set.
 */
idmefv2_process_t *idmefv2_source_get_process(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->process;

}


/**
 * idmefv2_source_set_process:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @process: pointer to a #idmefv2_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmefv2_source_set_process(idmefv2_source_t *ptr, idmefv2_process_t *process)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->process )
                idmefv2_process_destroy(ptr->process);

        ptr->process = process;
}
/**
 * idmefv2_source_new_process:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #idmefv2_process_t object.
 *
 * Create a new process object, children of #idmefv2_source_t.
 * If @ptr already contain a #idmefv2_process_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_process(idmefv2_source_t *ptr, idmefv2_process_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->process ) {
                retval = idmefv2_process_new(&ptr->process);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->process;
        return 0;
}




/**
 * idmefv2_source_get_service:
 * @ptr: pointer to a #idmefv2_source_t object.
 *
 * Get service children of the #idmefv2_source_t object.
 *
 * Returns: a pointer to a idmefv2_service_t object, or NULL if the children object is not set.
 */
idmefv2_service_t *idmefv2_source_get_service(idmefv2_source_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->service;

}


/**
 * idmefv2_source_set_service:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @service: pointer to a #idmefv2_service_t object.
 *
 * Set @service object as a children of @ptr.
 * if @ptr already contain an @service object, then it is destroyed,
 * and updated to point to the provided @service object.
 */

void idmefv2_source_set_service(idmefv2_source_t *ptr, idmefv2_service_t *service)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->service )
                idmefv2_service_destroy(ptr->service);

        ptr->service = service;
}
/**
 * idmefv2_source_new_service:
 * @ptr: pointer to a #idmefv2_source_t object.
 * @ret: pointer to an address where to store the created #idmefv2_service_t object.
 *
 * Create a new service object, children of #idmefv2_source_t.
 * If @ptr already contain a #idmefv2_service_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_source_new_service(idmefv2_source_t *ptr, idmefv2_service_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->service ) {
                retval = idmefv2_service_new(&ptr->service);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->service;
        return 0;
}



/**
 * idmefv2_source_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_source_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_source_copy(const idmefv2_source_t *src, idmefv2_source_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }




        dst->spoofed = src->spoofed;




        if ( dst->node ) {
                idmefv2_node_destroy(dst->node);
                dst->node = NULL;
        }

        if ( src->node ) {
                ret = idmefv2_node_clone(src->node, &dst->node);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->user ) {
                idmefv2_user_destroy(dst->user);
                dst->user = NULL;
        }

        if ( src->user ) {
                ret = idmefv2_user_clone(src->user, &dst->user);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->process ) {
                idmefv2_process_destroy(dst->process);
                dst->process = NULL;
        }

        if ( src->process ) {
                ret = idmefv2_process_clone(src->process, &dst->process);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->service ) {
                idmefv2_service_destroy(dst->service);
                dst->service = NULL;
        }

        if ( src->service ) {
                ret = idmefv2_service_clone(src->service, &dst->service);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_source_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_source_clone(idmefv2_source_t *src, idmefv2_source_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_source_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_source_copy(src, *dst);
}


/**
 * idmefv2_source_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_source_compare(const idmefv2_source_t *obj1, const idmefv2_source_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        if ( obj1->spoofed != obj2->spoofed )
                return -1;


        ret = idmefv2_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_user_compare(obj1->user, obj2->user);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_process_compare(obj1->process, obj2->process);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_service_compare(obj1->service, obj2->service);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_target_new:
 * @ret: Pointer where to store the created #idmefv2_target_t object.
 *
 * Create a new #idmefv2_target_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_target_new(idmefv2_target_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_TARGET;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;













            return 0;
}


/**
 * idmefv2_target_ref:
 * @target: pointer to a #idmefv2_target_t object.
 *
 * Increase @target reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @target.
 */
idmefv2_target_t *idmefv2_target_ref(idmefv2_target_t *target)
{
        libidmefv2_return_val_if_fail(target, NULL);
        target->refcount++;

        return target;
}



int _idmefv2_target_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_target_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_TARGET_DECOY , ptr->decoy);


            case 2:
                *childptr = ptr->node;
                return 0;


            case 3:
                *childptr = ptr->user;
                return 0;


            case 4:
                *childptr = ptr->process;
                return 0;


            case 5:
                *childptr = ptr->service;
                return 0;


            case 6:
                *childptr = ptr->file;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_target_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_target_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_target_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_target_new_decoy(ptr, (idmefv2_target_decoy_t **) ret);

                case 2:
                    return idmefv2_target_new_node(ptr, (idmefv2_node_t **) ret);

                case 3:
                    return idmefv2_target_new_user(ptr, (idmefv2_user_t **) ret);

                case 4:
                    return idmefv2_target_new_process(ptr, (idmefv2_process_t **) ret);

                case 5:
                    return idmefv2_target_new_service(ptr, (idmefv2_service_t **) ret);

                case 6:
                    return idmefv2_target_new_file(ptr, (idmefv2_file_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_target_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_target_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                    ptr->decoy = 0;
                    return 0;




                case 2:
                        if ( ptr->node ) {
                                idmefv2_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->user ) {
                                idmefv2_user_destroy(ptr->user);
                                ptr->user = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->process ) {
                                idmefv2_process_destroy(ptr->process);
                                ptr->process = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->service ) {
                                idmefv2_service_destroy(ptr->service);
                                ptr->service = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->file ) {
                                idmefv2_file_destroy(ptr->file);
                                ptr->file = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_target_destroy_internal(idmefv2_target_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }






        if ( ptr->node ) {
                idmefv2_node_destroy(ptr->node);
                ptr->node = NULL;
        }




        if ( ptr->user ) {
                idmefv2_user_destroy(ptr->user);
                ptr->user = NULL;
        }




        if ( ptr->process ) {
                idmefv2_process_destroy(ptr->process);
                ptr->process = NULL;
        }




        if ( ptr->service ) {
                idmefv2_service_destroy(ptr->service);
                ptr->service = NULL;
        }




        if ( ptr->file ) {
                idmefv2_file_destroy(ptr->file);
                ptr->file = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_target_destroy:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_target_destroy(idmefv2_target_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_target_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_target_get_ident:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get ident children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_target_get_ident(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_target_set_ident:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_target_set_ident(idmefv2_target_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_target_new_ident:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_target_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_ident(idmefv2_target_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}



/**
 * idmefv2_target_get_decoy:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get decoy children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_target_decoy_t object, or NULL if the children object is not set.
 */
idmefv2_target_decoy_t idmefv2_target_get_decoy(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->decoy;

}


/**
 * idmefv2_target_set_decoy:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @decoy: pointer to a #idmefv2_target_decoy_t object.
 *
 * Set @decoy object as a children of @ptr.
 * if @ptr already contain an @decoy object, then it is destroyed,
 * and updated to point to the provided @decoy object.
 */
void idmefv2_target_set_decoy(idmefv2_target_t *ptr, idmefv2_target_decoy_t decoy)
{
        libidmefv2_return_if_fail(ptr);
        ptr->decoy = decoy;
}
/**
 * idmefv2_target_new_decoy:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_target_decoy_t object.
 *
 * Create a new decoy object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_target_decoy_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_decoy(idmefv2_target_t *ptr, idmefv2_target_decoy_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->decoy;
        return 0;
}




/**
 * idmefv2_target_get_node:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get node children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_node_t object, or NULL if the children object is not set.
 */
idmefv2_node_t *idmefv2_target_get_node(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;

}


/**
 * idmefv2_target_set_node:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @node: pointer to a #idmefv2_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmefv2_target_set_node(idmefv2_target_t *ptr, idmefv2_node_t *node)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->node )
                idmefv2_node_destroy(ptr->node);

        ptr->node = node;
}
/**
 * idmefv2_target_new_node:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_node_t object.
 *
 * Create a new node object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_node(idmefv2_target_t *ptr, idmefv2_node_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = idmefv2_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->node;
        return 0;
}




/**
 * idmefv2_target_get_user:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get user children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_user_t object, or NULL if the children object is not set.
 */
idmefv2_user_t *idmefv2_target_get_user(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->user;

}


/**
 * idmefv2_target_set_user:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @user: pointer to a #idmefv2_user_t object.
 *
 * Set @user object as a children of @ptr.
 * if @ptr already contain an @user object, then it is destroyed,
 * and updated to point to the provided @user object.
 */

void idmefv2_target_set_user(idmefv2_target_t *ptr, idmefv2_user_t *user)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->user )
                idmefv2_user_destroy(ptr->user);

        ptr->user = user;
}
/**
 * idmefv2_target_new_user:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_user_t object.
 *
 * Create a new user object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_user_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_user(idmefv2_target_t *ptr, idmefv2_user_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->user ) {
                retval = idmefv2_user_new(&ptr->user);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->user;
        return 0;
}




/**
 * idmefv2_target_get_process:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get process children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_process_t object, or NULL if the children object is not set.
 */
idmefv2_process_t *idmefv2_target_get_process(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->process;

}


/**
 * idmefv2_target_set_process:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @process: pointer to a #idmefv2_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmefv2_target_set_process(idmefv2_target_t *ptr, idmefv2_process_t *process)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->process )
                idmefv2_process_destroy(ptr->process);

        ptr->process = process;
}
/**
 * idmefv2_target_new_process:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_process_t object.
 *
 * Create a new process object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_process_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_process(idmefv2_target_t *ptr, idmefv2_process_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->process ) {
                retval = idmefv2_process_new(&ptr->process);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->process;
        return 0;
}




/**
 * idmefv2_target_get_service:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get service children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_service_t object, or NULL if the children object is not set.
 */
idmefv2_service_t *idmefv2_target_get_service(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->service;

}


/**
 * idmefv2_target_set_service:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @service: pointer to a #idmefv2_service_t object.
 *
 * Set @service object as a children of @ptr.
 * if @ptr already contain an @service object, then it is destroyed,
 * and updated to point to the provided @service object.
 */

void idmefv2_target_set_service(idmefv2_target_t *ptr, idmefv2_service_t *service)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->service )
                idmefv2_service_destroy(ptr->service);

        ptr->service = service;
}
/**
 * idmefv2_target_new_service:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_service_t object.
 *
 * Create a new service object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_service_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_service(idmefv2_target_t *ptr, idmefv2_service_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->service ) {
                retval = idmefv2_service_new(&ptr->service);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->service;
        return 0;
}




/**
 * idmefv2_target_get_file:
 * @ptr: pointer to a #idmefv2_target_t object.
 *
 * Get file children of the #idmefv2_target_t object.
 *
 * Returns: a pointer to a idmefv2_file_t object, or NULL if the children object is not set.
 */
idmefv2_file_t *idmefv2_target_get_file(idmefv2_target_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file;

}


/**
 * idmefv2_target_set_file:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @file: pointer to a #idmefv2_file_t object.
 *
 * Set @file object as a children of @ptr.
 * if @ptr already contain an @file object, then it is destroyed,
 * and updated to point to the provided @file object.
 */

void idmefv2_target_set_file(idmefv2_target_t *ptr, idmefv2_file_t *file)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->file )
                idmefv2_file_destroy(ptr->file);

        ptr->file = file;
}
/**
 * idmefv2_target_new_file:
 * @ptr: pointer to a #idmefv2_target_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_t object.
 *
 * Create a new file object, children of #idmefv2_target_t.
 * If @ptr already contain a #idmefv2_file_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_target_new_file(idmefv2_target_t *ptr, idmefv2_file_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->file ) {
                retval = idmefv2_file_new(&ptr->file);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file;
        return 0;
}



/**
 * idmefv2_target_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_target_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_target_copy(const idmefv2_target_t *src, idmefv2_target_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }




        dst->decoy = src->decoy;




        if ( dst->node ) {
                idmefv2_node_destroy(dst->node);
                dst->node = NULL;
        }

        if ( src->node ) {
                ret = idmefv2_node_clone(src->node, &dst->node);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->user ) {
                idmefv2_user_destroy(dst->user);
                dst->user = NULL;
        }

        if ( src->user ) {
                ret = idmefv2_user_clone(src->user, &dst->user);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->process ) {
                idmefv2_process_destroy(dst->process);
                dst->process = NULL;
        }

        if ( src->process ) {
                ret = idmefv2_process_clone(src->process, &dst->process);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->service ) {
                idmefv2_service_destroy(dst->service);
                dst->service = NULL;
        }

        if ( src->service ) {
                ret = idmefv2_service_clone(src->service, &dst->service);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->file ) {
                idmefv2_file_destroy(dst->file);
                dst->file = NULL;
        }

        if ( src->file ) {
                ret = idmefv2_file_clone(src->file, &dst->file);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_target_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_target_clone(idmefv2_target_t *src, idmefv2_target_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_target_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_target_copy(src, *dst);
}


/**
 * idmefv2_target_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_target_compare(const idmefv2_target_t *obj1, const idmefv2_target_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;


        if ( obj1->decoy != obj2->decoy )
                return -1;


        ret = idmefv2_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_user_compare(obj1->user, obj2->user);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_process_compare(obj1->process, obj2->process);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_service_compare(obj1->service, obj2->service);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_file_compare(obj1->file, obj2->file);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_original_data_new:
 * @ret: Pointer where to store the created #idmefv2_original_data_t object.
 *
 * Create a new #idmefv2_original_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_original_data_new(idmefv2_original_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ORIGINAL_DATA;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
            int retval = idmefv2_time_new(&(*ret)->timestamp);

            if ( retval < 0 ) {
                    idmefv2_original_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_original_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = idmefv2_data_new(&(*ret)->data);

            if ( retval < 0 ) {
                    idmefv2_original_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }




            return 0;
}


/**
 * idmefv2_original_data_ref:
 * @original_data: pointer to a #idmefv2_original_data_t object.
 *
 * Increase @original_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @original_data.
 */
idmefv2_original_data_t *idmefv2_original_data_ref(idmefv2_original_data_t *original_data)
{
        libidmefv2_return_val_if_fail(original_data, NULL);
        original_data->refcount++;

        return original_data;
}



int _idmefv2_original_data_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_original_data_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->timestamp, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 2:

                return get_value_from_data((idmefv2_value_t **) childptr,  ptr->data, TRUE);



            case 3:
                *childptr = ptr->node;
                return 0;


            case 4:
                *childptr = ptr->file;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_original_data_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_original_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_original_data_new_timestamp(ptr, (idmefv2_time_t **) ret);

                case 1:
                    return idmefv2_original_data_new_name(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_original_data_new_data(ptr, (idmefv2_data_t **) ret);

                case 3:
                    return idmefv2_original_data_new_node(ptr, (idmefv2_node_t **) ret);

                case 4:
                    return idmefv2_original_data_new_file(ptr, (idmefv2_file_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_original_data_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_original_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->timestamp ) {
                                idmefv2_time_destroy(ptr->timestamp);
                                ptr->timestamp = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->data ) {
                                idmefv2_data_destroy(ptr->data);
                                ptr->data = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->node ) {
                                idmefv2_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->file ) {
                                idmefv2_file_destroy(ptr->file);
                                ptr->file = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_original_data_destroy_internal(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->timestamp ) {
                idmefv2_time_destroy(ptr->timestamp);
                ptr->timestamp = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->data ) {
                idmefv2_data_destroy(ptr->data);
                ptr->data = NULL;
        }




        if ( ptr->node ) {
                idmefv2_node_destroy(ptr->node);
                ptr->node = NULL;
        }




        if ( ptr->file ) {
                idmefv2_file_destroy(ptr->file);
                ptr->file = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_original_data_destroy:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_original_data_destroy(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_original_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_original_data_get_timestamp:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Get timestamp children of the #idmefv2_original_data_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_original_data_get_timestamp(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->timestamp;

}


/**
 * idmefv2_original_data_set_timestamp:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @timestamp: pointer to a #idmefv2_time_t object.
 *
 * Set @timestamp object as a children of @ptr.
 * if @ptr already contain an @timestamp object, then it is destroyed,
 * and updated to point to the provided @timestamp object.
 */

void idmefv2_original_data_set_timestamp(idmefv2_original_data_t *ptr, idmefv2_time_t *timestamp)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->timestamp )
                idmefv2_time_destroy(ptr->timestamp);

        ptr->timestamp = timestamp;
}
/**
 * idmefv2_original_data_new_timestamp:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new timestamp object, children of #idmefv2_original_data_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_original_data_new_timestamp(idmefv2_original_data_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->timestamp ) {
                retval = idmefv2_time_new(&ptr->timestamp);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->timestamp;
        return 0;
}




/**
 * idmefv2_original_data_get_name:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Get name children of the #idmefv2_original_data_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_original_data_get_name(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_original_data_set_name:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_original_data_set_name(idmefv2_original_data_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_original_data_new_name:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_original_data_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_original_data_new_name(idmefv2_original_data_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_original_data_get_data:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Get data children of the #idmefv2_original_data_t object.
 *
 * Returns: a pointer to a idmefv2_data_t object, or NULL if the children object is not set.
 */
idmefv2_data_t *idmefv2_original_data_get_data(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data;

}


/**
 * idmefv2_original_data_set_data:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @data: pointer to a #idmefv2_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void idmefv2_original_data_set_data(idmefv2_original_data_t *ptr, idmefv2_data_t *data)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->data )
                idmefv2_data_destroy(ptr->data);

        ptr->data = data;
}
/**
 * idmefv2_original_data_new_data:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_data_t object.
 *
 * Create a new data object, children of #idmefv2_original_data_t.
 * If @ptr already contain a #idmefv2_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_original_data_new_data(idmefv2_original_data_t *ptr, idmefv2_data_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->data ) {
                retval = idmefv2_data_new(&ptr->data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->data;
        return 0;
}




/**
 * idmefv2_original_data_get_node:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Get node children of the #idmefv2_original_data_t object.
 *
 * Returns: a pointer to a idmefv2_node_t object, or NULL if the children object is not set.
 */
idmefv2_node_t *idmefv2_original_data_get_node(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;

}


/**
 * idmefv2_original_data_set_node:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @node: pointer to a #idmefv2_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmefv2_original_data_set_node(idmefv2_original_data_t *ptr, idmefv2_node_t *node)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->node )
                idmefv2_node_destroy(ptr->node);

        ptr->node = node;
}
/**
 * idmefv2_original_data_new_node:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_node_t object.
 *
 * Create a new node object, children of #idmefv2_original_data_t.
 * If @ptr already contain a #idmefv2_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_original_data_new_node(idmefv2_original_data_t *ptr, idmefv2_node_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = idmefv2_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->node;
        return 0;
}




/**
 * idmefv2_original_data_get_file:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 *
 * Get file children of the #idmefv2_original_data_t object.
 *
 * Returns: a pointer to a idmefv2_file_t object, or NULL if the children object is not set.
 */
idmefv2_file_t *idmefv2_original_data_get_file(idmefv2_original_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file;

}


/**
 * idmefv2_original_data_set_file:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @file: pointer to a #idmefv2_file_t object.
 *
 * Set @file object as a children of @ptr.
 * if @ptr already contain an @file object, then it is destroyed,
 * and updated to point to the provided @file object.
 */

void idmefv2_original_data_set_file(idmefv2_original_data_t *ptr, idmefv2_file_t *file)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->file )
                idmefv2_file_destroy(ptr->file);

        ptr->file = file;
}
/**
 * idmefv2_original_data_new_file:
 * @ptr: pointer to a #idmefv2_original_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_file_t object.
 *
 * Create a new file object, children of #idmefv2_original_data_t.
 * If @ptr already contain a #idmefv2_file_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_original_data_new_file(idmefv2_original_data_t *ptr, idmefv2_file_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->file ) {
                retval = idmefv2_file_new(&ptr->file);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file;
        return 0;
}



/**
 * idmefv2_original_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_original_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_original_data_copy(const idmefv2_original_data_t *src, idmefv2_original_data_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->timestamp ) {
                ret = idmefv2_time_copy(src->timestamp, dst->timestamp);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->data ) {
                ret = idmefv2_data_copy(src->data, dst->data);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->node ) {
                idmefv2_node_destroy(dst->node);
                dst->node = NULL;
        }

        if ( src->node ) {
                ret = idmefv2_node_clone(src->node, &dst->node);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->file ) {
                idmefv2_file_destroy(dst->file);
                dst->file = NULL;
        }

        if ( src->file ) {
                ret = idmefv2_file_clone(src->file, &dst->file);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_original_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_original_data_clone(idmefv2_original_data_t *src, idmefv2_original_data_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_original_data_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_original_data_copy(src, *dst);
}


/**
 * idmefv2_original_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_original_data_compare(const idmefv2_original_data_t *obj1, const idmefv2_original_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = idmefv2_time_compare(obj1->timestamp, obj2->timestamp);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_data_compare(obj1->data, obj2->data);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_file_compare(obj1->file, obj2->file);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_observable_new:
 * @ret: Pointer where to store the created #idmefv2_observable_t object.
 *
 * Create a new #idmefv2_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_observable_new(idmefv2_observable_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_OBSERVABLE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = libidmefv2_string_new(&(*ret)->url);

            if ( retval < 0 ) {
                    idmefv2_observable_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_observable_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_observable_ref:
 * @observable: pointer to a #idmefv2_observable_t object.
 *
 * Increase @observable reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @observable.
 */
idmefv2_observable_t *idmefv2_observable_ref(idmefv2_observable_t *observable)
{
        libidmefv2_return_val_if_fail(observable, NULL);
        observable->refcount++;

        return observable;
}



int _idmefv2_observable_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_observable_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_OBSERVABLE_ORIGIN , ptr->origin);


            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->meaning, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->url, TRUE);



            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_observable_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_observable_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_observable_new_origin(ptr, (idmefv2_observable_origin_t **) ret);

                case 1:
                    return idmefv2_observable_new_meaning(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_observable_new_url(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_observable_new_name(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_observable_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_observable_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->origin = 0;
                    return 0;




                case 1:
                        if ( ptr->meaning ) {
                                libidmefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->url ) {
                                libidmefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_observable_destroy_internal(idmefv2_observable_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);



        if ( ptr->meaning ) {
                libidmefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }



        if ( ptr->url ) {
                libidmefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_observable_destroy:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_observable_destroy(idmefv2_observable_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_observable_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_observable_get_origin:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Get origin children of the #idmefv2_observable_t object.
 *
 * Returns: a pointer to a idmefv2_observable_origin_t object, or NULL if the children object is not set.
 */
idmefv2_observable_origin_t idmefv2_observable_get_origin(idmefv2_observable_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->origin;

}


/**
 * idmefv2_observable_set_origin:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @origin: pointer to a #idmefv2_observable_origin_t object.
 *
 * Set @origin object as a children of @ptr.
 * if @ptr already contain an @origin object, then it is destroyed,
 * and updated to point to the provided @origin object.
 */
void idmefv2_observable_set_origin(idmefv2_observable_t *ptr, idmefv2_observable_origin_t origin)
{
        libidmefv2_return_if_fail(ptr);
        ptr->origin = origin;
}
/**
 * idmefv2_observable_new_origin:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @ret: pointer to an address where to store the created #idmefv2_observable_origin_t object.
 *
 * Create a new origin object, children of #idmefv2_observable_t.
 * If @ptr already contain a #idmefv2_observable_origin_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_observable_new_origin(idmefv2_observable_t *ptr, idmefv2_observable_origin_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->origin;
        return 0;
}




/**
 * idmefv2_observable_get_meaning:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Get meaning children of the #idmefv2_observable_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_observable_get_meaning(idmefv2_observable_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * idmefv2_observable_set_meaning:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @meaning: pointer to a #libidmefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmefv2_observable_set_meaning(idmefv2_observable_t *ptr, libidmefv2_string_t *meaning)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libidmefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * idmefv2_observable_new_meaning:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new meaning object, children of #idmefv2_observable_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_observable_new_meaning(idmefv2_observable_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libidmefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}




/**
 * idmefv2_observable_get_url:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Get url children of the #idmefv2_observable_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_observable_get_url(idmefv2_observable_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * idmefv2_observable_set_url:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @url: pointer to a #libidmefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void idmefv2_observable_set_url(idmefv2_observable_t *ptr, libidmefv2_string_t *url)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->url )
                libidmefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * idmefv2_observable_new_url:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new url object, children of #idmefv2_observable_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_observable_new_url(idmefv2_observable_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libidmefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * idmefv2_observable_get_name:
 * @ptr: pointer to a #idmefv2_observable_t object.
 *
 * Get name children of the #idmefv2_observable_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_observable_get_name(idmefv2_observable_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_observable_set_name:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_observable_set_name(idmefv2_observable_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_observable_new_name:
 * @ptr: pointer to a #idmefv2_observable_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_observable_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_observable_new_name(idmefv2_observable_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}



/**
 * idmefv2_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_observable_copy(const idmefv2_observable_t *src, idmefv2_observable_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->origin = src->origin;



        if ( dst->meaning ) {
                libidmefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libidmefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->url ) {
                ret = libidmefv2_string_copy(src->url, dst->url);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_observable_clone(idmefv2_observable_t *src, idmefv2_observable_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_observable_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_observable_copy(src, *dst);
}


/**
 * idmefv2_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_observable_compare(const idmefv2_observable_t *obj1, const idmefv2_observable_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->origin != obj2->origin )
                return -1;

        ret = libidmefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_taken_action_new:
 * @ret: Pointer where to store the created #idmefv2_taken_action_t object.
 *
 * Create a new #idmefv2_taken_action_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_taken_action_new(idmefv2_taken_action_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_TAKEN_ACTION;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;


            return 0;
}


/**
 * idmefv2_taken_action_ref:
 * @taken_action: pointer to a #idmefv2_taken_action_t object.
 *
 * Increase @taken_action reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @taken_action.
 */
idmefv2_taken_action_t *idmefv2_taken_action_ref(idmefv2_taken_action_t *taken_action)
{
        libidmefv2_return_val_if_fail(taken_action, NULL);
        taken_action->refcount++;

        return taken_action;
}



int _idmefv2_taken_action_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_taken_action_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_TAKEN_ACTION_CATEGORY , ptr->category);

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_taken_action_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_taken_action_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_taken_action_new_category(ptr, (idmefv2_taken_action_category_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_taken_action_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_taken_action_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_taken_action_destroy_internal(idmefv2_taken_action_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);


        /* free() should be done by the caller */
}


/**
 * idmefv2_taken_action_destroy:
 * @ptr: pointer to a #idmefv2_taken_action_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_taken_action_destroy(idmefv2_taken_action_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_taken_action_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_taken_action_get_category:
 * @ptr: pointer to a #idmefv2_taken_action_t object.
 *
 * Get category children of the #idmefv2_taken_action_t object.
 *
 * Returns: a pointer to a idmefv2_taken_action_category_t object, or NULL if the children object is not set.
 */
idmefv2_taken_action_category_t idmefv2_taken_action_get_category(idmefv2_taken_action_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * idmefv2_taken_action_set_category:
 * @ptr: pointer to a #idmefv2_taken_action_t object.
 * @category: pointer to a #idmefv2_taken_action_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void idmefv2_taken_action_set_category(idmefv2_taken_action_t *ptr, idmefv2_taken_action_category_t category)
{
        libidmefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * idmefv2_taken_action_new_category:
 * @ptr: pointer to a #idmefv2_taken_action_t object.
 * @ret: pointer to an address where to store the created #idmefv2_taken_action_category_t object.
 *
 * Create a new category object, children of #idmefv2_taken_action_t.
 * If @ptr already contain a #idmefv2_taken_action_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_taken_action_new_category(idmefv2_taken_action_t *ptr, idmefv2_taken_action_category_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}



/**
 * idmefv2_taken_action_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_taken_action_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_taken_action_copy(const idmefv2_taken_action_t *src, idmefv2_taken_action_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;
    return 0 ;
}


/**
 * idmefv2_taken_action_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_taken_action_clone(idmefv2_taken_action_t *src, idmefv2_taken_action_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_taken_action_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_taken_action_copy(src, *dst);
}


/**
 * idmefv2_taken_action_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_taken_action_compare(const idmefv2_taken_action_t *obj1, const idmefv2_taken_action_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;
        return ret;
}


        



/**
 * idmefv2_reference_new:
 * @ret: Pointer where to store the created #idmefv2_reference_t object.
 *
 * Create a new #idmefv2_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_reference_new(idmefv2_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_REFERENCE;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;







        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_reference_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->url);

            if ( retval < 0 ) {
                    idmefv2_reference_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_reference_ref:
 * @reference: pointer to a #idmefv2_reference_t object.
 *
 * Increase @reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @reference.
 */
idmefv2_reference_t *idmefv2_reference_ref(idmefv2_reference_t *reference)
{
        libidmefv2_return_val_if_fail(reference, NULL);
        reference->refcount++;

        return reference;
}



int _idmefv2_reference_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_reference_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_REFERENCE_ORIGIN , ptr->origin);


            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->meaning, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->author, TRUE);



            case 3:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->publication_time, TRUE);



            case 4:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->version, TRUE);



            case 5:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 6:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->url, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_reference_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_reference_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_reference_new_origin(ptr, (idmefv2_reference_origin_t **) ret);

                case 1:
                    return idmefv2_reference_new_meaning(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_reference_new_author(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_reference_new_publication_time(ptr, (idmefv2_time_t **) ret);

                case 4:
                    return idmefv2_reference_new_version(ptr, (libidmefv2_string_t **) ret);

                case 5:
                    return idmefv2_reference_new_name(ptr, (libidmefv2_string_t **) ret);

                case 6:
                    return idmefv2_reference_new_url(ptr, (libidmefv2_string_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_reference_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_reference_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->origin = 0;
                    return 0;




                case 1:
                        if ( ptr->meaning ) {
                                libidmefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->author ) {
                                libidmefv2_string_destroy(ptr->author);
                                ptr->author = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->publication_time ) {
                                idmefv2_time_destroy(ptr->publication_time);
                                ptr->publication_time = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->version ) {
                                libidmefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->url ) {
                                libidmefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_reference_destroy_internal(idmefv2_reference_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);



        if ( ptr->meaning ) {
                libidmefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }



        if ( ptr->author ) {
                libidmefv2_string_destroy(ptr->author);
                ptr->author = NULL;
        }



        if ( ptr->publication_time ) {
                idmefv2_time_destroy(ptr->publication_time);
                ptr->publication_time = NULL;
        }



        if ( ptr->version ) {
                libidmefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->url ) {
                libidmefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_reference_destroy:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_reference_destroy(idmefv2_reference_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_reference_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_reference_get_origin:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get origin children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a idmefv2_reference_origin_t object, or NULL if the children object is not set.
 */
idmefv2_reference_origin_t idmefv2_reference_get_origin(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->origin;

}


/**
 * idmefv2_reference_set_origin:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @origin: pointer to a #idmefv2_reference_origin_t object.
 *
 * Set @origin object as a children of @ptr.
 * if @ptr already contain an @origin object, then it is destroyed,
 * and updated to point to the provided @origin object.
 */
void idmefv2_reference_set_origin(idmefv2_reference_t *ptr, idmefv2_reference_origin_t origin)
{
        libidmefv2_return_if_fail(ptr);
        ptr->origin = origin;
}
/**
 * idmefv2_reference_new_origin:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #idmefv2_reference_origin_t object.
 *
 * Create a new origin object, children of #idmefv2_reference_t.
 * If @ptr already contain a #idmefv2_reference_origin_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_origin(idmefv2_reference_t *ptr, idmefv2_reference_origin_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->origin;
        return 0;
}




/**
 * idmefv2_reference_get_meaning:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get meaning children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_reference_get_meaning(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * idmefv2_reference_set_meaning:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @meaning: pointer to a #libidmefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmefv2_reference_set_meaning(idmefv2_reference_t *ptr, libidmefv2_string_t *meaning)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libidmefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * idmefv2_reference_new_meaning:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new meaning object, children of #idmefv2_reference_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_meaning(idmefv2_reference_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libidmefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}




/**
 * idmefv2_reference_get_author:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get author children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_reference_get_author(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->author;

}


/**
 * idmefv2_reference_set_author:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @author: pointer to a #libidmefv2_string_t object.
 *
 * Set @author object as a children of @ptr.
 * if @ptr already contain an @author object, then it is destroyed,
 * and updated to point to the provided @author object.
 */

void idmefv2_reference_set_author(idmefv2_reference_t *ptr, libidmefv2_string_t *author)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->author )
                libidmefv2_string_destroy(ptr->author);

        ptr->author = author;
}
/**
 * idmefv2_reference_new_author:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new author object, children of #idmefv2_reference_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_author(idmefv2_reference_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->author ) {
                retval = libidmefv2_string_new(&ptr->author);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->author;
        return 0;
}




/**
 * idmefv2_reference_get_publication_time:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get publication_time children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_reference_get_publication_time(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->publication_time;

}


/**
 * idmefv2_reference_set_publication_time:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @publication_time: pointer to a #idmefv2_time_t object.
 *
 * Set @publication_time object as a children of @ptr.
 * if @ptr already contain an @publication_time object, then it is destroyed,
 * and updated to point to the provided @publication_time object.
 */

void idmefv2_reference_set_publication_time(idmefv2_reference_t *ptr, idmefv2_time_t *publication_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->publication_time )
                idmefv2_time_destroy(ptr->publication_time);

        ptr->publication_time = publication_time;
}
/**
 * idmefv2_reference_new_publication_time:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new publication_time object, children of #idmefv2_reference_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_publication_time(idmefv2_reference_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->publication_time ) {
                retval = idmefv2_time_new(&ptr->publication_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->publication_time;
        return 0;
}




/**
 * idmefv2_reference_get_version:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get version children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_reference_get_version(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * idmefv2_reference_set_version:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @version: pointer to a #libidmefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void idmefv2_reference_set_version(idmefv2_reference_t *ptr, libidmefv2_string_t *version)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->version )
                libidmefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * idmefv2_reference_new_version:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new version object, children of #idmefv2_reference_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_version(idmefv2_reference_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libidmefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}




/**
 * idmefv2_reference_get_name:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get name children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_reference_get_name(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_reference_set_name:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_reference_set_name(idmefv2_reference_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_reference_new_name:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_reference_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_name(idmefv2_reference_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_reference_get_url:
 * @ptr: pointer to a #idmefv2_reference_t object.
 *
 * Get url children of the #idmefv2_reference_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_reference_get_url(idmefv2_reference_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * idmefv2_reference_set_url:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @url: pointer to a #libidmefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void idmefv2_reference_set_url(idmefv2_reference_t *ptr, libidmefv2_string_t *url)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->url )
                libidmefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * idmefv2_reference_new_url:
 * @ptr: pointer to a #idmefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new url object, children of #idmefv2_reference_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_reference_new_url(idmefv2_reference_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libidmefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}



/**
 * idmefv2_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_reference_copy(const idmefv2_reference_t *src, idmefv2_reference_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->origin = src->origin;



        if ( dst->meaning ) {
                libidmefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libidmefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->author ) {
                libidmefv2_string_destroy(dst->author);
                dst->author = NULL;
        }

        if ( src->author ) {
                ret = libidmefv2_string_clone(src->author, &dst->author);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->publication_time ) {
                idmefv2_time_destroy(dst->publication_time);
                dst->publication_time = NULL;
        }

        if ( src->publication_time ) {
                ret = idmefv2_time_clone(src->publication_time, &dst->publication_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->version ) {
                libidmefv2_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libidmefv2_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->url ) {
                ret = libidmefv2_string_copy(src->url, dst->url);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_reference_clone(idmefv2_reference_t *src, idmefv2_reference_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_reference_copy(src, *dst);
}


/**
 * idmefv2_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_reference_compare(const idmefv2_reference_t *obj1, const idmefv2_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->origin != obj2->origin )
                return -1;

        ret = libidmefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->author, obj2->author);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->publication_time, obj2->publication_time);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_analyzer_new:
 * @ret: Pointer where to store the created #idmefv2_analyzer_t object.
 *
 * Create a new #idmefv2_analyzer_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analyzer_new(idmefv2_analyzer_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ANALYZER;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
            int retval = libidmefv2_string_new(&(*ret)->analyzerid);

            if ( retval < 0 ) {
                    idmefv2_analyzer_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

















            return 0;
}


/**
 * idmefv2_analyzer_ref:
 * @analyzer: pointer to a #idmefv2_analyzer_t object.
 *
 * Increase @analyzer reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @analyzer.
 */
idmefv2_analyzer_t *idmefv2_analyzer_ref(idmefv2_analyzer_t *analyzer)
{
        libidmefv2_return_val_if_fail(analyzer, NULL);
        analyzer->refcount++;

        return analyzer;
}



int _idmefv2_analyzer_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_analyzer_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->analyzerid, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);



            case 2:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->manufacturer, TRUE);



            case 3:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->model, TRUE);



            case 4:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->version, TRUE);


            case 5:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_ANALYZER_CLASS , ptr->class);


            case 6:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ostype, TRUE);



            case 7:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->osversion, TRUE);



            case 8:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ext_class, TRUE);


            case 9:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_ANALYZER_ANALYZERACTION , ptr->analyzeraction);


            case 10:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->actionhistory, TRUE);



            case 11:
                *childptr = ptr->node;
                return 0;


            case 12:
                *childptr = ptr->process;
                return 0;


            case 13:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->analyzer_time, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_analyzer_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_analyzer_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_analyzer_new_analyzerid(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_analyzer_new_name(ptr, (libidmefv2_string_t **) ret);

                case 2:
                    return idmefv2_analyzer_new_manufacturer(ptr, (libidmefv2_string_t **) ret);

                case 3:
                    return idmefv2_analyzer_new_model(ptr, (libidmefv2_string_t **) ret);

                case 4:
                    return idmefv2_analyzer_new_version(ptr, (libidmefv2_string_t **) ret);

                case 5:
                    return idmefv2_analyzer_new_class(ptr, (idmefv2_analyzer_class_t **) ret);

                case 6:
                    return idmefv2_analyzer_new_ostype(ptr, (libidmefv2_string_t **) ret);

                case 7:
                    return idmefv2_analyzer_new_osversion(ptr, (libidmefv2_string_t **) ret);

                case 8:
                    return idmefv2_analyzer_new_ext_class(ptr, (libidmefv2_string_t **) ret);

                case 9:
                    return idmefv2_analyzer_new_analyzeraction(ptr, (idmefv2_analyzer_analyzeraction_t **) ret);

                case 10:
                    return idmefv2_analyzer_new_actionhistory(ptr, (libidmefv2_string_t **) ret);

                case 11:
                    return idmefv2_analyzer_new_node(ptr, (idmefv2_node_t **) ret);

                case 12:
                    return idmefv2_analyzer_new_process(ptr, (idmefv2_process_t **) ret);

                case 13:
                    return idmefv2_analyzer_new_analyzer_time(ptr, (idmefv2_time_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_analyzer_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_analyzer_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->analyzerid ) {
                                libidmefv2_string_destroy(ptr->analyzerid);
                                ptr->analyzerid = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->manufacturer ) {
                                libidmefv2_string_destroy(ptr->manufacturer);
                                ptr->manufacturer = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->model ) {
                                libidmefv2_string_destroy(ptr->model);
                                ptr->model = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->version ) {
                                libidmefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;




                case 5:
                    ptr->class = 0;
                    return 0;




                case 6:
                        if ( ptr->ostype ) {
                                libidmefv2_string_destroy(ptr->ostype);
                                ptr->ostype = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->osversion ) {
                                libidmefv2_string_destroy(ptr->osversion);
                                ptr->osversion = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->ext_class ) {
                                libidmefv2_string_destroy(ptr->ext_class);
                                ptr->ext_class = NULL;
                        }

                        return 0;




                case 9:
                    ptr->analyzeraction = 0;
                    return 0;




                case 10:
                        if ( ptr->actionhistory ) {
                                libidmefv2_string_destroy(ptr->actionhistory);
                                ptr->actionhistory = NULL;
                        }

                        return 0;




                case 11:
                        if ( ptr->node ) {
                                idmefv2_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;




                case 12:
                        if ( ptr->process ) {
                                idmefv2_process_destroy(ptr->process);
                                ptr->process = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->analyzer_time ) {
                                idmefv2_time_destroy(ptr->analyzer_time);
                                ptr->analyzer_time = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_analyzer_destroy_internal(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->analyzerid ) {
                libidmefv2_string_destroy(ptr->analyzerid);
                ptr->analyzerid = NULL;
        }



        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        if ( ptr->manufacturer ) {
                libidmefv2_string_destroy(ptr->manufacturer);
                ptr->manufacturer = NULL;
        }



        if ( ptr->model ) {
                libidmefv2_string_destroy(ptr->model);
                ptr->model = NULL;
        }



        if ( ptr->version ) {
                libidmefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }





        if ( ptr->ostype ) {
                libidmefv2_string_destroy(ptr->ostype);
                ptr->ostype = NULL;
        }



        if ( ptr->osversion ) {
                libidmefv2_string_destroy(ptr->osversion);
                ptr->osversion = NULL;
        }



        if ( ptr->ext_class ) {
                libidmefv2_string_destroy(ptr->ext_class);
                ptr->ext_class = NULL;
        }





        if ( ptr->actionhistory ) {
                libidmefv2_string_destroy(ptr->actionhistory);
                ptr->actionhistory = NULL;
        }




        if ( ptr->node ) {
                idmefv2_node_destroy(ptr->node);
                ptr->node = NULL;
        }




        if ( ptr->process ) {
                idmefv2_process_destroy(ptr->process);
                ptr->process = NULL;
        }



        if ( ptr->analyzer_time ) {
                idmefv2_time_destroy(ptr->analyzer_time);
                ptr->analyzer_time = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_analyzer_destroy:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_analyzer_destroy(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_analyzer_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_analyzer_get_analyzerid:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get analyzerid children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_analyzerid(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analyzerid;

}


/**
 * idmefv2_analyzer_set_analyzerid:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @analyzerid: pointer to a #libidmefv2_string_t object.
 *
 * Set @analyzerid object as a children of @ptr.
 * if @ptr already contain an @analyzerid object, then it is destroyed,
 * and updated to point to the provided @analyzerid object.
 */

void idmefv2_analyzer_set_analyzerid(idmefv2_analyzer_t *ptr, libidmefv2_string_t *analyzerid)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->analyzerid )
                libidmefv2_string_destroy(ptr->analyzerid);

        ptr->analyzerid = analyzerid;
}
/**
 * idmefv2_analyzer_new_analyzerid:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new analyzerid object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_analyzerid(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->analyzerid ) {
                retval = libidmefv2_string_new(&ptr->analyzerid);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->analyzerid;
        return 0;
}




/**
 * idmefv2_analyzer_get_name:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get name children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_name(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_analyzer_set_name:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_analyzer_set_name(idmefv2_analyzer_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_analyzer_new_name:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_name(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_analyzer_get_manufacturer:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get manufacturer children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_manufacturer(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->manufacturer;

}


/**
 * idmefv2_analyzer_set_manufacturer:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @manufacturer: pointer to a #libidmefv2_string_t object.
 *
 * Set @manufacturer object as a children of @ptr.
 * if @ptr already contain an @manufacturer object, then it is destroyed,
 * and updated to point to the provided @manufacturer object.
 */

void idmefv2_analyzer_set_manufacturer(idmefv2_analyzer_t *ptr, libidmefv2_string_t *manufacturer)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->manufacturer )
                libidmefv2_string_destroy(ptr->manufacturer);

        ptr->manufacturer = manufacturer;
}
/**
 * idmefv2_analyzer_new_manufacturer:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new manufacturer object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_manufacturer(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->manufacturer ) {
                retval = libidmefv2_string_new(&ptr->manufacturer);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->manufacturer;
        return 0;
}




/**
 * idmefv2_analyzer_get_model:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get model children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_model(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->model;

}


/**
 * idmefv2_analyzer_set_model:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @model: pointer to a #libidmefv2_string_t object.
 *
 * Set @model object as a children of @ptr.
 * if @ptr already contain an @model object, then it is destroyed,
 * and updated to point to the provided @model object.
 */

void idmefv2_analyzer_set_model(idmefv2_analyzer_t *ptr, libidmefv2_string_t *model)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->model )
                libidmefv2_string_destroy(ptr->model);

        ptr->model = model;
}
/**
 * idmefv2_analyzer_new_model:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new model object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_model(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->model ) {
                retval = libidmefv2_string_new(&ptr->model);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->model;
        return 0;
}




/**
 * idmefv2_analyzer_get_version:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get version children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_version(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * idmefv2_analyzer_set_version:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @version: pointer to a #libidmefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void idmefv2_analyzer_set_version(idmefv2_analyzer_t *ptr, libidmefv2_string_t *version)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->version )
                libidmefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * idmefv2_analyzer_new_version:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new version object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_version(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libidmefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}



/**
 * idmefv2_analyzer_get_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get class children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a idmefv2_analyzer_class_t object, or NULL if the children object is not set.
 */
idmefv2_analyzer_class_t idmefv2_analyzer_get_class(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->class;

}


/**
 * idmefv2_analyzer_set_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @class_str: pointer to a #idmefv2_analyzer_class_t object.
 *
 * Set @class_str object as a children of @ptr.
 * if @ptr already contain an @class_str object, then it is destroyed,
 * and updated to point to the provided @class_str object.
 */
void idmefv2_analyzer_set_class(idmefv2_analyzer_t *ptr, idmefv2_analyzer_class_t class_str)
{
        libidmefv2_return_if_fail(ptr);
        ptr->class = class_str;
}
/**
 * idmefv2_analyzer_new_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #idmefv2_analyzer_class_t object.
 *
 * Create a new class object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #idmefv2_analyzer_class_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_class(idmefv2_analyzer_t *ptr, idmefv2_analyzer_class_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->class;
        return 0;
}




/**
 * idmefv2_analyzer_get_ostype:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get ostype children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_ostype(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ostype;

}


/**
 * idmefv2_analyzer_set_ostype:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ostype: pointer to a #libidmefv2_string_t object.
 *
 * Set @ostype object as a children of @ptr.
 * if @ptr already contain an @ostype object, then it is destroyed,
 * and updated to point to the provided @ostype object.
 */

void idmefv2_analyzer_set_ostype(idmefv2_analyzer_t *ptr, libidmefv2_string_t *ostype)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ostype )
                libidmefv2_string_destroy(ptr->ostype);

        ptr->ostype = ostype;
}
/**
 * idmefv2_analyzer_new_ostype:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ostype object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_ostype(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ostype ) {
                retval = libidmefv2_string_new(&ptr->ostype);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ostype;
        return 0;
}




/**
 * idmefv2_analyzer_get_osversion:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get osversion children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_osversion(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->osversion;

}


/**
 * idmefv2_analyzer_set_osversion:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @osversion: pointer to a #libidmefv2_string_t object.
 *
 * Set @osversion object as a children of @ptr.
 * if @ptr already contain an @osversion object, then it is destroyed,
 * and updated to point to the provided @osversion object.
 */

void idmefv2_analyzer_set_osversion(idmefv2_analyzer_t *ptr, libidmefv2_string_t *osversion)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->osversion )
                libidmefv2_string_destroy(ptr->osversion);

        ptr->osversion = osversion;
}
/**
 * idmefv2_analyzer_new_osversion:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new osversion object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_osversion(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->osversion ) {
                retval = libidmefv2_string_new(&ptr->osversion);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->osversion;
        return 0;
}




/**
 * idmefv2_analyzer_get_ext_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get ext_class children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_ext_class(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_class;

}


/**
 * idmefv2_analyzer_set_ext_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ext_class: pointer to a #libidmefv2_string_t object.
 *
 * Set @ext_class object as a children of @ptr.
 * if @ptr already contain an @ext_class object, then it is destroyed,
 * and updated to point to the provided @ext_class object.
 */

void idmefv2_analyzer_set_ext_class(idmefv2_analyzer_t *ptr, libidmefv2_string_t *ext_class)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ext_class )
                libidmefv2_string_destroy(ptr->ext_class);

        ptr->ext_class = ext_class;
}
/**
 * idmefv2_analyzer_new_ext_class:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ext_class object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_ext_class(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_class ) {
                retval = libidmefv2_string_new(&ptr->ext_class);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_class;
        return 0;
}



/**
 * idmefv2_analyzer_get_analyzeraction:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get analyzeraction children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a idmefv2_analyzer_analyzeraction_t object, or NULL if the children object is not set.
 */
idmefv2_analyzer_analyzeraction_t idmefv2_analyzer_get_analyzeraction(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analyzeraction;

}


/**
 * idmefv2_analyzer_set_analyzeraction:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @analyzeraction: pointer to a #idmefv2_analyzer_analyzeraction_t object.
 *
 * Set @analyzeraction object as a children of @ptr.
 * if @ptr already contain an @analyzeraction object, then it is destroyed,
 * and updated to point to the provided @analyzeraction object.
 */
void idmefv2_analyzer_set_analyzeraction(idmefv2_analyzer_t *ptr, idmefv2_analyzer_analyzeraction_t analyzeraction)
{
        libidmefv2_return_if_fail(ptr);
        ptr->analyzeraction = analyzeraction;
}
/**
 * idmefv2_analyzer_new_analyzeraction:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #idmefv2_analyzer_analyzeraction_t object.
 *
 * Create a new analyzeraction object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #idmefv2_analyzer_analyzeraction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_analyzeraction(idmefv2_analyzer_t *ptr, idmefv2_analyzer_analyzeraction_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->analyzeraction;
        return 0;
}




/**
 * idmefv2_analyzer_get_actionhistory:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get actionhistory children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_analyzer_get_actionhistory(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->actionhistory;

}


/**
 * idmefv2_analyzer_set_actionhistory:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @actionhistory: pointer to a #libidmefv2_string_t object.
 *
 * Set @actionhistory object as a children of @ptr.
 * if @ptr already contain an @actionhistory object, then it is destroyed,
 * and updated to point to the provided @actionhistory object.
 */

void idmefv2_analyzer_set_actionhistory(idmefv2_analyzer_t *ptr, libidmefv2_string_t *actionhistory)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->actionhistory )
                libidmefv2_string_destroy(ptr->actionhistory);

        ptr->actionhistory = actionhistory;
}
/**
 * idmefv2_analyzer_new_actionhistory:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new actionhistory object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_actionhistory(idmefv2_analyzer_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->actionhistory ) {
                retval = libidmefv2_string_new(&ptr->actionhistory);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->actionhistory;
        return 0;
}




/**
 * idmefv2_analyzer_get_node:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get node children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a idmefv2_node_t object, or NULL if the children object is not set.
 */
idmefv2_node_t *idmefv2_analyzer_get_node(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;

}


/**
 * idmefv2_analyzer_set_node:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @node: pointer to a #idmefv2_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmefv2_analyzer_set_node(idmefv2_analyzer_t *ptr, idmefv2_node_t *node)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->node )
                idmefv2_node_destroy(ptr->node);

        ptr->node = node;
}
/**
 * idmefv2_analyzer_new_node:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #idmefv2_node_t object.
 *
 * Create a new node object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #idmefv2_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_node(idmefv2_analyzer_t *ptr, idmefv2_node_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = idmefv2_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->node;
        return 0;
}




/**
 * idmefv2_analyzer_get_process:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get process children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a idmefv2_process_t object, or NULL if the children object is not set.
 */
idmefv2_process_t *idmefv2_analyzer_get_process(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->process;

}


/**
 * idmefv2_analyzer_set_process:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @process: pointer to a #idmefv2_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmefv2_analyzer_set_process(idmefv2_analyzer_t *ptr, idmefv2_process_t *process)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->process )
                idmefv2_process_destroy(ptr->process);

        ptr->process = process;
}
/**
 * idmefv2_analyzer_new_process:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #idmefv2_process_t object.
 *
 * Create a new process object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #idmefv2_process_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_process(idmefv2_analyzer_t *ptr, idmefv2_process_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->process ) {
                retval = idmefv2_process_new(&ptr->process);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->process;
        return 0;
}




/**
 * idmefv2_analyzer_get_analyzer_time:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 *
 * Get analyzer_time children of the #idmefv2_analyzer_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_analyzer_get_analyzer_time(idmefv2_analyzer_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analyzer_time;

}


/**
 * idmefv2_analyzer_set_analyzer_time:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @analyzer_time: pointer to a #idmefv2_time_t object.
 *
 * Set @analyzer_time object as a children of @ptr.
 * if @ptr already contain an @analyzer_time object, then it is destroyed,
 * and updated to point to the provided @analyzer_time object.
 */

void idmefv2_analyzer_set_analyzer_time(idmefv2_analyzer_t *ptr, idmefv2_time_t *analyzer_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->analyzer_time )
                idmefv2_time_destroy(ptr->analyzer_time);

        ptr->analyzer_time = analyzer_time;
}
/**
 * idmefv2_analyzer_new_analyzer_time:
 * @ptr: pointer to a #idmefv2_analyzer_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new analyzer_time object, children of #idmefv2_analyzer_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analyzer_new_analyzer_time(idmefv2_analyzer_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->analyzer_time ) {
                retval = idmefv2_time_new(&ptr->analyzer_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->analyzer_time;
        return 0;
}



/**
 * idmefv2_analyzer_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analyzer_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analyzer_copy(const idmefv2_analyzer_t *src, idmefv2_analyzer_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->analyzerid ) {
                ret = libidmefv2_string_copy(src->analyzerid, dst->analyzerid);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->name ) {
                libidmefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libidmefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->manufacturer ) {
                libidmefv2_string_destroy(dst->manufacturer);
                dst->manufacturer = NULL;
        }

        if ( src->manufacturer ) {
                ret = libidmefv2_string_clone(src->manufacturer, &dst->manufacturer);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->model ) {
                libidmefv2_string_destroy(dst->model);
                dst->model = NULL;
        }

        if ( src->model ) {
                ret = libidmefv2_string_clone(src->model, &dst->model);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->version ) {
                libidmefv2_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libidmefv2_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }




        dst->class = src->class;



        if ( dst->ostype ) {
                libidmefv2_string_destroy(dst->ostype);
                dst->ostype = NULL;
        }

        if ( src->ostype ) {
                ret = libidmefv2_string_clone(src->ostype, &dst->ostype);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->osversion ) {
                libidmefv2_string_destroy(dst->osversion);
                dst->osversion = NULL;
        }

        if ( src->osversion ) {
                ret = libidmefv2_string_clone(src->osversion, &dst->osversion);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_class ) {
                libidmefv2_string_destroy(dst->ext_class);
                dst->ext_class = NULL;
        }

        if ( src->ext_class ) {
                ret = libidmefv2_string_clone(src->ext_class, &dst->ext_class);
                if ( ret < 0 )
                        return ret;
        }




        dst->analyzeraction = src->analyzeraction;



        if ( dst->actionhistory ) {
                libidmefv2_string_destroy(dst->actionhistory);
                dst->actionhistory = NULL;
        }

        if ( src->actionhistory ) {
                ret = libidmefv2_string_clone(src->actionhistory, &dst->actionhistory);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->node ) {
                idmefv2_node_destroy(dst->node);
                dst->node = NULL;
        }

        if ( src->node ) {
                ret = idmefv2_node_clone(src->node, &dst->node);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->process ) {
                idmefv2_process_destroy(dst->process);
                dst->process = NULL;
        }

        if ( src->process ) {
                ret = idmefv2_process_clone(src->process, &dst->process);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->analyzer_time ) {
                idmefv2_time_destroy(dst->analyzer_time);
                dst->analyzer_time = NULL;
        }

        if ( src->analyzer_time ) {
                ret = idmefv2_time_clone(src->analyzer_time, &dst->analyzer_time);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * idmefv2_analyzer_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analyzer_clone(idmefv2_analyzer_t *src, idmefv2_analyzer_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_analyzer_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_analyzer_copy(src, *dst);
}


/**
 * idmefv2_analyzer_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_analyzer_compare(const idmefv2_analyzer_t *obj1, const idmefv2_analyzer_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->analyzerid, obj2->analyzerid);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->manufacturer, obj2->manufacturer);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->model, obj2->model);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;


        if ( obj1->class != obj2->class )
                return -1;

        ret = libidmefv2_string_compare(obj1->ostype, obj2->ostype);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->osversion, obj2->osversion);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->ext_class, obj2->ext_class);
        if ( ret != 0 )
                return ret;


        if ( obj1->analyzeraction != obj2->analyzeraction )
                return -1;

        ret = libidmefv2_string_compare(obj1->actionhistory, obj2->actionhistory);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_process_compare(obj1->process, obj2->process);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->analyzer_time, obj2->analyzer_time);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_additional_data_new:
 * @ret: Pointer where to store the created #idmefv2_additional_data_t object.
 *
 * Create a new #idmefv2_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_additional_data_new(idmefv2_additional_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ADDITIONAL_DATA;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = idmefv2_data_new(&(*ret)->data);

            if ( retval < 0 ) {
                    idmefv2_additional_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * idmefv2_additional_data_ref:
 * @additional_data: pointer to a #idmefv2_additional_data_t object.
 *
 * Increase @additional_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @additional_data.
 */
idmefv2_additional_data_t *idmefv2_additional_data_ref(idmefv2_additional_data_t *additional_data)
{
        libidmefv2_return_val_if_fail(additional_data, NULL);
        additional_data->refcount++;

        return additional_data;
}



int _idmefv2_additional_data_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_additional_data_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->meaning, TRUE);


            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_ADDITIONAL_DATA_TYPE , ptr->type);


            case 2:

                return get_value_from_data((idmefv2_value_t **) childptr,  ptr->data, TRUE);


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_additional_data_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_additional_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_additional_data_new_meaning(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_additional_data_new_type(ptr, (idmefv2_additional_data_type_t **) ret);

                case 2:
                    return idmefv2_additional_data_new_data(ptr, (idmefv2_data_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_additional_data_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_additional_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->meaning ) {
                                libidmefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 1:
                    ptr->type = 0;
                    return 0;




                case 2:
                        if ( ptr->data ) {
                                idmefv2_data_destroy(ptr->data);
                                ptr->data = NULL;
                        }

                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_additional_data_destroy_internal(idmefv2_additional_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);

        if ( ptr->meaning ) {
                libidmefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }





        if ( ptr->data ) {
                idmefv2_data_destroy(ptr->data);
                ptr->data = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * idmefv2_additional_data_destroy:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_additional_data_destroy(idmefv2_additional_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_additional_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_additional_data_get_meaning:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 *
 * Get meaning children of the #idmefv2_additional_data_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_additional_data_get_meaning(idmefv2_additional_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * idmefv2_additional_data_set_meaning:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @meaning: pointer to a #libidmefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmefv2_additional_data_set_meaning(idmefv2_additional_data_t *ptr, libidmefv2_string_t *meaning)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libidmefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * idmefv2_additional_data_new_meaning:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new meaning object, children of #idmefv2_additional_data_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_additional_data_new_meaning(idmefv2_additional_data_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libidmefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}



/**
 * idmefv2_additional_data_get_type:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 *
 * Get type children of the #idmefv2_additional_data_t object.
 *
 * Returns: a pointer to a idmefv2_additional_data_type_t object, or NULL if the children object is not set.
 */
idmefv2_additional_data_type_t idmefv2_additional_data_get_type(idmefv2_additional_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * idmefv2_additional_data_set_type:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @type: pointer to a #idmefv2_additional_data_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void idmefv2_additional_data_set_type(idmefv2_additional_data_t *ptr, idmefv2_additional_data_type_t type)
{
        libidmefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->_type_is_set = TRUE;

}
/**
 * idmefv2_additional_data_new_type:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_additional_data_type_t object.
 *
 * Create a new type object, children of #idmefv2_additional_data_t.
 * If @ptr already contain a #idmefv2_additional_data_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_additional_data_new_type(idmefv2_additional_data_t *ptr, idmefv2_additional_data_type_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->_type_is_set = TRUE;
        *ret = &ptr->type;
        return 0;
}




/**
 * idmefv2_additional_data_get_data:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 *
 * Get data children of the #idmefv2_additional_data_t object.
 *
 * Returns: a pointer to a idmefv2_data_t object, or NULL if the children object is not set.
 */
idmefv2_data_t *idmefv2_additional_data_get_data(idmefv2_additional_data_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data;

}


/**
 * idmefv2_additional_data_set_data:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @data: pointer to a #idmefv2_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void idmefv2_additional_data_set_data(idmefv2_additional_data_t *ptr, idmefv2_data_t *data)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->data )
                idmefv2_data_destroy(ptr->data);

        ptr->data = data;
}
/**
 * idmefv2_additional_data_new_data:
 * @ptr: pointer to a #idmefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #idmefv2_data_t object.
 *
 * Create a new data object, children of #idmefv2_additional_data_t.
 * If @ptr already contain a #idmefv2_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_additional_data_new_data(idmefv2_additional_data_t *ptr, idmefv2_data_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->data ) {
                retval = idmefv2_data_new(&ptr->data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->data;
        return 0;
}



/**
 * idmefv2_additional_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_additional_data_copy(const idmefv2_additional_data_t *src, idmefv2_additional_data_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->meaning ) {
                libidmefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libidmefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;


        if ( src->data ) {
                ret = idmefv2_data_copy(src->data, dst->data);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * idmefv2_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_additional_data_clone(idmefv2_additional_data_t *src, idmefv2_additional_data_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_additional_data_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_additional_data_copy(src, *dst);
}


/**
 * idmefv2_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_additional_data_compare(const idmefv2_additional_data_t *obj1, const idmefv2_additional_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;

        ret = idmefv2_data_compare(obj1->data, obj2->data);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * idmefv2_correlation_alert_new:
 * @ret: Pointer where to store the created #idmefv2_correlation_alert_t object.
 *
 * Create a new #idmefv2_correlation_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_correlation_alert_new(idmefv2_correlation_alert_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_CORRELATION_ALERT;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->alertident_list);


        {
            int retval = libidmefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    idmefv2_correlation_alert_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }



            return 0;
}


/**
 * idmefv2_correlation_alert_ref:
 * @correlation_alert: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Increase @correlation_alert reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @correlation_alert.
 */
idmefv2_correlation_alert_t *idmefv2_correlation_alert_ref(idmefv2_correlation_alert_t *correlation_alert)
{
        libidmefv2_return_val_if_fail(correlation_alert, NULL);
        correlation_alert->refcount++;

        return correlation_alert;
}



int _idmefv2_correlation_alert_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_correlation_alert_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->name, TRUE);


            case 1:
                *childptr = &ptr->alertident_list;
                return 0;

            case 2:
                         return (ptr->duration_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->duration) : 0;

            case 3:
                         return (ptr->counter_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->counter) : 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_correlation_alert_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_correlation_alert_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_correlation_alert_new_name(ptr, (libidmefv2_string_t **) ret);

                case 1: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_correlation_alert_new_alertident(ptr, (libidmefv2_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->alertident_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->alertident_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_correlation_alert_new_alertident(ptr, (libidmefv2_string_t **) ret, n);
                }

                case 2:
                    return idmefv2_correlation_alert_new_duration(ptr, (uint32_t **) ret);

                case 3:
                    return idmefv2_correlation_alert_new_counter(ptr, (uint32_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_correlation_alert_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_correlation_alert_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->name ) {
                                libidmefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;


                case 1: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->alertident_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            libidmefv2_string_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->alertident_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        libidmefv2_string_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        ptr->duration_is_set = 0;
                        return 0;

                case 3:
                        ptr->counter_is_set = 0;
                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_correlation_alert_destroy_internal(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->name ) {
                libidmefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }



        {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry;

                libidmefv2_list_for_each_safe(&ptr->alertident_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        libidmefv2_string_destroy(entry);
                }
        }




        /* free() should be done by the caller */
}


/**
 * idmefv2_correlation_alert_destroy:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_correlation_alert_destroy(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_correlation_alert_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_correlation_alert_get_name:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Get name children of the #idmefv2_correlation_alert_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_correlation_alert_get_name(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * idmefv2_correlation_alert_set_name:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @name: pointer to a #libidmefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmefv2_correlation_alert_set_name(idmefv2_correlation_alert_t *ptr, libidmefv2_string_t *name)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->name )
                libidmefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * idmefv2_correlation_alert_new_name:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new name object, children of #idmefv2_correlation_alert_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_correlation_alert_new_name(idmefv2_correlation_alert_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libidmefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * idmefv2_correlation_alert_get_next_alertident:
 * @correlation_alert: pointer to a #idmefv2_correlation_alert_t object.
 * @libidmefv2_string_cur: pointer to a #libidmefv2_string_t object.
 *
 * Get the next #libidmefv2_string_t object listed in @ptr.
 * When iterating over the libidmefv2_string_t object listed in @ptr,
 * @object should be set to the latest returned #libidmefv2_string_t object.
 *
 * Returns: the next #libidmefv2_string_t in the list.
 */
libidmefv2_string_t *idmefv2_correlation_alert_get_next_alertident(idmefv2_correlation_alert_t *correlation_alert, libidmefv2_string_t *libidmefv2_string_cur)
{
        libidmefv2_list_t *tmp = (libidmefv2_string_cur) ? &((libidmefv2_linked_object_t *) libidmefv2_string_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(correlation_alert, NULL);

        libidmefv2_list_for_each_continue(&correlation_alert->alertident_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_correlation_alert_set_alertident:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @object: pointer to a #libidmefv2_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libidmefv2_string_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_correlation_alert_set_alertident(idmefv2_correlation_alert_t *ptr, libidmefv2_string_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->alertident_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_correlation_alert_new_alertident:
 *  @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *  @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *  @pos: position in the list.
 *
 * Create a new #libidmefv2_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libidmefv2_string_t object. The created #libidmefv2_string_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_correlation_alert_new_alertident(idmefv2_correlation_alert_t *ptr, libidmefv2_string_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = libidmefv2_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->alertident_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_correlation_alert_get_duration:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Get duration children of the #idmefv2_correlation_alert_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_correlation_alert_get_duration(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->duration_is_set ? &ptr->duration : NULL;


}


/**
 * idmefv2_correlation_alert_set_duration:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @duration: pointer to a #uint32_t object.
 *
 * Set @duration object as a children of @ptr.
 * if @ptr already contain an @duration object, then it is destroyed,
 * and updated to point to the provided @duration object.
 */
void idmefv2_correlation_alert_set_duration(idmefv2_correlation_alert_t *ptr, uint32_t duration)
{
        libidmefv2_return_if_fail(ptr);
        ptr->duration = duration;
        ptr->duration_is_set = 1;
}

void idmefv2_correlation_alert_unset_duration(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->duration_is_set = 0;
}
/**
 * idmefv2_correlation_alert_new_duration:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new duration object, children of #idmefv2_correlation_alert_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_correlation_alert_new_duration(idmefv2_correlation_alert_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->duration_is_set = 1;



        *ret = &ptr->duration;
        return 0;
}




/**
 * idmefv2_correlation_alert_get_counter:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Get counter children of the #idmefv2_correlation_alert_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_correlation_alert_get_counter(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->counter_is_set ? &ptr->counter : NULL;


}


/**
 * idmefv2_correlation_alert_set_counter:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @counter: pointer to a #uint32_t object.
 *
 * Set @counter object as a children of @ptr.
 * if @ptr already contain an @counter object, then it is destroyed,
 * and updated to point to the provided @counter object.
 */
void idmefv2_correlation_alert_set_counter(idmefv2_correlation_alert_t *ptr, uint32_t counter)
{
        libidmefv2_return_if_fail(ptr);
        ptr->counter = counter;
        ptr->counter_is_set = 1;
}

void idmefv2_correlation_alert_unset_counter(idmefv2_correlation_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->counter_is_set = 0;
}
/**
 * idmefv2_correlation_alert_new_counter:
 * @ptr: pointer to a #idmefv2_correlation_alert_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new counter object, children of #idmefv2_correlation_alert_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_correlation_alert_new_counter(idmefv2_correlation_alert_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->counter_is_set = 1;



        *ret = &ptr->counter;
        return 0;
}



/**
 * idmefv2_correlation_alert_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_correlation_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_correlation_alert_copy(const idmefv2_correlation_alert_t *src, idmefv2_correlation_alert_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->name ) {
                ret = libidmefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }


         {
                libidmefv2_list_t *n, *tmp;
                libidmefv2_string_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->alertident_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->alertident_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_string_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->alertident_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }


        dst->duration_is_set = src->duration_is_set;
        dst->duration = src->duration;


        dst->counter_is_set = src->counter_is_set;
        dst->counter = src->counter;
    return 0 ;
}


/**
 * idmefv2_correlation_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_correlation_alert_clone(idmefv2_correlation_alert_t *src, idmefv2_correlation_alert_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_correlation_alert_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_correlation_alert_copy(src, *dst);
}


/**
 * idmefv2_correlation_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_correlation_alert_compare(const idmefv2_correlation_alert_t *obj1, const idmefv2_correlation_alert_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        {
            libidmefv2_list_t *tmp1, *tmp2;
            libidmefv2_string_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->alertident_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->alertident_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = libidmefv2_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        if ( obj1->duration_is_set != obj2->duration_is_set )
                return -1;

        if ( obj1->duration_is_set && obj1->duration != obj2->duration )
                return -1;


        if ( obj1->counter_is_set != obj2->counter_is_set )
                return -1;

        if ( obj1->counter_is_set && obj1->counter != obj2->counter )
                return -1;

        return ret;
}


        



/**
 * idmefv2_analysis_data_new:
 * @ret: Pointer where to store the created #idmefv2_analysis_data_t object.
 *
 * Create a new #idmefv2_analysis_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analysis_data_new(idmefv2_analysis_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ANALYSIS_DATA;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->observable_list);


        libidmefv2_list_init(&(*ret)->original_data_list);





            return 0;
}


/**
 * idmefv2_analysis_data_ref:
 * @analysis_data: pointer to a #idmefv2_analysis_data_t object.
 *
 * Increase @analysis_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @analysis_data.
 */
idmefv2_analysis_data_t *idmefv2_analysis_data_ref(idmefv2_analysis_data_t *analysis_data)
{
        libidmefv2_return_val_if_fail(analysis_data, NULL);
        analysis_data->refcount++;

        return analysis_data;
}



int _idmefv2_analysis_data_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_analysis_data_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->observable_list;
                return 0;

            case 1:
                *childptr = &ptr->original_data_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_analysis_data_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_analysis_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_analysis_data_new_observable(ptr, (idmefv2_observable_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->observable_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->observable_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_analysis_data_new_observable(ptr, (idmefv2_observable_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_analysis_data_new_original_data(ptr, (idmefv2_original_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->original_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->original_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_analysis_data_new_original_data(ptr, (idmefv2_original_data_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_analysis_data_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_analysis_data_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->observable_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_observable_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->observable_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_observable_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 1: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->original_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_original_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->original_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_original_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_analysis_data_destroy_internal(idmefv2_analysis_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);


        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_observable_t *entry;

                libidmefv2_list_for_each_safe(&ptr->observable_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_observable_destroy(entry);
                }
        }


        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_original_data_t *entry;

                libidmefv2_list_for_each_safe(&ptr->original_data_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_original_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_analysis_data_destroy:
 * @ptr: pointer to a #idmefv2_analysis_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_analysis_data_destroy(idmefv2_analysis_data_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_analysis_data_destroy_internal(ptr);
        free(ptr);
}






/**
 * idmefv2_analysis_data_get_next_observable:
 * @analysis_data: pointer to a #idmefv2_analysis_data_t object.
 * @observable_cur: pointer to a #idmefv2_observable_t object.
 *
 * Get the next #idmefv2_observable_t object listed in @ptr.
 * When iterating over the idmefv2_observable_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_observable_t object.
 *
 * Returns: the next #idmefv2_observable_t in the list.
 */
idmefv2_observable_t *idmefv2_analysis_data_get_next_observable(idmefv2_analysis_data_t *analysis_data, idmefv2_observable_t *observable_cur)
{
        libidmefv2_list_t *tmp = (observable_cur) ? &((libidmefv2_linked_object_t *) observable_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(analysis_data, NULL);

        libidmefv2_list_for_each_continue(&analysis_data->observable_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_analysis_data_set_observable:
 * @ptr: pointer to a #idmefv2_analysis_data_t object.
 * @object: pointer to a #idmefv2_observable_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_observable_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_analysis_data_set_observable(idmefv2_analysis_data_t *ptr, idmefv2_observable_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->observable_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_analysis_data_new_observable:
 *  @ptr: pointer to a #idmefv2_analysis_data_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_observable_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_observable_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_observable_t object. The created #idmefv2_observable_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analysis_data_new_observable(idmefv2_analysis_data_t *ptr, idmefv2_observable_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_observable_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->observable_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * idmefv2_analysis_data_get_next_original_data:
 * @analysis_data: pointer to a #idmefv2_analysis_data_t object.
 * @original_data_cur: pointer to a #idmefv2_original_data_t object.
 *
 * Get the next #idmefv2_original_data_t object listed in @ptr.
 * When iterating over the idmefv2_original_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_original_data_t object.
 *
 * Returns: the next #idmefv2_original_data_t in the list.
 */
idmefv2_original_data_t *idmefv2_analysis_data_get_next_original_data(idmefv2_analysis_data_t *analysis_data, idmefv2_original_data_t *original_data_cur)
{
        libidmefv2_list_t *tmp = (original_data_cur) ? &((libidmefv2_linked_object_t *) original_data_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(analysis_data, NULL);

        libidmefv2_list_for_each_continue(&analysis_data->original_data_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_analysis_data_set_original_data:
 * @ptr: pointer to a #idmefv2_analysis_data_t object.
 * @object: pointer to a #idmefv2_original_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_original_data_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_analysis_data_set_original_data(idmefv2_analysis_data_t *ptr, idmefv2_original_data_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->original_data_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_analysis_data_new_original_data:
 *  @ptr: pointer to a #idmefv2_analysis_data_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_original_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_original_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_original_data_t object. The created #idmefv2_original_data_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_analysis_data_new_original_data(idmefv2_analysis_data_t *ptr, idmefv2_original_data_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_original_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->original_data_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_analysis_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_analysis_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analysis_data_copy(const idmefv2_analysis_data_t *src, idmefv2_analysis_data_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_observable_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->observable_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_observable_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->observable_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_observable_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->observable_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_original_data_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->original_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_original_data_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->original_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_original_data_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->original_data_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_analysis_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_analysis_data_clone(idmefv2_analysis_data_t *src, idmefv2_analysis_data_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_analysis_data_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_analysis_data_copy(src, *dst);
}


/**
 * idmefv2_analysis_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_analysis_data_compare(const idmefv2_analysis_data_t *obj1, const idmefv2_analysis_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_observable_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->observable_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->observable_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_observable_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_original_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->original_data_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->original_data_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_original_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_confidence_new:
 * @ret: Pointer where to store the created #idmefv2_confidence_t object.
 *
 * Create a new #idmefv2_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_confidence_new(idmefv2_confidence_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_CONFIDENCE;


        (*ret)->refcount = 1;


            return 0;
}


/**
 * idmefv2_confidence_ref:
 * @confidence: pointer to a #idmefv2_confidence_t object.
 *
 * Increase @confidence reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @confidence.
 */
idmefv2_confidence_t *idmefv2_confidence_ref(idmefv2_confidence_t *confidence)
{
        libidmefv2_return_val_if_fail(confidence, NULL);
        confidence->refcount++;

        return confidence;
}



int _idmefv2_confidence_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_confidence_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_CONFIDENCE_RATING , ptr->rating);

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_confidence_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_confidence_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_confidence_new_rating(ptr, (idmefv2_confidence_rating_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_confidence_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_confidence_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->rating = 0;
                    return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_confidence_destroy_internal(idmefv2_confidence_t *ptr)
{
        libidmefv2_return_if_fail(ptr);


        /* free() should be done by the caller */
}


/**
 * idmefv2_confidence_destroy:
 * @ptr: pointer to a #idmefv2_confidence_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_confidence_destroy(idmefv2_confidence_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_confidence_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_confidence_get_rating:
 * @ptr: pointer to a #idmefv2_confidence_t object.
 *
 * Get rating children of the #idmefv2_confidence_t object.
 *
 * Returns: a pointer to a idmefv2_confidence_rating_t object, or NULL if the children object is not set.
 */
idmefv2_confidence_rating_t idmefv2_confidence_get_rating(idmefv2_confidence_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->rating;

}


/**
 * idmefv2_confidence_set_rating:
 * @ptr: pointer to a #idmefv2_confidence_t object.
 * @rating: pointer to a #idmefv2_confidence_rating_t object.
 *
 * Set @rating object as a children of @ptr.
 * if @ptr already contain an @rating object, then it is destroyed,
 * and updated to point to the provided @rating object.
 */
void idmefv2_confidence_set_rating(idmefv2_confidence_t *ptr, idmefv2_confidence_rating_t rating)
{
        libidmefv2_return_if_fail(ptr);
        ptr->rating = rating;
}
/**
 * idmefv2_confidence_new_rating:
 * @ptr: pointer to a #idmefv2_confidence_t object.
 * @ret: pointer to an address where to store the created #idmefv2_confidence_rating_t object.
 *
 * Create a new rating object, children of #idmefv2_confidence_t.
 * If @ptr already contain a #idmefv2_confidence_rating_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_confidence_new_rating(idmefv2_confidence_t *ptr, idmefv2_confidence_rating_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->rating;
        return 0;
}



/**
 * idmefv2_confidence_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_confidence_copy(const idmefv2_confidence_t *src, idmefv2_confidence_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->rating = src->rating;
    return 0 ;
}


/**
 * idmefv2_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_confidence_clone(idmefv2_confidence_t *src, idmefv2_confidence_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_confidence_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_confidence_copy(src, *dst);
}


/**
 * idmefv2_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_confidence_compare(const idmefv2_confidence_t *obj1, const idmefv2_confidence_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->rating != obj2->rating )
                return -1;
        return ret;
}


        



/**
 * idmefv2_impact_new:
 * @ret: Pointer where to store the created #idmefv2_impact_t object.
 *
 * Create a new #idmefv2_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_new(idmefv2_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_IMPACT;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->impact_type_list);














            return 0;
}


/**
 * idmefv2_impact_ref:
 * @impact: pointer to a #idmefv2_impact_t object.
 *
 * Increase @impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @impact.
 */
idmefv2_impact_t *idmefv2_impact_ref(idmefv2_impact_t *impact)
{
        libidmefv2_return_val_if_fail(impact, NULL);
        impact->refcount++;

        return impact;
}



int _idmefv2_impact_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_impact_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_SEVERITY , ptr->severity);

            case 1:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_COMPLETION , ptr->completion);

            case 2:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_AVAILABILITY , ptr->availability);

            case 3:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_INTEGRITY , ptr->integrity);

            case 4:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_IMPACT_CONFIDENTIALITY , ptr->confidentiality);


            case 5:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->description, TRUE);


            case 6:
                *childptr = &ptr->impact_type_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_impact_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_impact_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_impact_new_severity(ptr, (idmefv2_impact_severity_t **) ret);

                case 1:
                    return idmefv2_impact_new_completion(ptr, (idmefv2_impact_completion_t **) ret);

                case 2:
                    return idmefv2_impact_new_availability(ptr, (idmefv2_impact_availability_t **) ret);

                case 3:
                    return idmefv2_impact_new_integrity(ptr, (idmefv2_impact_integrity_t **) ret);

                case 4:
                    return idmefv2_impact_new_confidentiality(ptr, (idmefv2_impact_confidentiality_t **) ret);

                case 5:
                    return idmefv2_impact_new_description(ptr, (libidmefv2_string_t **) ret);

                case 6: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_impact_new_impact_type(ptr, (idmefv2_impact_type_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->impact_type_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->impact_type_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_impact_new_impact_type(ptr, (idmefv2_impact_type_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_impact_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_impact_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->severity = 0;
                    return 0;




                case 1:
                    ptr->completion = 0;
                    return 0;




                case 2:
                    ptr->availability = 0;
                    return 0;




                case 3:
                    ptr->integrity = 0;
                    return 0;




                case 4:
                    ptr->confidentiality = 0;
                    return 0;




                case 5:
                        if ( ptr->description ) {
                                libidmefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 6: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->impact_type_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_impact_type_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->impact_type_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_impact_type_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_impact_destroy_internal(idmefv2_impact_t *ptr)
{
        libidmefv2_return_if_fail(ptr);











        if ( ptr->description ) {
                libidmefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_impact_type_t *entry;

                libidmefv2_list_for_each_safe(&ptr->impact_type_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_impact_type_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_impact_destroy:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_impact_destroy(idmefv2_impact_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_impact_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_impact_get_severity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get severity children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a idmefv2_impact_severity_t object, or NULL if the children object is not set.
 */
idmefv2_impact_severity_t idmefv2_impact_get_severity(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity;

}


/**
 * idmefv2_impact_set_severity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @severity: pointer to a #idmefv2_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void idmefv2_impact_set_severity(idmefv2_impact_t *ptr, idmefv2_impact_severity_t severity)
{
        libidmefv2_return_if_fail(ptr);
        ptr->severity = severity;
}
/**
 * idmefv2_impact_new_severity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_severity_t object.
 *
 * Create a new severity object, children of #idmefv2_impact_t.
 * If @ptr already contain a #idmefv2_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_severity(idmefv2_impact_t *ptr, idmefv2_impact_severity_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->severity;
        return 0;
}



/**
 * idmefv2_impact_get_completion:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get completion children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a idmefv2_impact_completion_t object, or NULL if the children object is not set.
 */
idmefv2_impact_completion_t idmefv2_impact_get_completion(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->completion;

}


/**
 * idmefv2_impact_set_completion:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @completion: pointer to a #idmefv2_impact_completion_t object.
 *
 * Set @completion object as a children of @ptr.
 * if @ptr already contain an @completion object, then it is destroyed,
 * and updated to point to the provided @completion object.
 */
void idmefv2_impact_set_completion(idmefv2_impact_t *ptr, idmefv2_impact_completion_t completion)
{
        libidmefv2_return_if_fail(ptr);
        ptr->completion = completion;
}
/**
 * idmefv2_impact_new_completion:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_completion_t object.
 *
 * Create a new completion object, children of #idmefv2_impact_t.
 * If @ptr already contain a #idmefv2_impact_completion_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_completion(idmefv2_impact_t *ptr, idmefv2_impact_completion_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->completion;
        return 0;
}



/**
 * idmefv2_impact_get_availability:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get availability children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a idmefv2_impact_availability_t object, or NULL if the children object is not set.
 */
idmefv2_impact_availability_t idmefv2_impact_get_availability(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->availability;

}


/**
 * idmefv2_impact_set_availability:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @availability: pointer to a #idmefv2_impact_availability_t object.
 *
 * Set @availability object as a children of @ptr.
 * if @ptr already contain an @availability object, then it is destroyed,
 * and updated to point to the provided @availability object.
 */
void idmefv2_impact_set_availability(idmefv2_impact_t *ptr, idmefv2_impact_availability_t availability)
{
        libidmefv2_return_if_fail(ptr);
        ptr->availability = availability;
}
/**
 * idmefv2_impact_new_availability:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_availability_t object.
 *
 * Create a new availability object, children of #idmefv2_impact_t.
 * If @ptr already contain a #idmefv2_impact_availability_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_availability(idmefv2_impact_t *ptr, idmefv2_impact_availability_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->availability;
        return 0;
}



/**
 * idmefv2_impact_get_integrity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get integrity children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a idmefv2_impact_integrity_t object, or NULL if the children object is not set.
 */
idmefv2_impact_integrity_t idmefv2_impact_get_integrity(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->integrity;

}


/**
 * idmefv2_impact_set_integrity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @integrity: pointer to a #idmefv2_impact_integrity_t object.
 *
 * Set @integrity object as a children of @ptr.
 * if @ptr already contain an @integrity object, then it is destroyed,
 * and updated to point to the provided @integrity object.
 */
void idmefv2_impact_set_integrity(idmefv2_impact_t *ptr, idmefv2_impact_integrity_t integrity)
{
        libidmefv2_return_if_fail(ptr);
        ptr->integrity = integrity;
}
/**
 * idmefv2_impact_new_integrity:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_integrity_t object.
 *
 * Create a new integrity object, children of #idmefv2_impact_t.
 * If @ptr already contain a #idmefv2_impact_integrity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_integrity(idmefv2_impact_t *ptr, idmefv2_impact_integrity_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->integrity;
        return 0;
}



/**
 * idmefv2_impact_get_confidentiality:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get confidentiality children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a idmefv2_impact_confidentiality_t object, or NULL if the children object is not set.
 */
idmefv2_impact_confidentiality_t idmefv2_impact_get_confidentiality(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidentiality;

}


/**
 * idmefv2_impact_set_confidentiality:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @confidentiality: pointer to a #idmefv2_impact_confidentiality_t object.
 *
 * Set @confidentiality object as a children of @ptr.
 * if @ptr already contain an @confidentiality object, then it is destroyed,
 * and updated to point to the provided @confidentiality object.
 */
void idmefv2_impact_set_confidentiality(idmefv2_impact_t *ptr, idmefv2_impact_confidentiality_t confidentiality)
{
        libidmefv2_return_if_fail(ptr);
        ptr->confidentiality = confidentiality;
}
/**
 * idmefv2_impact_new_confidentiality:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_confidentiality_t object.
 *
 * Create a new confidentiality object, children of #idmefv2_impact_t.
 * If @ptr already contain a #idmefv2_impact_confidentiality_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_confidentiality(idmefv2_impact_t *ptr, idmefv2_impact_confidentiality_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->confidentiality;
        return 0;
}




/**
 * idmefv2_impact_get_description:
 * @ptr: pointer to a #idmefv2_impact_t object.
 *
 * Get description children of the #idmefv2_impact_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_impact_get_description(idmefv2_impact_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * idmefv2_impact_set_description:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @description: pointer to a #libidmefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void idmefv2_impact_set_description(idmefv2_impact_t *ptr, libidmefv2_string_t *description)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->description )
                libidmefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * idmefv2_impact_new_description:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new description object, children of #idmefv2_impact_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_description(idmefv2_impact_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libidmefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * idmefv2_impact_get_next_impact_type:
 * @impact: pointer to a #idmefv2_impact_t object.
 * @impact_type_cur: pointer to a #idmefv2_impact_type_t object.
 *
 * Get the next #idmefv2_impact_type_t object listed in @ptr.
 * When iterating over the idmefv2_impact_type_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_impact_type_t object.
 *
 * Returns: the next #idmefv2_impact_type_t in the list.
 */
idmefv2_impact_type_t *idmefv2_impact_get_next_impact_type(idmefv2_impact_t *impact, idmefv2_impact_type_t *impact_type_cur)
{
        libidmefv2_list_t *tmp = (impact_type_cur) ? &((libidmefv2_linked_object_t *) impact_type_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(impact, NULL);

        libidmefv2_list_for_each_continue(&impact->impact_type_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_impact_set_impact_type:
 * @ptr: pointer to a #idmefv2_impact_t object.
 * @object: pointer to a #idmefv2_impact_type_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_impact_type_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_impact_set_impact_type(idmefv2_impact_t *ptr, idmefv2_impact_type_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->impact_type_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_impact_new_impact_type:
 *  @ptr: pointer to a #idmefv2_impact_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_impact_type_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_impact_type_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_impact_type_t object. The created #idmefv2_impact_type_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_impact_new_impact_type(idmefv2_impact_t *ptr, idmefv2_impact_type_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_impact_type_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->impact_type_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_copy(const idmefv2_impact_t *src, idmefv2_impact_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->severity = src->severity;



        dst->completion = src->completion;



        dst->availability = src->availability;



        dst->integrity = src->integrity;



        dst->confidentiality = src->confidentiality;



        if ( dst->description ) {
                libidmefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libidmefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_impact_type_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->impact_type_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_impact_type_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->impact_type_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_impact_type_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->impact_type_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_impact_clone(idmefv2_impact_t *src, idmefv2_impact_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_impact_copy(src, *dst);
}


/**
 * idmefv2_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_impact_compare(const idmefv2_impact_t *obj1, const idmefv2_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->severity != obj2->severity )
                return -1;


        if ( obj1->completion != obj2->completion )
                return -1;


        if ( obj1->availability != obj2->availability )
                return -1;


        if ( obj1->integrity != obj2->integrity )
                return -1;


        if ( obj1->confidentiality != obj2->confidentiality )
                return -1;

        ret = libidmefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_impact_type_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->impact_type_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->impact_type_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_impact_type_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_recommanded_action_new:
 * @ret: Pointer where to store the created #idmefv2_recommanded_action_t object.
 *
 * Create a new #idmefv2_recommanded_action_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_recommanded_action_new(idmefv2_recommanded_action_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_RECOMMANDED_ACTION;



        libidmefv2_list_init(&((libidmefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



            return 0;
}


/**
 * idmefv2_recommanded_action_ref:
 * @recommanded_action: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Increase @recommanded_action reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @recommanded_action.
 */
idmefv2_recommanded_action_t *idmefv2_recommanded_action_ref(idmefv2_recommanded_action_t *recommanded_action)
{
        libidmefv2_return_val_if_fail(recommanded_action, NULL);
        recommanded_action->refcount++;

        return recommanded_action;
}



int _idmefv2_recommanded_action_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_recommanded_action_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return idmefv2_value_new_enum_from_numeric((idmefv2_value_t **) childptr,
                                                                IDMEFV2_CLASS_ID_RECOMMANDED_ACTION_ACTION , ptr->action);

            case 1:
                         return (ptr->step_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->step) : 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_recommanded_action_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_recommanded_action_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_recommanded_action_new_action(ptr, (idmefv2_recommanded_action_action_t **) ret);

                case 1:
                    return idmefv2_recommanded_action_new_step(ptr, (uint32_t **) ret);

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_recommanded_action_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_recommanded_action_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->action = 0;
                    return 0;

                case 1:
                        ptr->step_is_set = 0;
                        return 0;

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_recommanded_action_destroy_internal(idmefv2_recommanded_action_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *)ptr)->_list) )
               libidmefv2_list_del_init(&((libidmefv2_linked_object_t *)ptr)->_list);




        /* free() should be done by the caller */
}


/**
 * idmefv2_recommanded_action_destroy:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_recommanded_action_destroy(idmefv2_recommanded_action_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_recommanded_action_destroy_internal(ptr);
        free(ptr);
}




/**
 * idmefv2_recommanded_action_get_action:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Get action children of the #idmefv2_recommanded_action_t object.
 *
 * Returns: a pointer to a idmefv2_recommanded_action_action_t object, or NULL if the children object is not set.
 */
idmefv2_recommanded_action_action_t idmefv2_recommanded_action_get_action(idmefv2_recommanded_action_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->action;

}


/**
 * idmefv2_recommanded_action_set_action:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 * @action: pointer to a #idmefv2_recommanded_action_action_t object.
 *
 * Set @action object as a children of @ptr.
 * if @ptr already contain an @action object, then it is destroyed,
 * and updated to point to the provided @action object.
 */
void idmefv2_recommanded_action_set_action(idmefv2_recommanded_action_t *ptr, idmefv2_recommanded_action_action_t action)
{
        libidmefv2_return_if_fail(ptr);
        ptr->action = action;
}
/**
 * idmefv2_recommanded_action_new_action:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 * @ret: pointer to an address where to store the created #idmefv2_recommanded_action_action_t object.
 *
 * Create a new action object, children of #idmefv2_recommanded_action_t.
 * If @ptr already contain a #idmefv2_recommanded_action_action_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_recommanded_action_new_action(idmefv2_recommanded_action_t *ptr, idmefv2_recommanded_action_action_t **ret)
{



        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        *ret = &ptr->action;
        return 0;
}




/**
 * idmefv2_recommanded_action_get_step:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Get step children of the #idmefv2_recommanded_action_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_recommanded_action_get_step(idmefv2_recommanded_action_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->step_is_set ? &ptr->step : NULL;


}


/**
 * idmefv2_recommanded_action_set_step:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 * @step: pointer to a #uint32_t object.
 *
 * Set @step object as a children of @ptr.
 * if @ptr already contain an @step object, then it is destroyed,
 * and updated to point to the provided @step object.
 */
void idmefv2_recommanded_action_set_step(idmefv2_recommanded_action_t *ptr, uint32_t step)
{
        libidmefv2_return_if_fail(ptr);
        ptr->step = step;
        ptr->step_is_set = 1;
}

void idmefv2_recommanded_action_unset_step(idmefv2_recommanded_action_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->step_is_set = 0;
}
/**
 * idmefv2_recommanded_action_new_step:
 * @ptr: pointer to a #idmefv2_recommanded_action_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new step object, children of #idmefv2_recommanded_action_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_recommanded_action_new_step(idmefv2_recommanded_action_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->step_is_set = 1;



        *ret = &ptr->step;
        return 0;
}



/**
 * idmefv2_recommanded_action_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_recommanded_action_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_recommanded_action_copy(const idmefv2_recommanded_action_t *src, idmefv2_recommanded_action_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->action = src->action;


        dst->step_is_set = src->step_is_set;
        dst->step = src->step;
    return 0 ;
}


/**
 * idmefv2_recommanded_action_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_recommanded_action_clone(idmefv2_recommanded_action_t *src, idmefv2_recommanded_action_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_recommanded_action_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_recommanded_action_copy(src, *dst);
}


/**
 * idmefv2_recommanded_action_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_recommanded_action_compare(const idmefv2_recommanded_action_t *obj1, const idmefv2_recommanded_action_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->action != obj2->action )
                return -1;

        if ( obj1->step_is_set != obj2->step_is_set )
                return -1;

        if ( obj1->step_is_set && obj1->step != obj2->step )
                return -1;

        return ret;
}


        



/**
 * idmefv2_assessment_new:
 * @ret: Pointer where to store the created #idmefv2_assessment_t object.
 *
 * Create a new #idmefv2_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_assessment_new(idmefv2_assessment_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ASSESSMENT;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->taken_action_list);


        libidmefv2_list_init(&(*ret)->recommanded_action_list);









            return 0;
}


/**
 * idmefv2_assessment_ref:
 * @assessment: pointer to a #idmefv2_assessment_t object.
 *
 * Increase @assessment reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @assessment.
 */
idmefv2_assessment_t *idmefv2_assessment_ref(idmefv2_assessment_t *assessment)
{
        libidmefv2_return_val_if_fail(assessment, NULL);
        assessment->refcount++;

        return assessment;
}



int _idmefv2_assessment_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_assessment_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:
                *childptr = ptr->impact;
                return 0;

            case 1:
                *childptr = &ptr->taken_action_list;
                return 0;


            case 2:
                *childptr = ptr->confidence;
                return 0;

            case 3:
                *childptr = &ptr->recommanded_action_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_assessment_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_assessment_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_assessment_new_impact(ptr, (idmefv2_impact_t **) ret);

                case 1: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_assessment_new_taken_action(ptr, (idmefv2_taken_action_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->taken_action_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->taken_action_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_assessment_new_taken_action(ptr, (idmefv2_taken_action_t **) ret, n);
                }

                case 2:
                    return idmefv2_assessment_new_confidence(ptr, (idmefv2_confidence_t **) ret);

                case 3: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_assessment_new_recommanded_action(ptr, (idmefv2_recommanded_action_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->recommanded_action_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->recommanded_action_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_assessment_new_recommanded_action(ptr, (idmefv2_recommanded_action_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_assessment_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_assessment_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->impact ) {
                                idmefv2_impact_destroy(ptr->impact);
                                ptr->impact = NULL;
                        }

                        return 0;

    
                case 1: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->taken_action_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_taken_action_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->taken_action_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_taken_action_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 2:
                        if ( ptr->confidence ) {
                                idmefv2_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->recommanded_action_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_recommanded_action_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->recommanded_action_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_recommanded_action_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_assessment_destroy_internal(idmefv2_assessment_t *ptr)
{
        libidmefv2_return_if_fail(ptr);


        if ( ptr->impact ) {
                idmefv2_impact_destroy(ptr->impact);
                ptr->impact = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_taken_action_t *entry;

                libidmefv2_list_for_each_safe(&ptr->taken_action_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_taken_action_destroy(entry);
                }
        }


        if ( ptr->confidence ) {
                idmefv2_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_recommanded_action_t *entry;

                libidmefv2_list_for_each_safe(&ptr->recommanded_action_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_recommanded_action_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_assessment_destroy:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_assessment_destroy(idmefv2_assessment_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_assessment_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_assessment_get_impact:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 *
 * Get impact children of the #idmefv2_assessment_t object.
 *
 * Returns: a pointer to a idmefv2_impact_t object, or NULL if the children object is not set.
 */
idmefv2_impact_t *idmefv2_assessment_get_impact(idmefv2_assessment_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->impact;

}


/**
 * idmefv2_assessment_set_impact:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @impact: pointer to a #idmefv2_impact_t object.
 *
 * Set @impact object as a children of @ptr.
 * if @ptr already contain an @impact object, then it is destroyed,
 * and updated to point to the provided @impact object.
 */

void idmefv2_assessment_set_impact(idmefv2_assessment_t *ptr, idmefv2_impact_t *impact)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->impact )
                idmefv2_impact_destroy(ptr->impact);

        ptr->impact = impact;
}
/**
 * idmefv2_assessment_new_impact:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #idmefv2_impact_t object.
 *
 * Create a new impact object, children of #idmefv2_assessment_t.
 * If @ptr already contain a #idmefv2_impact_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_assessment_new_impact(idmefv2_assessment_t *ptr, idmefv2_impact_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->impact ) {
                retval = idmefv2_impact_new(&ptr->impact);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->impact;
        return 0;
}





/**
 * idmefv2_assessment_get_next_taken_action:
 * @assessment: pointer to a #idmefv2_assessment_t object.
 * @taken_action_cur: pointer to a #idmefv2_taken_action_t object.
 *
 * Get the next #idmefv2_taken_action_t object listed in @ptr.
 * When iterating over the idmefv2_taken_action_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_taken_action_t object.
 *
 * Returns: the next #idmefv2_taken_action_t in the list.
 */
idmefv2_taken_action_t *idmefv2_assessment_get_next_taken_action(idmefv2_assessment_t *assessment, idmefv2_taken_action_t *taken_action_cur)
{
        libidmefv2_list_t *tmp = (taken_action_cur) ? &((libidmefv2_linked_object_t *) taken_action_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(assessment, NULL);

        libidmefv2_list_for_each_continue(&assessment->taken_action_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_assessment_set_taken_action:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @object: pointer to a #idmefv2_taken_action_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_taken_action_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_assessment_set_taken_action(idmefv2_assessment_t *ptr, idmefv2_taken_action_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->taken_action_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_assessment_new_taken_action:
 *  @ptr: pointer to a #idmefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_taken_action_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_taken_action_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_taken_action_t object. The created #idmefv2_taken_action_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_assessment_new_taken_action(idmefv2_assessment_t *ptr, idmefv2_taken_action_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_taken_action_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->taken_action_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_assessment_get_confidence:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 *
 * Get confidence children of the #idmefv2_assessment_t object.
 *
 * Returns: a pointer to a idmefv2_confidence_t object, or NULL if the children object is not set.
 */
idmefv2_confidence_t *idmefv2_assessment_get_confidence(idmefv2_assessment_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;

}


/**
 * idmefv2_assessment_set_confidence:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @confidence: pointer to a #idmefv2_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void idmefv2_assessment_set_confidence(idmefv2_assessment_t *ptr, idmefv2_confidence_t *confidence)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->confidence )
                idmefv2_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}
/**
 * idmefv2_assessment_new_confidence:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #idmefv2_confidence_t object.
 *
 * Create a new confidence object, children of #idmefv2_assessment_t.
 * If @ptr already contain a #idmefv2_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_assessment_new_confidence(idmefv2_assessment_t *ptr, idmefv2_confidence_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = idmefv2_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->confidence;
        return 0;
}





/**
 * idmefv2_assessment_get_next_recommanded_action:
 * @assessment: pointer to a #idmefv2_assessment_t object.
 * @recommanded_action_cur: pointer to a #idmefv2_recommanded_action_t object.
 *
 * Get the next #idmefv2_recommanded_action_t object listed in @ptr.
 * When iterating over the idmefv2_recommanded_action_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_recommanded_action_t object.
 *
 * Returns: the next #idmefv2_recommanded_action_t in the list.
 */
idmefv2_recommanded_action_t *idmefv2_assessment_get_next_recommanded_action(idmefv2_assessment_t *assessment, idmefv2_recommanded_action_t *recommanded_action_cur)
{
        libidmefv2_list_t *tmp = (recommanded_action_cur) ? &((libidmefv2_linked_object_t *) recommanded_action_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(assessment, NULL);

        libidmefv2_list_for_each_continue(&assessment->recommanded_action_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_assessment_set_recommanded_action:
 * @ptr: pointer to a #idmefv2_assessment_t object.
 * @object: pointer to a #idmefv2_recommanded_action_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_recommanded_action_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_assessment_set_recommanded_action(idmefv2_assessment_t *ptr, idmefv2_recommanded_action_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->recommanded_action_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_assessment_new_recommanded_action:
 *  @ptr: pointer to a #idmefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_recommanded_action_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_recommanded_action_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_recommanded_action_t object. The created #idmefv2_recommanded_action_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_assessment_new_recommanded_action(idmefv2_assessment_t *ptr, idmefv2_recommanded_action_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_recommanded_action_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->recommanded_action_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_assessment_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_assessment_copy(const idmefv2_assessment_t *src, idmefv2_assessment_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;




        if ( dst->impact ) {
                idmefv2_impact_destroy(dst->impact);
                dst->impact = NULL;
        }

        if ( src->impact ) {
                ret = idmefv2_impact_clone(src->impact, &dst->impact);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_taken_action_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->taken_action_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_taken_action_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->taken_action_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_taken_action_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->taken_action_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->confidence ) {
                idmefv2_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = idmefv2_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_recommanded_action_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->recommanded_action_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_recommanded_action_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->recommanded_action_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_recommanded_action_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->recommanded_action_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_assessment_clone(idmefv2_assessment_t *src, idmefv2_assessment_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_assessment_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_assessment_copy(src, *dst);
}


/**
 * idmefv2_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_assessment_compare(const idmefv2_assessment_t *obj1, const idmefv2_assessment_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        ret = idmefv2_impact_compare(obj1->impact, obj2->impact);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_taken_action_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->taken_action_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->taken_action_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_taken_action_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = idmefv2_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_recommanded_action_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->recommanded_action_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->recommanded_action_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_recommanded_action_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_classification_new:
 * @ret: Pointer where to store the created #idmefv2_classification_t object.
 *
 * Create a new #idmefv2_classification_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_classification_new(idmefv2_classification_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_CLASSIFICATION;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->reference_list);



        {
            int retval = libidmefv2_string_new(&(*ret)->text);

            if ( retval < 0 ) {
                    idmefv2_classification_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


            return 0;
}


/**
 * idmefv2_classification_ref:
 * @classification: pointer to a #idmefv2_classification_t object.
 *
 * Increase @classification reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @classification.
 */
idmefv2_classification_t *idmefv2_classification_ref(idmefv2_classification_t *classification)
{
        libidmefv2_return_val_if_fail(classification, NULL);
        classification->refcount++;

        return classification;
}



int _idmefv2_classification_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_classification_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->ident, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->text, TRUE);


            case 2:
                *childptr = &ptr->reference_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_classification_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_classification_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_classification_new_ident(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_classification_new_text(ptr, (libidmefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_classification_new_reference(ptr, (idmefv2_reference_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->reference_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_classification_new_reference(ptr, (idmefv2_reference_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_classification_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_classification_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ident ) {
                                libidmefv2_string_destroy(ptr->ident);
                                ptr->ident = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->text ) {
                                libidmefv2_string_destroy(ptr->text);
                                ptr->text = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->reference_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_reference_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_reference_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_classification_destroy_internal(idmefv2_classification_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->ident ) {
                libidmefv2_string_destroy(ptr->ident);
                ptr->ident = NULL;
        }



        if ( ptr->text ) {
                libidmefv2_string_destroy(ptr->text);
                ptr->text = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_reference_t *entry;

                libidmefv2_list_for_each_safe(&ptr->reference_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_reference_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_classification_destroy:
 * @ptr: pointer to a #idmefv2_classification_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_classification_destroy(idmefv2_classification_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_classification_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_classification_get_ident:
 * @ptr: pointer to a #idmefv2_classification_t object.
 *
 * Get ident children of the #idmefv2_classification_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_classification_get_ident(idmefv2_classification_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ident;

}


/**
 * idmefv2_classification_set_ident:
 * @ptr: pointer to a #idmefv2_classification_t object.
 * @ident: pointer to a #libidmefv2_string_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmefv2_classification_set_ident(idmefv2_classification_t *ptr, libidmefv2_string_t *ident)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->ident )
                libidmefv2_string_destroy(ptr->ident);

        ptr->ident = ident;
}
/**
 * idmefv2_classification_new_ident:
 * @ptr: pointer to a #idmefv2_classification_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new ident object, children of #idmefv2_classification_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_classification_new_ident(idmefv2_classification_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->ident ) {
                retval = libidmefv2_string_new(&ptr->ident);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ident;
        return 0;
}




/**
 * idmefv2_classification_get_text:
 * @ptr: pointer to a #idmefv2_classification_t object.
 *
 * Get text children of the #idmefv2_classification_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_classification_get_text(idmefv2_classification_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->text;

}


/**
 * idmefv2_classification_set_text:
 * @ptr: pointer to a #idmefv2_classification_t object.
 * @text: pointer to a #libidmefv2_string_t object.
 *
 * Set @text object as a children of @ptr.
 * if @ptr already contain an @text object, then it is destroyed,
 * and updated to point to the provided @text object.
 */

void idmefv2_classification_set_text(idmefv2_classification_t *ptr, libidmefv2_string_t *text)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->text )
                libidmefv2_string_destroy(ptr->text);

        ptr->text = text;
}
/**
 * idmefv2_classification_new_text:
 * @ptr: pointer to a #idmefv2_classification_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new text object, children of #idmefv2_classification_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_classification_new_text(idmefv2_classification_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->text ) {
                retval = libidmefv2_string_new(&ptr->text);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->text;
        return 0;
}





/**
 * idmefv2_classification_get_next_reference:
 * @classification: pointer to a #idmefv2_classification_t object.
 * @reference_cur: pointer to a #idmefv2_reference_t object.
 *
 * Get the next #idmefv2_reference_t object listed in @ptr.
 * When iterating over the idmefv2_reference_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_reference_t object.
 *
 * Returns: the next #idmefv2_reference_t in the list.
 */
idmefv2_reference_t *idmefv2_classification_get_next_reference(idmefv2_classification_t *classification, idmefv2_reference_t *reference_cur)
{
        libidmefv2_list_t *tmp = (reference_cur) ? &((libidmefv2_linked_object_t *) reference_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(classification, NULL);

        libidmefv2_list_for_each_continue(&classification->reference_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_classification_set_reference:
 * @ptr: pointer to a #idmefv2_classification_t object.
 * @object: pointer to a #idmefv2_reference_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_reference_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_classification_set_reference(idmefv2_classification_t *ptr, idmefv2_reference_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->reference_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_classification_new_reference:
 *  @ptr: pointer to a #idmefv2_classification_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_reference_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_reference_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_reference_t object. The created #idmefv2_reference_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_classification_new_reference(idmefv2_classification_t *ptr, idmefv2_reference_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_reference_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->reference_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_classification_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_classification_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_classification_copy(const idmefv2_classification_t *src, idmefv2_classification_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ident ) {
                libidmefv2_string_destroy(dst->ident);
                dst->ident = NULL;
        }

        if ( src->ident ) {
                ret = libidmefv2_string_clone(src->ident, &dst->ident);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->text ) {
                ret = libidmefv2_string_copy(src->text, dst->text);
                if ( ret < 0 )
                        return ret;
        }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_reference_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->reference_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_reference_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->reference_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_reference_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->reference_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_classification_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_classification_clone(idmefv2_classification_t *src, idmefv2_classification_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_classification_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_classification_copy(src, *dst);
}


/**
 * idmefv2_classification_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_classification_compare(const idmefv2_classification_t *obj1, const idmefv2_classification_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->ident, obj2->ident);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->text, obj2->text);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_reference_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->reference_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->reference_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_reference_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_heartbeat_new:
 * @ret: Pointer where to store the created #idmefv2_heartbeat_t object.
 *
 * Create a new #idmefv2_heartbeat_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_heartbeat_new(idmefv2_heartbeat_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_HEARTBEAT;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->additional_data_list);


        {
            int retval = libidmefv2_string_new(&(*ret)->messageid);

            if ( retval < 0 ) {
                    idmefv2_heartbeat_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }



        {
            int retval = idmefv2_time_new(&(*ret)->create_time);

            if ( retval < 0 ) {
                    idmefv2_heartbeat_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
          idmefv2_time_set_from_gettimeofday((*ret)->create_time);



            return 0;
}


/**
 * idmefv2_heartbeat_ref:
 * @heartbeat: pointer to a #idmefv2_heartbeat_t object.
 *
 * Increase @heartbeat reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @heartbeat.
 */
idmefv2_heartbeat_t *idmefv2_heartbeat_ref(idmefv2_heartbeat_t *heartbeat)
{
        libidmefv2_return_val_if_fail(heartbeat, NULL);
        heartbeat->refcount++;

        return heartbeat;
}



int _idmefv2_heartbeat_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_heartbeat_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->messageid, TRUE);



            case 1:
                *childptr = ptr->analyzer;
                return 0;


            case 2:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->create_time, TRUE);


            case 3:
                         return (ptr->heartbeat_interval_is_set) ? idmefv2_value_new_uint32((idmefv2_value_t **) childptr, ptr->heartbeat_interval) : 0;

            case 4:
                *childptr = &ptr->additional_data_list;
                return 0;

            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_heartbeat_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_heartbeat_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_heartbeat_new_messageid(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_heartbeat_new_analyzer(ptr, (idmefv2_analyzer_t **) ret);

                case 2:
                    return idmefv2_heartbeat_new_create_time(ptr, (idmefv2_time_t **) ret);

                case 3:
                    return idmefv2_heartbeat_new_heartbeat_interval(ptr, (uint32_t **) ret);

                case 4: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_heartbeat_new_additional_data(ptr, (idmefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_heartbeat_new_additional_data(ptr, (idmefv2_additional_data_t **) ret, n);
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_heartbeat_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_heartbeat_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->messageid ) {
                                libidmefv2_string_destroy(ptr->messageid);
                                ptr->messageid = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->analyzer ) {
                                idmefv2_analyzer_destroy(ptr->analyzer);
                                ptr->analyzer = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->create_time ) {
                                idmefv2_time_destroy(ptr->create_time);
                                ptr->create_time = NULL;
                        }

                        return 0;

                case 3:
                        ptr->heartbeat_interval_is_set = 0;
                        return 0;

    
                case 4: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_heartbeat_destroy_internal(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->messageid ) {
                libidmefv2_string_destroy(ptr->messageid);
                ptr->messageid = NULL;
        }




        if ( ptr->analyzer ) {
                idmefv2_analyzer_destroy(ptr->analyzer);
                ptr->analyzer = NULL;
        }



        if ( ptr->create_time ) {
                idmefv2_time_destroy(ptr->create_time);
                ptr->create_time = NULL;
        }






        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_additional_data_t *entry;

                libidmefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_additional_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_heartbeat_destroy:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_heartbeat_destroy(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_heartbeat_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_heartbeat_get_messageid:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Get messageid children of the #idmefv2_heartbeat_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_heartbeat_get_messageid(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->messageid;

}


/**
 * idmefv2_heartbeat_set_messageid:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @messageid: pointer to a #libidmefv2_string_t object.
 *
 * Set @messageid object as a children of @ptr.
 * if @ptr already contain an @messageid object, then it is destroyed,
 * and updated to point to the provided @messageid object.
 */

void idmefv2_heartbeat_set_messageid(idmefv2_heartbeat_t *ptr, libidmefv2_string_t *messageid)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->messageid )
                libidmefv2_string_destroy(ptr->messageid);

        ptr->messageid = messageid;
}
/**
 * idmefv2_heartbeat_new_messageid:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new messageid object, children of #idmefv2_heartbeat_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_heartbeat_new_messageid(idmefv2_heartbeat_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->messageid ) {
                retval = libidmefv2_string_new(&ptr->messageid);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->messageid;
        return 0;
}




/**
 * idmefv2_heartbeat_get_analyzer:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Get analyzer children of the #idmefv2_heartbeat_t object.
 *
 * Returns: a pointer to a idmefv2_analyzer_t object, or NULL if the children object is not set.
 */
idmefv2_analyzer_t *idmefv2_heartbeat_get_analyzer(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analyzer;

}


/**
 * idmefv2_heartbeat_set_analyzer:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @analyzer: pointer to a #idmefv2_analyzer_t object.
 *
 * Set @analyzer object as a children of @ptr.
 * if @ptr already contain an @analyzer object, then it is destroyed,
 * and updated to point to the provided @analyzer object.
 */

void idmefv2_heartbeat_set_analyzer(idmefv2_heartbeat_t *ptr, idmefv2_analyzer_t *analyzer)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->analyzer )
                idmefv2_analyzer_destroy(ptr->analyzer);

        ptr->analyzer = analyzer;
}
/**
 * idmefv2_heartbeat_new_analyzer:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @ret: pointer to an address where to store the created #idmefv2_analyzer_t object.
 *
 * Create a new analyzer object, children of #idmefv2_heartbeat_t.
 * If @ptr already contain a #idmefv2_analyzer_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_heartbeat_new_analyzer(idmefv2_heartbeat_t *ptr, idmefv2_analyzer_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->analyzer ) {
                retval = idmefv2_analyzer_new(&ptr->analyzer);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->analyzer;
        return 0;
}




/**
 * idmefv2_heartbeat_get_create_time:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Get create_time children of the #idmefv2_heartbeat_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_heartbeat_get_create_time(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->create_time;

}


/**
 * idmefv2_heartbeat_set_create_time:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @create_time: pointer to a #idmefv2_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmefv2_heartbeat_set_create_time(idmefv2_heartbeat_t *ptr, idmefv2_time_t *create_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->create_time )
                idmefv2_time_destroy(ptr->create_time);

        ptr->create_time = create_time;
}
/**
 * idmefv2_heartbeat_new_create_time:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new create_time object, children of #idmefv2_heartbeat_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_heartbeat_new_create_time(idmefv2_heartbeat_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->create_time ) {
                retval = idmefv2_time_new(&ptr->create_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->create_time;
        return 0;
}




/**
 * idmefv2_heartbeat_get_heartbeat_interval:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 *
 * Get heartbeat_interval children of the #idmefv2_heartbeat_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmefv2_heartbeat_get_heartbeat_interval(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->heartbeat_interval_is_set ? &ptr->heartbeat_interval : NULL;


}


/**
 * idmefv2_heartbeat_set_heartbeat_interval:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @heartbeat_interval: pointer to a #uint32_t object.
 *
 * Set @heartbeat_interval object as a children of @ptr.
 * if @ptr already contain an @heartbeat_interval object, then it is destroyed,
 * and updated to point to the provided @heartbeat_interval object.
 */
void idmefv2_heartbeat_set_heartbeat_interval(idmefv2_heartbeat_t *ptr, uint32_t heartbeat_interval)
{
        libidmefv2_return_if_fail(ptr);
        ptr->heartbeat_interval = heartbeat_interval;
        ptr->heartbeat_interval_is_set = 1;
}

void idmefv2_heartbeat_unset_heartbeat_interval(idmefv2_heartbeat_t *ptr)
{
        libidmefv2_return_if_fail(ptr);
        ptr->heartbeat_interval_is_set = 0;
}
/**
 * idmefv2_heartbeat_new_heartbeat_interval:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new heartbeat_interval object, children of #idmefv2_heartbeat_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_heartbeat_new_heartbeat_interval(idmefv2_heartbeat_t *ptr, uint32_t **ret)
{


        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        ptr->heartbeat_interval_is_set = 1;



        *ret = &ptr->heartbeat_interval;
        return 0;
}





/**
 * idmefv2_heartbeat_get_next_additional_data:
 * @heartbeat: pointer to a #idmefv2_heartbeat_t object.
 * @additional_data_cur: pointer to a #idmefv2_additional_data_t object.
 *
 * Get the next #idmefv2_additional_data_t object listed in @ptr.
 * When iterating over the idmefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_additional_data_t object.
 *
 * Returns: the next #idmefv2_additional_data_t in the list.
 */
idmefv2_additional_data_t *idmefv2_heartbeat_get_next_additional_data(idmefv2_heartbeat_t *heartbeat, idmefv2_additional_data_t *additional_data_cur)
{
        libidmefv2_list_t *tmp = (additional_data_cur) ? &((libidmefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(heartbeat, NULL);

        libidmefv2_list_for_each_continue(&heartbeat->additional_data_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_heartbeat_set_additional_data:
 * @ptr: pointer to a #idmefv2_heartbeat_t object.
 * @object: pointer to a #idmefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_additional_data_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_heartbeat_set_additional_data(idmefv2_heartbeat_t *ptr, idmefv2_additional_data_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_heartbeat_new_additional_data:
 *  @ptr: pointer to a #idmefv2_heartbeat_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_additional_data_t object. The created #idmefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_heartbeat_new_additional_data(idmefv2_heartbeat_t *ptr, idmefv2_additional_data_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * idmefv2_heartbeat_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_heartbeat_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_heartbeat_copy(const idmefv2_heartbeat_t *src, idmefv2_heartbeat_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->messageid ) {
                ret = libidmefv2_string_copy(src->messageid, dst->messageid);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->analyzer ) {
                idmefv2_analyzer_destroy(dst->analyzer);
                dst->analyzer = NULL;
        }

        if ( src->analyzer ) {
                ret = idmefv2_analyzer_clone(src->analyzer, &dst->analyzer);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->create_time ) {
                ret = idmefv2_time_copy(src->create_time, dst->create_time);
                if ( ret < 0 )
                        return ret;
        }


        dst->heartbeat_interval_is_set = src->heartbeat_interval_is_set;
        dst->heartbeat_interval = src->heartbeat_interval;



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_additional_data_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_additional_data_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_additional_data_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->additional_data_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * idmefv2_heartbeat_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_heartbeat_clone(idmefv2_heartbeat_t *src, idmefv2_heartbeat_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_heartbeat_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_heartbeat_copy(src, *dst);
}


/**
 * idmefv2_heartbeat_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_heartbeat_compare(const idmefv2_heartbeat_t *obj1, const idmefv2_heartbeat_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->messageid, obj2->messageid);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_analyzer_compare(obj1->analyzer, obj2->analyzer);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->create_time, obj2->create_time);
        if ( ret != 0 )
                return ret;

        if ( obj1->heartbeat_interval_is_set != obj2->heartbeat_interval_is_set )
                return -1;

        if ( obj1->heartbeat_interval_is_set && obj1->heartbeat_interval != obj2->heartbeat_interval )
                return -1;



        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * idmefv2_alert_new:
 * @ret: Pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new #idmefv2_alert_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_alert_new(idmefv2_alert_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_ALERT;


        (*ret)->refcount = 1;

        libidmefv2_list_init(&(*ret)->analyzer_list);


        libidmefv2_list_init(&(*ret)->source_list);


        libidmefv2_list_init(&(*ret)->target_list);


        libidmefv2_list_init(&(*ret)->additional_data_list);


        {
            int retval = libidmefv2_string_new(&(*ret)->messageid);

            if ( retval < 0 ) {
                    idmefv2_alert_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libidmefv2_string_new(&(*ret)->analyzerhash);

            if ( retval < 0 ) {
                    idmefv2_alert_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }



        {
            int retval = idmefv2_time_new(&(*ret)->create_time);

            if ( retval < 0 ) {
                    idmefv2_alert_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
          idmefv2_time_set_from_gettimeofday((*ret)->create_time);


        {
            int retval = idmefv2_classification_new(&(*ret)->classification);

            if ( retval < 0 ) {
                    idmefv2_alert_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }













            return 0;
}


/**
 * idmefv2_alert_ref:
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Increase @alert reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @alert.
 */
idmefv2_alert_t *idmefv2_alert_ref(idmefv2_alert_t *alert)
{
        libidmefv2_return_val_if_fail(alert, NULL);
        alert->refcount++;

        return alert;
}



int _idmefv2_alert_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_alert_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->messageid, TRUE);



            case 1:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->analyzerhash, TRUE);


            case 2:
                *childptr = &ptr->analyzer_list;
                return 0;


            case 3:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->create_time, TRUE);



            case 4:
                *childptr = ptr->classification;
                return 0;


            case 5:

                return get_value_from_time((idmefv2_value_t **) childptr,  ptr->detect_time, TRUE);



            case 6:
                *childptr = ptr->analysis_data;
                return 0;

            case 7:
                *childptr = &ptr->source_list;
                return 0;

            case 8:
                *childptr = &ptr->target_list;
                return 0;


            case 9:
                *childptr = ptr->assessment;
                return 0;

            case 10:
                *childptr = &ptr->additional_data_list;
                return 0;

            case 11:
                *childptr = ( ptr->type == IDMEFV2_ALERT_TYPE_CORRELATION ) ? ptr->detail.correlation_alert : NULL;
                return 0;


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_alert_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_alert_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_alert_new_messageid(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_alert_new_analyzerhash(ptr, (libidmefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_alert_new_analyzer(ptr, (idmefv2_analyzer_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->analyzer_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->analyzer_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_alert_new_analyzer(ptr, (idmefv2_analyzer_t **) ret, n);
                }

                case 3:
                    return idmefv2_alert_new_create_time(ptr, (idmefv2_time_t **) ret);

                case 4:
                    return idmefv2_alert_new_classification(ptr, (idmefv2_classification_t **) ret);

                case 5:
                    return idmefv2_alert_new_detect_time(ptr, (idmefv2_time_t **) ret);

                case 6:
                    return idmefv2_alert_new_analysis_data(ptr, (idmefv2_analysis_data_t **) ret);

                case 7: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_alert_new_source(ptr, (idmefv2_source_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->source_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->source_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_alert_new_source(ptr, (idmefv2_source_t **) ret, n);
                }

                case 8: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_alert_new_target(ptr, (idmefv2_target_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->target_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->target_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_alert_new_target(ptr, (idmefv2_target_t **) ret, n);
                }

                case 9:
                    return idmefv2_alert_new_assessment(ptr, (idmefv2_assessment_t **) ret);

                case 10: {
                        int i = 0;
                        libidmefv2_list_t *tmp;

                        if ( n == IDMEFV2_LIST_APPEND || n == IDMEFV2_LIST_PREPEND )
                               return idmefv2_alert_new_additional_data(ptr, (idmefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libidmefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libidmefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libidmefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return idmefv2_alert_new_additional_data(ptr, (idmefv2_additional_data_t **) ret, n);
                }

                case 11:
                    return idmefv2_alert_new_correlation_alert(ptr, (idmefv2_correlation_alert_t **) ret);



                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_alert_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_alert_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->messageid ) {
                                libidmefv2_string_destroy(ptr->messageid);
                                ptr->messageid = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->analyzerhash ) {
                                libidmefv2_string_destroy(ptr->analyzerhash);
                                ptr->analyzerhash = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->analyzer_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_analyzer_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->analyzer_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_analyzer_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 3:
                        if ( ptr->create_time ) {
                                idmefv2_time_destroy(ptr->create_time);
                                ptr->create_time = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->classification ) {
                                idmefv2_classification_destroy(ptr->classification);
                                ptr->classification = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->detect_time ) {
                                idmefv2_time_destroy(ptr->detect_time);
                                ptr->detect_time = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->analysis_data ) {
                                idmefv2_analysis_data_destroy(ptr->analysis_data);
                                ptr->analysis_data = NULL;
                        }

                        return 0;

    
                case 7: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->source_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_source_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->source_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_source_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 8: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->target_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_target_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->target_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_target_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 9:
                        if ( ptr->assessment ) {
                                idmefv2_assessment_destroy(ptr->assessment);
                                ptr->assessment = NULL;
                        }

                        return 0;

    
                case 10: {
                    int i = 0;
                    libidmefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libidmefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libidmefv2_linked_object_get_object(tmp);
                                            idmefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libidmefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libidmefv2_linked_object_get_object(tmp);
                                        idmefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_TREE_INDEX_UNDEFINED);
                        }
                }


                case 11:
                        if (  ptr->type != IDMEFV2_ALERT_TYPE_CORRELATION )
                                return 0;
                        idmefv2_correlation_alert_destroy(ptr->detail.correlation_alert);
                        ptr->detail.correlation_alert = NULL;
                        ptr->type = 0;
                        return 0;



                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_alert_destroy_internal(idmefv2_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->messageid ) {
                libidmefv2_string_destroy(ptr->messageid);
                ptr->messageid = NULL;
        }



        if ( ptr->analyzerhash ) {
                libidmefv2_string_destroy(ptr->analyzerhash);
                ptr->analyzerhash = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_analyzer_t *entry;

                libidmefv2_list_for_each_safe(&ptr->analyzer_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_analyzer_destroy(entry);
                }
        }

        if ( ptr->create_time ) {
                idmefv2_time_destroy(ptr->create_time);
                ptr->create_time = NULL;
        }




        if ( ptr->classification ) {
                idmefv2_classification_destroy(ptr->classification);
                ptr->classification = NULL;
        }



        if ( ptr->detect_time ) {
                idmefv2_time_destroy(ptr->detect_time);
                ptr->detect_time = NULL;
        }




        if ( ptr->analysis_data ) {
                idmefv2_analysis_data_destroy(ptr->analysis_data);
                ptr->analysis_data = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_source_t *entry;

                libidmefv2_list_for_each_safe(&ptr->source_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_source_destroy(entry);
                }
        }


        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_target_t *entry;

                libidmefv2_list_for_each_safe(&ptr->target_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_target_destroy(entry);
                }
        }


        if ( ptr->assessment ) {
                idmefv2_assessment_destroy(ptr->assessment);
                ptr->assessment = NULL;
        }




        {
                libidmefv2_list_t *n, *tmp;
                idmefv2_additional_data_t *entry;

                libidmefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        libidmefv2_list_del_init(tmp);
                        idmefv2_additional_data_destroy(entry);
                }
        }


        switch ( ptr->type ) {
                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        idmefv2_correlation_alert_destroy(ptr->detail.correlation_alert);
                        ptr->detail.correlation_alert = NULL;
                        break;
                default:
                        break;
        }
        /* free() should be done by the caller */
}


/**
 * idmefv2_alert_destroy:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_alert_destroy(idmefv2_alert_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_alert_destroy_internal(ptr);
        free(ptr);
}





/**
 * idmefv2_alert_get_messageid:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get messageid children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_alert_get_messageid(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->messageid;

}


/**
 * idmefv2_alert_set_messageid:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @messageid: pointer to a #libidmefv2_string_t object.
 *
 * Set @messageid object as a children of @ptr.
 * if @ptr already contain an @messageid object, then it is destroyed,
 * and updated to point to the provided @messageid object.
 */

void idmefv2_alert_set_messageid(idmefv2_alert_t *ptr, libidmefv2_string_t *messageid)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->messageid )
                libidmefv2_string_destroy(ptr->messageid);

        ptr->messageid = messageid;
}
/**
 * idmefv2_alert_new_messageid:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new messageid object, children of #idmefv2_alert_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_messageid(idmefv2_alert_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->messageid ) {
                retval = libidmefv2_string_new(&ptr->messageid);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->messageid;
        return 0;
}




/**
 * idmefv2_alert_get_analyzerhash:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get analyzerhash children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_alert_get_analyzerhash(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analyzerhash;

}


/**
 * idmefv2_alert_set_analyzerhash:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @analyzerhash: pointer to a #libidmefv2_string_t object.
 *
 * Set @analyzerhash object as a children of @ptr.
 * if @ptr already contain an @analyzerhash object, then it is destroyed,
 * and updated to point to the provided @analyzerhash object.
 */

void idmefv2_alert_set_analyzerhash(idmefv2_alert_t *ptr, libidmefv2_string_t *analyzerhash)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->analyzerhash )
                libidmefv2_string_destroy(ptr->analyzerhash);

        ptr->analyzerhash = analyzerhash;
}
/**
 * idmefv2_alert_new_analyzerhash:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new analyzerhash object, children of #idmefv2_alert_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_analyzerhash(idmefv2_alert_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->analyzerhash ) {
                retval = libidmefv2_string_new(&ptr->analyzerhash);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->analyzerhash;
        return 0;
}





/**
 * idmefv2_alert_get_next_analyzer:
 * @alert: pointer to a #idmefv2_alert_t object.
 * @analyzer_cur: pointer to a #idmefv2_analyzer_t object.
 *
 * Get the next #idmefv2_analyzer_t object listed in @ptr.
 * When iterating over the idmefv2_analyzer_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_analyzer_t object.
 *
 * Returns: the next #idmefv2_analyzer_t in the list.
 */
idmefv2_analyzer_t *idmefv2_alert_get_next_analyzer(idmefv2_alert_t *alert, idmefv2_analyzer_t *analyzer_cur)
{
        libidmefv2_list_t *tmp = (analyzer_cur) ? &((libidmefv2_linked_object_t *) analyzer_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(alert, NULL);

        libidmefv2_list_for_each_continue(&alert->analyzer_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_alert_set_analyzer:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @object: pointer to a #idmefv2_analyzer_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_analyzer_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_alert_set_analyzer(idmefv2_alert_t *ptr, idmefv2_analyzer_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->analyzer_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_alert_new_analyzer:
 *  @ptr: pointer to a #idmefv2_alert_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_analyzer_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_analyzer_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_analyzer_t object. The created #idmefv2_analyzer_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_analyzer(idmefv2_alert_t *ptr, idmefv2_analyzer_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_analyzer_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->analyzer_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_alert_get_create_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get create_time children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_alert_get_create_time(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->create_time;

}


/**
 * idmefv2_alert_set_create_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @create_time: pointer to a #idmefv2_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmefv2_alert_set_create_time(idmefv2_alert_t *ptr, idmefv2_time_t *create_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->create_time )
                idmefv2_time_destroy(ptr->create_time);

        ptr->create_time = create_time;
}
/**
 * idmefv2_alert_new_create_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new create_time object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_create_time(idmefv2_alert_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->create_time ) {
                retval = idmefv2_time_new(&ptr->create_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->create_time;
        return 0;
}




/**
 * idmefv2_alert_get_classification:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get classification children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a idmefv2_classification_t object, or NULL if the children object is not set.
 */
idmefv2_classification_t *idmefv2_alert_get_classification(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->classification;

}


/**
 * idmefv2_alert_set_classification:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @classification: pointer to a #idmefv2_classification_t object.
 *
 * Set @classification object as a children of @ptr.
 * if @ptr already contain an @classification object, then it is destroyed,
 * and updated to point to the provided @classification object.
 */

void idmefv2_alert_set_classification(idmefv2_alert_t *ptr, idmefv2_classification_t *classification)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->classification )
                idmefv2_classification_destroy(ptr->classification);

        ptr->classification = classification;
}
/**
 * idmefv2_alert_new_classification:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_classification_t object.
 *
 * Create a new classification object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_classification_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_classification(idmefv2_alert_t *ptr, idmefv2_classification_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->classification ) {
                retval = idmefv2_classification_new(&ptr->classification);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->classification;
        return 0;
}




/**
 * idmefv2_alert_get_detect_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get detect_time children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a idmefv2_time_t object, or NULL if the children object is not set.
 */
idmefv2_time_t *idmefv2_alert_get_detect_time(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detect_time;

}


/**
 * idmefv2_alert_set_detect_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @detect_time: pointer to a #idmefv2_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void idmefv2_alert_set_detect_time(idmefv2_alert_t *ptr, idmefv2_time_t *detect_time)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->detect_time )
                idmefv2_time_destroy(ptr->detect_time);

        ptr->detect_time = detect_time;
}
/**
 * idmefv2_alert_new_detect_time:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_time_t object.
 *
 * Create a new detect_time object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_detect_time(idmefv2_alert_t *ptr, idmefv2_time_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->detect_time ) {
                retval = idmefv2_time_new(&ptr->detect_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->detect_time;
        return 0;
}




/**
 * idmefv2_alert_get_analysis_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get analysis_data children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a idmefv2_analysis_data_t object, or NULL if the children object is not set.
 */
idmefv2_analysis_data_t *idmefv2_alert_get_analysis_data(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->analysis_data;

}


/**
 * idmefv2_alert_set_analysis_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @analysis_data: pointer to a #idmefv2_analysis_data_t object.
 *
 * Set @analysis_data object as a children of @ptr.
 * if @ptr already contain an @analysis_data object, then it is destroyed,
 * and updated to point to the provided @analysis_data object.
 */

void idmefv2_alert_set_analysis_data(idmefv2_alert_t *ptr, idmefv2_analysis_data_t *analysis_data)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->analysis_data )
                idmefv2_analysis_data_destroy(ptr->analysis_data);

        ptr->analysis_data = analysis_data;
}
/**
 * idmefv2_alert_new_analysis_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_analysis_data_t object.
 *
 * Create a new analysis_data object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_analysis_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_analysis_data(idmefv2_alert_t *ptr, idmefv2_analysis_data_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->analysis_data ) {
                retval = idmefv2_analysis_data_new(&ptr->analysis_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->analysis_data;
        return 0;
}





/**
 * idmefv2_alert_get_next_source:
 * @alert: pointer to a #idmefv2_alert_t object.
 * @source_cur: pointer to a #idmefv2_source_t object.
 *
 * Get the next #idmefv2_source_t object listed in @ptr.
 * When iterating over the idmefv2_source_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_source_t object.
 *
 * Returns: the next #idmefv2_source_t in the list.
 */
idmefv2_source_t *idmefv2_alert_get_next_source(idmefv2_alert_t *alert, idmefv2_source_t *source_cur)
{
        libidmefv2_list_t *tmp = (source_cur) ? &((libidmefv2_linked_object_t *) source_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(alert, NULL);

        libidmefv2_list_for_each_continue(&alert->source_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_alert_set_source:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @object: pointer to a #idmefv2_source_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_source_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_alert_set_source(idmefv2_alert_t *ptr, idmefv2_source_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->source_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_alert_new_source:
 *  @ptr: pointer to a #idmefv2_alert_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_source_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_source_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_source_t object. The created #idmefv2_source_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_source(idmefv2_alert_t *ptr, idmefv2_source_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_source_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->source_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * idmefv2_alert_get_next_target:
 * @alert: pointer to a #idmefv2_alert_t object.
 * @target_cur: pointer to a #idmefv2_target_t object.
 *
 * Get the next #idmefv2_target_t object listed in @ptr.
 * When iterating over the idmefv2_target_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_target_t object.
 *
 * Returns: the next #idmefv2_target_t in the list.
 */
idmefv2_target_t *idmefv2_alert_get_next_target(idmefv2_alert_t *alert, idmefv2_target_t *target_cur)
{
        libidmefv2_list_t *tmp = (target_cur) ? &((libidmefv2_linked_object_t *) target_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(alert, NULL);

        libidmefv2_list_for_each_continue(&alert->target_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_alert_set_target:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @object: pointer to a #idmefv2_target_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_target_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_alert_set_target(idmefv2_alert_t *ptr, idmefv2_target_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->target_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_alert_new_target:
 *  @ptr: pointer to a #idmefv2_alert_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_target_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_target_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_target_t object. The created #idmefv2_target_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_target(idmefv2_alert_t *ptr, idmefv2_target_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_target_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->target_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * idmefv2_alert_get_assessment:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Get assessment children of the #idmefv2_alert_t object.
 *
 * Returns: a pointer to a idmefv2_assessment_t object, or NULL if the children object is not set.
 */
idmefv2_assessment_t *idmefv2_alert_get_assessment(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->assessment;

}


/**
 * idmefv2_alert_set_assessment:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @assessment: pointer to a #idmefv2_assessment_t object.
 *
 * Set @assessment object as a children of @ptr.
 * if @ptr already contain an @assessment object, then it is destroyed,
 * and updated to point to the provided @assessment object.
 */

void idmefv2_alert_set_assessment(idmefv2_alert_t *ptr, idmefv2_assessment_t *assessment)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->assessment )
                idmefv2_assessment_destroy(ptr->assessment);

        ptr->assessment = assessment;
}
/**
 * idmefv2_alert_new_assessment:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer to an address where to store the created #idmefv2_assessment_t object.
 *
 * Create a new assessment object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_assessment_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_assessment(idmefv2_alert_t *ptr, idmefv2_assessment_t **ret)
{


        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->assessment ) {
                retval = idmefv2_assessment_new(&ptr->assessment);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->assessment;
        return 0;
}





/**
 * idmefv2_alert_get_next_additional_data:
 * @alert: pointer to a #idmefv2_alert_t object.
 * @additional_data_cur: pointer to a #idmefv2_additional_data_t object.
 *
 * Get the next #idmefv2_additional_data_t object listed in @ptr.
 * When iterating over the idmefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmefv2_additional_data_t object.
 *
 * Returns: the next #idmefv2_additional_data_t in the list.
 */
idmefv2_additional_data_t *idmefv2_alert_get_next_additional_data(idmefv2_alert_t *alert, idmefv2_additional_data_t *additional_data_cur)
{
        libidmefv2_list_t *tmp = (additional_data_cur) ? &((libidmefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libidmefv2_return_val_if_fail(alert, NULL);

        libidmefv2_list_for_each_continue(&alert->additional_data_list, tmp)
                return libidmefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * idmefv2_alert_set_additional_data:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @object: pointer to a #idmefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #idmefv2_additional_data_t object.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void idmefv2_alert_set_additional_data(idmefv2_alert_t *ptr, idmefv2_additional_data_t *object, int pos)
{
        libidmefv2_return_if_fail(ptr);
        libidmefv2_return_if_fail(object);

        if ( ! libidmefv2_list_is_empty(&((libidmefv2_linked_object_t *) object)->_list) )
                libidmefv2_list_del_init(&((libidmefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libidmefv2_linked_object_t *) object)->_list, pos);
}


/**
 * idmefv2_alert_new_additional_data:
 *  @ptr: pointer to a #idmefv2_alert_t object.
 *  @ret: pointer to an address where to store the created #idmefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #idmefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #idmefv2_additional_data_t object. The created #idmefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IDMEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IDMEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_additional_data(idmefv2_alert_t *ptr, idmefv2_additional_data_t **ret, int pos)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        retval = idmefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libidmefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * idmefv2_alert_get_type:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_type_t children, or NULL if it is not set.
 */
idmefv2_alert_type_t idmefv2_alert_get_type(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        return ptr->type;
}
/**
 * idmefv2_alert_get_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 *
 * Access the correlation_alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_correlation_alert_t children, or NULL if it is not set.
 */
idmefv2_correlation_alert_t *idmefv2_alert_get_correlation_alert(idmefv2_alert_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, NULL);
        return (ptr->type == IDMEFV2_ALERT_TYPE_CORRELATION) ? ptr->detail.correlation_alert : NULL;
}

/**
 * idmefv2_alert_set_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @correlation_alert: pointer to a #idmefv2_correlation_alert_t object.
 *
 * Set @correlation_alert object as a children of @ptr.
 * if @ptr already contain a @correlation_alert object, then it is destroyed,
 * and updated to point to the provided @correlation_alert object.
 */
void idmefv2_alert_set_correlation_alert(idmefv2_alert_t *ptr, idmefv2_correlation_alert_t *correlation_alert)
{
        libidmefv2_return_if_fail(ptr);

        switch ( ptr->type ) {
                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        idmefv2_correlation_alert_destroy(ptr->detail.correlation_alert);
                        break;
                default:
                        break;
        }
        ptr->detail.correlation_alert = correlation_alert;
        ptr->type = (correlation_alert) ? IDMEFV2_ALERT_TYPE_CORRELATION : 0;
}
/**
 * idmefv2_alert_new_correlation_alert:
 * @ptr: pointer to a #idmefv2_alert_t object.
 * @ret: pointer where to store the created #idmefv2_correlation_alert_t object.
 *
 * Create a new idmefv2_correlation_alert_t object, children of #idmefv2_alert_t.
 * If @ptr already contain a #idmefv2_correlation_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_alert_new_correlation_alert(idmefv2_alert_t *ptr, idmefv2_correlation_alert_t **ret)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( ptr->type ) {

                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        *ret = ptr->detail.correlation_alert;
                        return 0;

                default:
                        break;
        }

        retval = idmefv2_correlation_alert_new(ret);
        if ( retval < 0 )
                return retval;

        ptr->type = IDMEFV2_ALERT_TYPE_CORRELATION;
        ptr->detail.correlation_alert = *ret;

        return 0;
}



/**
 * idmefv2_alert_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_alert_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_alert_copy(const idmefv2_alert_t *src, idmefv2_alert_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->messageid ) {
                ret = libidmefv2_string_copy(src->messageid, dst->messageid);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->analyzerhash ) {
                ret = libidmefv2_string_copy(src->analyzerhash, dst->analyzerhash);
                if ( ret < 0 )
                        return ret;
        }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_analyzer_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->analyzer_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_analyzer_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->analyzer_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_analyzer_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->analyzer_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }


        if ( src->create_time ) {
                ret = idmefv2_time_copy(src->create_time, dst->create_time);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->classification ) {
                ret = idmefv2_classification_copy(src->classification, dst->classification);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->detect_time ) {
                idmefv2_time_destroy(dst->detect_time);
                dst->detect_time = NULL;
        }

        if ( src->detect_time ) {
                ret = idmefv2_time_clone(src->detect_time, &dst->detect_time);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->analysis_data ) {
                idmefv2_analysis_data_destroy(dst->analysis_data);
                dst->analysis_data = NULL;
        }

        if ( src->analysis_data ) {
                ret = idmefv2_analysis_data_clone(src->analysis_data, &dst->analysis_data);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_source_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->source_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_source_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->source_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_source_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->source_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_target_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->target_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_target_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->target_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_target_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->target_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->assessment ) {
                idmefv2_assessment_destroy(dst->assessment);
                dst->assessment = NULL;
        }

        if ( src->assessment ) {
                ret = idmefv2_assessment_clone(src->assessment, &dst->assessment);
                if ( ret < 0 )
                        return ret;
        }




         {
                libidmefv2_list_t *n, *tmp;
                idmefv2_additional_data_t *entry, *new;
                libidmefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_additional_data_destroy(entry);
                 }

                libidmefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libidmefv2_linked_object_get_object(tmp);
                        idmefv2_additional_data_clone(entry, &new);
                        libidmefv2_list_add_tail(&dst->additional_data_list, &((libidmefv2_linked_object_t *) new)->_list);
                 }

 }




        switch ( src->type ) {
                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        ret = idmefv2_correlation_alert_clone(src->detail.correlation_alert, &dst->detail.correlation_alert);
                        break;
                default:
                        break;
        }

        if ( ret < 0 )
               return ret;

        dst->type = src->type;
    return 0 ;
}


/**
 * idmefv2_alert_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_alert_clone(idmefv2_alert_t *src, idmefv2_alert_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_alert_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_alert_copy(src, *dst);
}


/**
 * idmefv2_alert_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_alert_compare(const idmefv2_alert_t *obj1, const idmefv2_alert_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->messageid, obj2->messageid);
        if ( ret != 0 )
                return ret;

        ret = libidmefv2_string_compare(obj1->analyzerhash, obj2->analyzerhash);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_analyzer_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->analyzer_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->analyzer_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_analyzer_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = idmefv2_time_compare(obj1->create_time, obj2->create_time);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_classification_compare(obj1->classification, obj2->classification);
        if ( ret != 0 )
                return ret;

        ret = idmefv2_time_compare(obj1->detect_time, obj2->detect_time);
        if ( ret != 0 )
                return ret;


        ret = idmefv2_analysis_data_compare(obj1->analysis_data, obj2->analysis_data);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_source_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->source_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->source_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_source_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_target_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->target_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->target_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_target_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = idmefv2_assessment_compare(obj1->assessment, obj2->assessment);
        if ( ret != 0 )
                return ret;


        {
            libidmefv2_list_t *tmp1, *tmp2;
            idmefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libidmefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libidmefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libidmefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libidmefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = idmefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        if ( obj1->type != obj2->type )
                return -1;

        switch ( obj1->type ) {
                case IDMEFV2_ALERT_TYPE_CORRELATION:
                        ret = idmefv2_correlation_alert_compare(obj1->detail.correlation_alert, obj2->detail.correlation_alert);
                        break;
                default:
                        break;
        }
        return ret;
}


        



/**
 * idmefv2_message_new:
 * @ret: Pointer where to store the created #idmefv2_message_t object.
 *
 * Create a new #idmefv2_message_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_message_new(idmefv2_message_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libidmefv2_error_from_errno(errno);

        (*ret)->_idmefv2_object_id = IDMEFV2_CLASS_ID_MESSAGE;


        (*ret)->refcount = 1;

        {
            int retval = libidmefv2_string_new(&(*ret)->version);

            if ( retval < 0 ) {
                    idmefv2_message_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


            return 0;
}


/**
 * idmefv2_message_ref:
 * @message: pointer to a #idmefv2_message_t object.
 *
 * Increase @message reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @message.
 */
idmefv2_message_t *idmefv2_message_ref(idmefv2_message_t *message)
{
        libidmefv2_return_val_if_fail(message, NULL);
        message->refcount++;

        return message;
}



int _idmefv2_message_get_child(void *p, idmefv2_class_child_id_t child, void **childptr)
{
    idmefv2_message_t *ptr = p;

    libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((idmefv2_value_t **) childptr,  ptr->version, TRUE);


            case 1:
                *childptr = ( ptr->type == IDMEFV2_MESSAGE_TYPE_ALERT ) ? ptr->message.alert : NULL;
                return 0;

            case 2:
                *childptr = ( ptr->type == IDMEFV2_MESSAGE_TYPE_HEARTBEAT ) ? ptr->message.heartbeat : NULL;
                return 0;


            default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_message_new_child(void *p, idmefv2_class_child_id_t child, int n, void **ret)
{
        idmefv2_message_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return idmefv2_message_new_version(ptr, (libidmefv2_string_t **) ret);

                case 1:
                    return idmefv2_message_new_alert(ptr, (idmefv2_alert_t **) ret);


                case 2:
                    return idmefv2_message_new_heartbeat(ptr, (idmefv2_heartbeat_t **) ret);



                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _idmefv2_message_destroy_child(void *p, idmefv2_class_child_id_t child, int n)
{
        idmefv2_message_t *ptr = p;
        libidmefv2_return_val_if_fail(p, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->version ) {
                                libidmefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;


                case 1:
                        if (  ptr->type != IDMEFV2_MESSAGE_TYPE_ALERT )
                                return 0;
                        idmefv2_alert_destroy(ptr->message.alert);
                        ptr->message.alert = NULL;
                        ptr->type = 0;
                        return 0;

                case 2:
                        if (  ptr->type != IDMEFV2_MESSAGE_TYPE_HEARTBEAT )
                                return 0;
                        idmefv2_heartbeat_destroy(ptr->message.heartbeat);
                        ptr->message.heartbeat = NULL;
                        ptr->type = 0;
                        return 0;



                default:
                    return libidmefv2_error(LIBIDMEFV2_ERROR_IDMEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void idmefv2_message_destroy_internal(idmefv2_message_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( ptr->version ) {
                libidmefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }




        switch ( ptr->type ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        idmefv2_alert_destroy(ptr->message.alert);
                        ptr->message.alert = NULL;
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        idmefv2_heartbeat_destroy(ptr->message.heartbeat);
                        ptr->message.heartbeat = NULL;
                        break;
                default:
                        break;
        }
        /* free() should be done by the caller */
}







/**
 * idmefv2_message_get_version:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Get version children of the #idmefv2_message_t object.
 *
 * Returns: a pointer to a libidmefv2_string_t object, or NULL if the children object is not set.
 */
libidmefv2_string_t *idmefv2_message_get_version(idmefv2_message_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * idmefv2_message_set_version:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @version: pointer to a #libidmefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void idmefv2_message_set_version(idmefv2_message_t *ptr, libidmefv2_string_t *version)
{
        libidmefv2_return_if_fail(ptr);
        if ( ptr->version )
                libidmefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * idmefv2_message_new_version:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @ret: pointer to an address where to store the created #libidmefv2_string_t object.
 *
 * Create a new version object, children of #idmefv2_message_t.
 * If @ptr already contain a #libidmefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_message_new_version(idmefv2_message_t *ptr, libidmefv2_string_t **ret)
{





        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libidmefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}


/**
 * idmefv2_message_get_type:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_message_type_t children, or NULL if it is not set.
 */
idmefv2_message_type_t idmefv2_message_get_type(idmefv2_message_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        return ptr->type;
}
/**
 * idmefv2_message_get_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_alert_t children, or NULL if it is not set.
 */
idmefv2_alert_t *idmefv2_message_get_alert(idmefv2_message_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, NULL);
        return (ptr->type == IDMEFV2_MESSAGE_TYPE_ALERT) ? ptr->message.alert : NULL;
}

/**
 * idmefv2_message_set_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @alert: pointer to a #idmefv2_alert_t object.
 *
 * Set @alert object as a children of @ptr.
 * if @ptr already contain a @alert object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void idmefv2_message_set_alert(idmefv2_message_t *ptr, idmefv2_alert_t *alert)
{
        libidmefv2_return_if_fail(ptr);

        switch ( ptr->type ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        idmefv2_alert_destroy(ptr->message.alert);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        idmefv2_heartbeat_destroy(ptr->message.heartbeat);
                        break;
                default:
                        break;
        }
        ptr->message.alert = alert;
        ptr->type = (alert) ? IDMEFV2_MESSAGE_TYPE_ALERT : 0;
}
/**
 * idmefv2_message_new_alert:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_alert_t object.
 *
 * Create a new idmefv2_alert_t object, children of #idmefv2_message_t.
 * If @ptr already contain a #idmefv2_alert_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_message_new_alert(idmefv2_message_t *ptr, idmefv2_alert_t **ret)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( ptr->type ) {

                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        *ret = ptr->message.alert;
                        return 0;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        idmefv2_heartbeat_destroy(ptr->message.heartbeat);
                        break;

                default:
                        break;
        }

        retval = idmefv2_alert_new(ret);
        if ( retval < 0 )
                return retval;

        ptr->type = IDMEFV2_MESSAGE_TYPE_ALERT;
        ptr->message.alert = *ret;

        return 0;
}
/**
 * idmefv2_message_get_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Access the heartbeat children of @ptr.
 *
 * Returns: a pointer to the #idmefv2_heartbeat_t children, or NULL if it is not set.
 */
idmefv2_heartbeat_t *idmefv2_message_get_heartbeat(idmefv2_message_t *ptr)
{
        libidmefv2_return_val_if_fail(ptr, NULL);
        return (ptr->type == IDMEFV2_MESSAGE_TYPE_HEARTBEAT) ? ptr->message.heartbeat : NULL;
}

/**
 * idmefv2_message_set_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @heartbeat: pointer to a #idmefv2_heartbeat_t object.
 *
 * Set @heartbeat object as a children of @ptr.
 * if @ptr already contain a @heartbeat object, then it is destroyed,
 * and updated to point to the provided @heartbeat object.
 */
void idmefv2_message_set_heartbeat(idmefv2_message_t *ptr, idmefv2_heartbeat_t *heartbeat)
{
        libidmefv2_return_if_fail(ptr);

        switch ( ptr->type ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        idmefv2_alert_destroy(ptr->message.alert);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        idmefv2_heartbeat_destroy(ptr->message.heartbeat);
                        break;
                default:
                        break;
        }
        ptr->message.heartbeat = heartbeat;
        ptr->type = (heartbeat) ? IDMEFV2_MESSAGE_TYPE_HEARTBEAT : 0;
}
/**
 * idmefv2_message_new_heartbeat:
 * @ptr: pointer to a #idmefv2_message_t object.
 * @ret: pointer where to store the created #idmefv2_heartbeat_t object.
 *
 * Create a new idmefv2_heartbeat_t object, children of #idmefv2_message_t.
 * If @ptr already contain a #idmefv2_heartbeat_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmefv2_message_new_heartbeat(idmefv2_message_t *ptr, idmefv2_heartbeat_t **ret)
{
        int retval;

        libidmefv2_return_val_if_fail(ptr, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        switch ( ptr->type ) {

                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        idmefv2_alert_destroy(ptr->message.alert);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        *ret = ptr->message.heartbeat;
                        return 0;

                default:
                        break;
        }

        retval = idmefv2_heartbeat_new(ret);
        if ( retval < 0 )
                return retval;

        ptr->type = IDMEFV2_MESSAGE_TYPE_HEARTBEAT;
        ptr->message.heartbeat = *ret;

        return 0;
}



/**
 * idmefv2_message_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #idmefv2_message_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_message_copy(const idmefv2_message_t *src, idmefv2_message_t *dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));
        libidmefv2_return_val_if_fail(dst, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->version ) {
                ret = libidmefv2_string_copy(src->version, dst->version);
                if ( ret < 0 )
                        return ret;
        }




        switch ( src->type ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        ret = idmefv2_alert_clone(src->message.alert, &dst->message.alert);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        ret = idmefv2_heartbeat_clone(src->message.heartbeat, &dst->message.heartbeat);
                        break;
                default:
                        break;
        }

        if ( ret < 0 )
               return ret;

        dst->type = src->type;
    return 0 ;
}


/**
 * idmefv2_message_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmefv2_message_clone(idmefv2_message_t *src, idmefv2_message_t **dst)
{
        int ret;

        libidmefv2_return_val_if_fail(src, libidmefv2_error(LIBIDMEFV2_ERROR_ASSERTION));

        ret = idmefv2_message_new(dst);
        if ( ret < 0 )
                return ret;

        return idmefv2_message_copy(src, *dst);
}


/**
 * idmefv2_message_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmefv2_message_compare(const idmefv2_message_t *obj1, const idmefv2_message_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libidmefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;

        switch ( obj1->type ) {
                case IDMEFV2_MESSAGE_TYPE_ALERT:
                        ret = idmefv2_alert_compare(obj1->message.alert, obj2->message.alert);
                        break;
                case IDMEFV2_MESSAGE_TYPE_HEARTBEAT:
                        ret = idmefv2_heartbeat_compare(obj1->message.heartbeat, obj2->message.heartbeat);
                        break;
                default:
                        break;
        }
        return ret;
}



int _idmefv2_additional_data_type_is_set(idmefv2_additional_data_t *ad)
{
        return ad->_type_is_set;
}

/**
 * idmefv2_message_destroy:
 * @ptr: pointer to a #idmefv2_message_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmefv2_message_destroy(idmefv2_message_t *ptr)
{
        libidmefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmefv2_message_destroy_internal(ptr);


        free(ptr);
}


